{"meta":{"title":"Hi There","subtitle":"If people do not believe that mathematics is simple, it is only because they do not realize how complicated life is. – John von Neumann.","description":"","author":"isFibonacci","url":"http://yoursite.com","root":"/"},"pages":[{"title":"","date":"2020-02-09T23:48:28.829Z","updated":"2020-02-09T23:48:28.829Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"","date":"2020-02-09T23:48:36.379Z","updated":"2020-02-09T23:48:36.379Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"My Blog Name | 404","date":"2020-02-11T18:27:50.835Z","updated":"2020-02-11T18:27:50.835Z","comments":true,"path":"404.html","permalink":"http://yoursite.com/404.html","excerpt":"","text":""}],"posts":[{"title":"Greedy Algorithm","slug":"greedy algorithm","date":"2020-02-11T01:55:00.000Z","updated":"2020-02-11T17:12:15.913Z","comments":true,"path":"2020/02/10/greedy algorithm/","link":"","permalink":"http://yoursite.com/2020/02/10/greedy%20algorithm/","excerpt":"","text":"860. Lemonade Change1234567Input: [5,5,5,10,20]Output: trueExplanation: From the first 3 customers, we collect three $5 bills in order.From the fourth customer, we collect a $10 bill and give back a $5.From the fifth customer, we give a $10 bill and a $5 bill.Since all customers got correct change, we output true. 123451. Every time we choose the largest one to exchange, like 20 -&gt; 10 + 52. if use 10 to exchange 5 we will have 10, so ten +&#x3D; 13. for 20 case, we cannot just return false if there is not 10, since we can use 5+5+5 to exchange4. make sure temp &#x3D;&#x3D; 0t to quit, otherwise we will have negative temp 123456789101112131415161718192021222324252627282930313233class Solution: def lemonadeChange(self, bills: List[int]) -&gt; bool: five, ten = 0, 0 for cur in bills : if cur == 5 : five += 1 if cur == 10 : #need 5 if five : five -= 1 #exchange to ten, so ten +1 ten += 1 else : return False if cur == 20 : #need 15 temp = 15 if ten : ten -= 1 temp -= 10 #cannot return false, bc we can return 5+5+5 while five and temp: #make sure when temp = 0 quit, or it will loop to negative five -= 1 temp -= 5 if temp : return False return True 392. Is Subsequence123456789Example 1:s &#x3D; &quot;abc&quot;, t &#x3D; &quot;ahbgdc&quot;Return true.Example 2:s &#x3D; &quot;axc&quot;, t &#x3D; &quot;ahbgdc&quot;Return false. 11. Two pointers, make suer k lease than len(s) 123456789class Solution: def isSubsequence(self, s: str, t: str) -&gt; bool: i, k = 0, 0 while i &lt; len(t) and k &lt; len(s) : if s[k] == t[i] : k += 1 i += 1 return k == len(s) 455. Assign Cookies12345678Input: [1,2,3], [1,1]Output: 1Explanation: You have 3 children and 2 cookies. The greed factors of 3 children are 1, 2, 3. And even though you have 2 cookies, since their size is both 1, you could only make the child whose greed factor is 1 content.You need to output 1. 1234567891011121314151617181920class Solution: def findContentChildren(self, g: List[int], s: List[int]) -&gt; int: #who come first, give the cookies to him g = sorted(g) s = sorted(s) res, j = 0, 0 for i in range (len(g)) : #not satisified while j &lt; len(s) and s[j] &lt; g[i] : j += 1 #satisified if j &lt; len(s) : res += 1 #make sure j += 1, bc have used j += 1 return res 55. Jump Game1234Input: [3,2,1,0,4]Output: falseExplanation: You will always arrive at index 3 no matter what. Its maximum jump length is 0, which makes it impossible to reach the last index. 12345678910111213141516class Solution: def canJump(self, nums: List[int]) -&gt; bool: n = len(nums) if n == 0 : return True i, maxDist = 0, 0 #maxDist : the maximum position you can arrive so far while i &lt; n and i &lt;= maxDist : # if i &gt; maxDist, we cannnot get i position maxDist = max(i + nums[i], maxDist) i += 1 # [3, 1, 2, 0] -&gt; i = 0, maxDist = 3, we can arrive i = 3 maximum; # i = 2, maxDist = 2 + 2 = 4, arrive i = 4 maximum return maxDist &gt;= n-1 #not maxDist &gt;= i, bc after loop i+= 1 &gt; n-1 45. Jump Game II1234Input: [2,3,1,1,4]Output: 2Explanation: The minimum number of jumps to reach the last index is 2. Jump 1 step from index 0 to 1, then 3 steps to the last index. At i = 0, if choose jump 2 -&gt; i = 2, we can only jump 1 -&gt; i = 3we can only jump 1 -&gt; i = 4so total is 3 At i = 0, if choose jump 1 -&gt; i = 1, we can jump 3 -&gt; i = 4so total is 4 12345678910111213141516Proof : f[i] &gt; f[i+1] is wrongf[i] : the minimum steps to arrive if[i+1] : the minimum steps to arrive i+1we prove f[i] &lt;&#x3D; f[i+1] is correctAssume at j, we need to arrive at i+1. j+nums[j] &gt;&#x3D; i+1[2, 3, 1, 1, 4]j &#x3D; 0, i+1 &#x3D; 1j+nums[j] &#x3D; 0+2, we can arrive position at 2 maximumAssume we at j, and want to arrive at i+1, we need to jump plus 1f[i+1] &#x3D; f[j] + 1we can also arrive at i by f[j] + 1 steps at leastso f[i] &#x3D; f[j] + 1Hence, f[i] &lt;&#x3D; f[i+1] 123456789101112131415161718192021222324class Solution: def jump(self, nums: List[int]) -&gt; int: n = len(nums) if n == 0 or n == 1: return 0 l, r, step = 0, 0, 0 while l &lt;= r : # we check at each postion we can jump how far maxDist = 0 for i in range(l, r+1) : # want to check l == r, l &lt;= r so r+1 # maxDist : at i position, how far we can jump maxDist = max(i+nums[i], maxDist) l = r+1 # can arrive at r at least r = maxDist step += 1 if r &gt;= n-1 : break return step","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/categories/leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/tags/leetcode/"},{"name":"greedy algorithm","slug":"greedy-algorithm","permalink":"http://yoursite.com/tags/greedy-algorithm/"}],"author":"isFibonacci"},{"title":"Informed search","slug":"Informed-search","date":"2020-02-10T22:18:00.000Z","updated":"2020-02-10T22:41:10.774Z","comments":true,"path":"2020/02/10/Informed-search/","link":"","permalink":"http://yoursite.com/2020/02/10/Informed-search/","excerpt":"","text":"In uninformed search, we only had the nodeinformation (parent, children, cost of actions) Now we will assume there is some additionalinformation, we will call a heuristic thatestimates the distance to the goal Previously, we had no idea how close we wereto goal, simply how far we had gone already 1. Greedy best-first searchThis search will simply repeatedly select thechild with the lowest heuristic(cost to goal est.) In fact, it is not guaranteed to converge (if apath reaches a dead-end, it will loop infinitely) 2. A* (a star) upload successful Priority queues can be used to efficiently storeand insert states and their f-values into the fringe Good heuristics can remove “bad” sections of the search space that will not be on any optimal solution (called pruning) A* is optimal and in fact, no optimal algorithm could expand less nodes (optimally efficient) However, the time and memory cost is still exponential (memory tighter constraint) 2.1 Iterative deepening A* Run DFS in IDS, but instead of using depthas cutoff, use f-cost If search fails to find goal, increase f-costto next smallest seen value (above old cost) Pros: Efficient on memory Cons: Large (LARGE) amount of re-searching","categories":[{"name":"AI","slug":"AI","permalink":"http://yoursite.com/categories/AI/"}],"tags":[],"author":"isFibonacci"},{"title":"Inheritance and Polymorphism in C++ (2)","slug":"Inheritance and Polymorphism in C++ (2)","date":"2020-02-07T22:56:00.000Z","updated":"2020-02-11T18:22:17.857Z","comments":true,"path":"2020/02/07/Inheritance and Polymorphism in C++ (2)/","link":"","permalink":"http://yoursite.com/2020/02/07/Inheritance%20and%20Polymorphism%20in%20C++%20(2)/","excerpt":"","text":"Overriding member functionsOverriding vs. overloadingIn overloading, functions with the same name must have different parameter types. In overriding, a derived class member function takes precedence over a base class member function with the same name, regardless of the parameter types. Overloading is not performed if derived and base member functions have different parameter types; the member function of the derived class hides the member function of the base class. Restaurant’s GetDescription() must be identical to Business’s GetDescription() name, return type, and parameter list. 1234567891011121314151617181920212223class Business &#123; public: ... string GetDescription() const &#123; return name + \" -- \" + address; protected: string name; string address;&#125;;class Restaurant : public Business &#123; public: ... string GetDescription() const &#123; return name + \" -- \" + address + \"\\n Rating: \" + to_string(rating); private: int rating;&#125;; Or you can call it conveniently : 12345678910class Restaurant : public Business &#123; ... string GetDescription() const &#123; return Business::GetDescription() + \"\\n Rating: \" + to_string(rating); &#125;; ...&#125;; Without the prepended base class name, the call to GetDescription() refers to itself (a recursive call) 123456789101112131415161718192021222324252627282930class Computer &#123;public: void SetComputerStatus(string cpuStatus, string internetStatus) &#123; cpuUsage = cpuStatus; internet = internetStatus; &#125;; void PrintStatus() &#123; cout &lt;&lt; \"CPU: \" &lt;&lt; cpuUsage &lt;&lt; endl; cout &lt;&lt; \"Internet: \" &lt;&lt; internet &lt;&lt; endl; &#125;;protected: string cpuUsage; string internet;&#125;;class Laptop : public Computer &#123;public: void SetComputerStatus(string cpuStatus, string internetStatus, string wifiStatus) &#123; cpuUsage = cpuStatus; internet = internetStatus; wifiQuality = wifiStatus; &#125;; void PrintStatus() &#123; Computer::PrintStatus(); cout &lt;&lt; \"WiFi: \" &lt;&lt; wifiQuality &lt;&lt; endl; &#125;; Polymorphism and virtual member functions Compile-time polymorphism is when the compiler determines which function to call at compile-time. Runtime polymorphism is when the compiler is unable to determine which function to call at compile-time, so the determination is made while the program is running. Function overloading is an example of compile-time polymorphism where the compiler determines which of several identically-named functions to call based on the function’s arguments. compile-time polymorphismconvert the Restaurant pointer to a Business pointer 1234567891011void DriveTo(string restaurant) &#123; cout &lt;&lt; \"Driving to \" &lt;&lt; restaurant &lt;&lt; endl;&#125;void DriveTo(Restaurant restaurant) &#123; cout &lt;&lt; \"Driving to \" &lt;&lt; restaurant.GetDescription() &lt;&lt; endl;&#125;int main() &#123; DriveTo(\"Big Mac's\"); // Call string version&#125; runtime polymorphism12345678910111213141516void DriveTo(Business* businessPtr) &#123; cout &lt;&lt; \"Driving to \" &lt;&lt; businessPtr-&gt;GetDescription() &lt;&lt; endl;&#125;int main() &#123; int index; vector&lt;Business*&gt; businessList; Business* businessPtr; Restaurant* restaurantPtr; ... businessList.push_back(businessPtr); businessList.push_back(restaurantPtr); index = rand() % businessList.size(); DriveTo(businessList.at(index);&#125; derived/base class pointer conversion :a pointer to a derived class is converted to a pointer to the base class without explicit casting The above statement businessList.push_back(restaurantPtr); uses derived/base class pointer conversion to convert the Restaurant pointer to a Business pointer (businessList is a vector of Business pointers). When derived/base class pointer conversion takes place, the compiler is unable to use compile-time polymorphism. Virtual functionsA virtual function is a member function that may be overridden in a derived class and is used for runtime polymorphism. 123456789101112131415161718192021222324252627282930class Business &#123;public: string GetDescription() const &#123; return name + \" -- \" + address; &#125; ...&#125;;class Restaurant : public Business &#123;public: string GetDescription() const &#123; return name + \" -- \" + address + \"\\n Rating: \" + to_string(rating); &#125; ...&#125;;int main() &#123; Business* businessPtr; Restaurant favoriteCafe; favoriteCafe.SetName(\"Friends Cafe\"); favoriteCafe.SetAddress(\"500 2nd Ave\"); favoriteCafe.SetRating(5); // Point to favoriteCafe businessPtr = &amp;favoriteCafe; cout &lt;&lt; businessPtr-&gt;GetDescription();&#125; businessPtr points to favoriteCafe. businessPtr-&gt;GetDesciption() calls Business GetDescription()instead of Restaurant GetDescription() because runtime polymorphism does not work without virtual functions. 12345678910111213141516171819202122232425class Business &#123;public: virtual string GetDescription() const &#123; return name + \" -- \" + address; &#125; ...&#125;;class Restaurant : public Business &#123;public: string GetDescription() const override &#123; return name + \" -- \" + address + \"\\n Rating: \" + to_string(rating); &#125; ...&#125;;int main() &#123; ... vector&lt;Business*&gt; businessList; Business* businessPtr; Restaurant* restaurantPtr; ...&#125; The “virtual” keyword makes GetDescription() a virtual function. The “override” keyword indicates that Restaurant GetDescription() overrides the base class GetDescription(). Running the program with an overridden virtual function causes runtime polymorphism to call Restaurant GetDescription(). Another way : 123void PrintDescription(Business&amp; business) &#123; cout &lt;&lt; business.GetDescription() &lt;&lt; endl;&#125; Runtime polymorphism only works with pointers to derived classes. 12345Restaurant favoritePlace;favoritePlace.SetName(\"Friends Cafe\");favoritePlace.SetAddress(\"500 2nd Ave\");favoritePlace.SetRating(5);cout &lt;&lt; favoritePlace.GetDescription(); The compiler can tell from the code that a Restaurant object is calling GetDescription(), so the overridden GetDescription() is called. Pure virtual functionsA pure virtual function is a virtual function that provides no definition in the base class, and all derived classes must override the function A class that has at least one pure virtual function is known as an abstract base class. An abstract base class object cannot be declared. Ex: The variable declaration Business someBusiness; generates a syntax error if Business is an abstract base class. 1234567891011121314151617181920class Business &#123;public: void SetName(string busName) &#123; name = busName; &#125; void SetAddress(string busAddress) &#123; address = busAddress; &#125; virtual string GetDescription() const &#123; return name + \" -- \" + address; &#125; virtual string GetHours() const = 0; // pure virtual functionprotected: string name; string address;&#125;;","categories":[{"name":"Program Language","slug":"Program-Language","permalink":"http://yoursite.com/categories/Program-Language/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"}],"author":"isFibonacci"},{"title":"Inheritance and Polymorphism in C++ (1)","slug":"Inheritance and Polymorphism in C++ (1)","date":"2020-02-07T22:56:00.000Z","updated":"2020-02-11T18:22:07.557Z","comments":true,"path":"2020/02/07/Inheritance and Polymorphism in C++ (1)/","link":"","permalink":"http://yoursite.com/2020/02/07/Inheritance%20and%20Polymorphism%20in%20C++%20(1)/","excerpt":"","text":"Access by members of derived classesThe members of a derived class have access to the public members of the base class, but not to the private members of the base class. 1234567891011121314151617181920212223class Business &#123; public: ... private: string name; string address;&#125;;class Restaurant : public Business &#123; public: ... void DisplayRestaurant() &#123; cout &lt;&lt; name &lt;&lt; endl; cout &lt;&lt; address &lt;&lt; endl; cout &lt;&lt; \" Rating: \" &lt;&lt; rating &lt;&lt; endl; &#125; private: int rating;&#125;; Solution :A third access specifier is protected, which provides access to derived classes but not by anyone else. But! Careful here : A third access specifier is protected, which provides access to derived classes but not by anyone else. 1234567891011121314151617181920212223242526272829303132333435363738394041class Business &#123; public: // Members accessible by anyone void PrintMembers(); protected: // Members accessible by self and derived classes string name; private: // Members accessible only by self string address;&#125;;class Restaurant : public Business &#123; ... // Attempted accesses PrintMembers(); // OK name = \"Gyro Hero\"; // OK (\"protected\" above made this possible) address = \"5 Fifth St\"; // ERROR ...&#125;;int main() &#123; ... Business business; Restaurant restaurant; ... // Attempted accesses business.PrintMembers(); // OK business.name = \"Gyro Hero\"; // ERROR (protected only applies to derived classes) business.address = \"5 Fifth St\"; // ERROR restaurant.PrintMembers(); // OK restaurant.name = \"Gyro Hero\"; // ERROR restaurant.rating = 5; // ERROR return 0;&#125;","categories":[{"name":"Program Language","slug":"Program-Language","permalink":"http://yoursite.com/categories/Program-Language/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"}],"author":"isFibonacci"},{"title":"Inheritance and Polymorphism in C++ (3)","slug":"Inheritance and Polymorphism in C++ (3)","date":"2020-02-07T22:56:00.000Z","updated":"2020-02-11T18:21:39.155Z","comments":true,"path":"2020/02/07/Inheritance and Polymorphism in C++ (3)/","link":"","permalink":"http://yoursite.com/2020/02/07/Inheritance%20and%20Polymorphism%20in%20C++%20(3)/","excerpt":"","text":"Abstract classes: Introduction (generic)Object-oriented programming (OOP) : Classes Inheritance Abstract classes","categories":[{"name":"Program Language","slug":"Program-Language","permalink":"http://yoursite.com/categories/Program-Language/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"}],"author":"isFibonacci"},{"title":"Uniformed Search","slug":"Search","date":"2020-02-07T01:55:00.000Z","updated":"2020-02-10T20:37:24.365Z","comments":true,"path":"2020/02/06/Search/","link":"","permalink":"http://yoursite.com/2020/02/06/Search/","excerpt":"","text":"Uniformed Searcha. In deterministic environments the search solution is a single sequence (list of actions) b. Stochastic environments need multiple sequences to account for all possible outcomes of actions c. There are 5 parts to search: 1. Initial state 2. Actions possible at each state 3. Transition model (result of each action) 4. Goal test (are we there yet?) 5. Path costs/weights (not stored in states) (related to performance measure) Search algorithm BFS: FIFO The search algorithms metrics/criteria: 1. Completeness (does it terminate with a valid solution) 2. Optimality (is the answer the best solution) 3. Time (in big-O notation) 4. Space (big-O) b = maximum branching factor d = minimum depth of a goal m = maximum length of any path a. Uniform-cost search The only modification is when exploring a node we cannot disregard it if it has already been explored by another node We might have found a shorter path and thus need to update the cost on that node We also do not terminate when we find a goal, but instead when the goal has the lowest cost in the queue. UCS is.. 1. Complete (if costs strictly greater than 0) 2. Optimal However.... 3&amp;4. Time complexity = space complexity = O(b1+C*/min(path cost)), where C* cost of optimal solution (much worse than BFS) b. Bidirectional search It starts from both the goal and start (using BFS) until the trees meet This is better as 2*(bd/2) &lt; bd (the space is much worse than IDS, so only applicable to small problems)![upload successful](/images/pasted-7.png =100x) DFS: FILOMetrics: 1. Might not terminate (not correct) (e.g. in vacuum world, if first expand is action L) 2. Non-optimal (just… no) 3. Time complexity = O(bd ) 4. Space complexity = O(b*d) Only way this is better than BFS is the space complexity… DFS by itself is not great, but it has two (very) useful modifications a. Depth limited search It runs normal DFS, but if it is at a specified depth limit, you cannot have children (i.e. take another action) However, if you pick the depth limit before d, you will not find a solution (not correct, but will terminate) b. iterative deepening DFSThis search performs depth limited search with maximum depth 1, then maximum depth 2, then 3… until it finds a solution The first few states do get re-checked multiple times in IDS, however it is not too many When you find the solution at depth d, depth 1 is expanded d times (at most b of them) The second depth are expanded d-1 times (at most b2 of them) Thus upload successful Metrics: 1. Complete 2. Non-optimal (unless uniform cost) 3. O(bd ) 4. O(b*d) Thus IDS is better in every way than BFS (asymptotically) Best uninformed we will talk about","categories":[{"name":"AI","slug":"AI","permalink":"http://yoursite.com/categories/AI/"}],"tags":[{"name":"Search","slug":"Search","permalink":"http://yoursite.com/tags/Search/"}],"author":"isFibonacci"},{"title":"Some thoughts on AI","slug":"Some-thoughts-about-AI","date":"2020-02-06T03:45:00.000Z","updated":"2020-02-10T01:53:04.424Z","comments":true,"path":"2020/02/05/Some-thoughts-about-AI/","link":"","permalink":"http://yoursite.com/2020/02/05/Some-thoughts-about-AI/","excerpt":"","text":"Recently, there has been a lot of concerns about AI(artificial intelligence), like AI will make people lose jobs and the tech oligarch will make wealth inequality; in brief, AI will raise abundant social issues over than its advantage to society. On the contrary, some people argues that AI will bring abundant jobs instead. Like in the past, some people concerned that industrial revolution will take away people’s jobs but we know this revolution promote society development and then bring many opening jobs. However, I still believe there are many reasons to be concerned about advances of AI. As the automation is developing, we can see in the near future; millions of people will be replaced by the machines. The reasons I concerned are that there are many advantages in automation over than humans. First, machines will never feel tired. Mentioned in this article, I believe ”the self-driving trucks promised by Tesla’s Elon Musk become widely available in the next decade.” (Bossmann, 2016). Human drivers need to take a break after long driving, but self-driving trucks not. Self-driving car can keep long driving during the midnight to avoid rush hours in the daytime, and self-driving car has a lower risk of accidents than humans after long driving. Absolutely, transportation company will hire robots to drive rather than humans in obvious these advances. Hence, we can see in the near future; AI will take away many people’s jobs, and the unemployment rate will be increasing rapidly. What if AI turn to hurt humans? Hollywood movies have presented many AI disasters for us. And in this article, the author mentioned a vivid example: in order to kill the cancer, the machine kills everyone on the planet instead, which is more efficient. (Bossmann, 2016). As we know, the real world is really complicated. It is hard to just use some if-else statements to cover all the cases, like we are hard to predicate the future. So, in more specific, how can we ensure that the robot will not hurt human in a complicate case like rescue hostages? How can we ensure human will still dominate the world if one day we totally lose the ingenuity and intelligence than AI? As one day AI can evolve them very efficiently by iteration? How can we protect ourselves if robots start to attack people? How can we ensure we can still dominate the world, not AI dominate us? Or AI can just create a pandemic breaks out the world, which is the most efficient way to kill all the organism on this planet. Or like the movie, The Matrix, people are imprisoned in a container as a energy source? Obviously, there are still many issues that AI will bring to us. So I believe govern- ments, industries, and academics should take some steps to address these issues. First, since the automation take place of many people’s job, the unemployment rate will be in- creasing. Government should make some effectual policy to against unemployment. For example, Andrew Yang proposes government to pay one thousand dollars each month to every American over the age of 18. This money is from company’s VAT(A Value-Added Tax), and then people use the money to consumer company’s product. (Yang, 2020). This is a double win. No need to say, there are still a lot of issues that AI will bring to us in the future, but government should take its strong right to control these issues. Second, industries and academics should make some principles or agreement during the AI development. Like The Institute for Ethical ML, this academic institute make 8 principles when designing and developing AI and ML.(for Ethical AI ML, 2020). In that 8 principles, the developer commit to assess and handle the impact of incorrect result. So I believe the developers can take a great effort to avoid accident due to AI, and even when the accident happens, they can reduce losses. In brief, We have reasons to be concerned about advances of AI.And there are still many steps to address these issues, but the only principle we need to make sure is, artificial intelligence is conducive to improving the efficiency of social work and promoting social development. References J. Bossmann. Top 9 ethical issues in artificial intelligence. 2016. URL https://www.weforum.org/agenda/2016/10/top-10-ethical-issues -in-artificial-intelligence.I. for Ethical AI ML. The 7 Most Pressing Ethical Issues in Artificial Intelligence. 2020. URL https://ethical.institute/principles.html.A. Yang. VALUE-ADDED TAX. 2020. URL https://www.yang2020.com/policies/value-added-tax/.","categories":[{"name":"AI","slug":"AI","permalink":"http://yoursite.com/categories/AI/"}],"tags":[],"author":"isFibonacci"},{"title":"Build your own blog","slug":"hello-world","date":"2020-02-01T15:22:00.000Z","updated":"2020-02-10T01:53:43.591Z","comments":true,"path":"2020/02/01/hello-world/","link":"","permalink":"http://yoursite.com/2020/02/01/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment Change ThemeThe theme I used in this blog is cited from yscoder 1.git clone -&gt; after all install -&gt; move theme to your hexo theme and 12hexo ghexo d Careful here, if in the _config.yml you set it as 123deploy: type: git branch: master The hexo d will delete your custom domin name!What should do is here","categories":[],"tags":[],"author":"isFibonacci"}]}