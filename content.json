{"meta":{"title":"Hi There","subtitle":"If people do not believe that mathematics is simple, it is only because they do not realize how complicated life is. – John von Neumann.","description":"Computer Sicence | University of Minnesota, twin cities","author":"isFibonacci","url":"http://yoursite.com","root":"/"},"pages":[{"title":"","date":"2020-02-09T23:48:28.829Z","updated":"2020-02-09T23:48:28.829Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"","date":"2020-02-09T23:48:36.379Z","updated":"2020-02-09T23:48:36.379Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"Oops | 404","date":"2020-02-12T02:33:34.647Z","updated":"2020-02-12T02:33:34.647Z","comments":true,"path":"404.html","permalink":"http://yoursite.com/404.html","excerpt":"","text":""}],"posts":[{"title":"Pointers and Dynamic Memory Allocation(1)","slug":"title:  Pointers and Dynamic Memory All","date":"2020-02-12T01:55:00.000Z","updated":"2020-02-13T15:06:13.970Z","comments":true,"path":"2020/02/11/title:  Pointers and Dynamic Memory All/","link":"","permalink":"http://yoursite.com/2020/02/11/title:%20%20Pointers%20and%20Dynamic%20Memory%20All/","excerpt":"","text":"PointerIn vecotr, if the capacity is over size, vector will expand the size, and point toanother continous memory. reference, deference123456789101112131415int someInt;int* valPointer; someInt = 5;cout &lt;&lt; \"someInt address is \" &lt;&lt; &amp;someInt &lt;&lt; endl;valPointer = &amp;someInt; cout &lt;&lt; \"valPointer is \" &lt;&lt; valPointer &lt;&lt; endl;cout &lt;&lt; \"*valPointer is \" &lt;&lt; *valPointer &lt;&lt; endl;*valPointer = 10; // Changes someInt to 10cout &lt;&lt; \"someInt is \" &lt;&lt; someInt &lt;&lt; endl;cout &lt;&lt; \"*valPointer is \" &lt;&lt; *valPointer &lt;&lt; endl; 12345someInt address is 76valPointer is 76*valPointer is76someInt is 10*valPointer is 10 COMMON ERROR 12345671. prog.cpp:10:13: error: invalid conversion from &#39;int&#39; to &#39;int*&#39; [-fpermissive] int *ptr &#x3D; var; CORRECT : int *ptr &#x3D; &amp;var;2. Segmentation Fault (SIGSEGV), dereferencing unknown address *ptr &#x3D; var; Three ways12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//Pass-by-Value int square1(int n) &#123; //Address of n in square1() is not the same as n1 in main() cout &lt;&lt; \"address of n1 in square1(): \" &lt;&lt; &amp;n &lt;&lt; \"\\n\"; // clone modified inside the function n *= n; return n; &#125; //Pass-by-Reference with Pointer Arguments void square2(int *n) &#123; //Address of n in square2() is the same as n2 in main() cout &lt;&lt; \"address of n2 in square2(): \" &lt;&lt; n &lt;&lt; \"\\n\"; // Explicit de-referencing to get the value pointed-to *n *= *n; &#125; //Pass-by-Reference with Reference Arguments void square3(int &amp;n) &#123; //Address of n in square3() is the same as n3 in main() cout &lt;&lt; \"address of n3 in square3(): \" &lt;&lt; &amp;n &lt;&lt; \"\\n\"; // Implicit de-referencing (without '*') n *= n; &#125; ... //Call-by-Value int n1=8; cout &lt;&lt; \"address of n1 in main(): \" &lt;&lt; &amp;n1 &lt;&lt; \"\\n\"; cout &lt;&lt; \"Square of n1: \" &lt;&lt; square1(n1) &lt;&lt; \"\\n\"; cout &lt;&lt; \"No change in n1: \" &lt;&lt; n1 &lt;&lt; \"\\n\"; //Call-by-Reference with Pointer Arguments int n2=8; cout &lt;&lt; \"address of n2 in main(): \" &lt;&lt; &amp;n2 &lt;&lt; \"\\n\"; square2(&amp;n2); cout &lt;&lt; \"Square of n2: \" &lt;&lt; n2 &lt;&lt; \"\\n\"; cout &lt;&lt; \"Change reflected in n2: \" &lt;&lt; n2 &lt;&lt; \"\\n\"; //Call-by-Reference with Reference Arguments int n3=8; cout &lt;&lt; \"address of n3 in main(): \" &lt;&lt; &amp;n3 &lt;&lt; \"\\n\"; square3(n3); cout &lt;&lt; \"Square of n3: \" &lt;&lt; n3 &lt;&lt; \"\\n\"; cout &lt;&lt; \"Change reflected in n3: \" &lt;&lt; n3 &lt;&lt; \"\\n\"; ... OUTPUT 123456789101112address of n1 in main(): 0x7ffcf4d06e2caddress of n1 in square1(): 0x7ffcf4d06e0cSquare of n1: 64No change in n1: 8address of n2 in main(): 0x7ffcf4d06e30address of n2 in square2(): 0x7ffcf4d06e30Square of n2: 64Change reflected in n2: 64address of n3 in main(): 0x7ffcf4d06e34address of n3 in square3(): 0x7ffcf4d06e34Square of n3: 64Change reflected in n3: 64 COMMON ERROR 12345678910cout &lt;&lt; &quot;Square of n1: &quot; &lt;&lt; square1(n1) &lt;&lt; &quot;\\n&quot;; void square1(n1) &#123; ... cout &lt;&lt; &quot;address of n1 in square1(): &quot; &lt;&lt; &amp;n &lt;&lt; &quot;\\n&quot;; ...&#125;call square1(n1) -&gt; call cout :address of n1 in square1(): 0x7ffcf4d06e0cSquare of n1: 64 Array Name as Pointers1234567891011121314void test() &#123; //Declare an array int val[3] = &#123; 5, 10, 20 &#125;; //declare pointer variable int *ptr; //Assign the address of val[0] to ptr // We can use ptr=&amp;val[0];(both are same) ptr = val ; cout &lt;&lt; \"Elements of the array are: \"; cout &lt;&lt; ptr[0] &lt;&lt; \" \" &lt;&lt; *(++ptr) &lt;&lt; \" \" &lt;&lt; val[2]; &#125; OUTPUT 1Elements of the array are: 5 10 20 NULLWhen a pointer is declared, the pointer variable holds an unknown address until the pointer is initialized.A programmer may wish to indicate that a pointer points to “nothing” by initializing a pointer to null 12345678910111213141516171819void PrintValue(int* valuePointer) &#123; if (valuePointer == nullptr) &#123; cout &lt;&lt; \"Pointer is null\" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; *valuePointer &lt;&lt; endl; &#125;&#125;int main() &#123; int someInt = 5; int* valPointer = nullptr; PrintValue(valPointer); valPointer = &amp;someInt; PrintValue(valPointer); return 0;&#125; Operators:new, delete, and -&gt; The new operator allocates memory for the given type and returns a pointer to the allocated memory. If the type is a class, the new operator calls the class’s constructor after allocating memory for the class’s member variables. 12345678910111213141516171819202122232425262728class Point &#123;public: Point(double xValue = 0, double yValue = 0); void Print(); double X; double Y;&#125;;Point:: Point(double xValue, double yValue) &#123; X = xValue; Y = yValue;&#125;void Point::Print() &#123; cout &lt;&lt; \"(\" &lt;&lt; X &lt;&lt; \", \"; cout &lt;&lt; Y &lt;&lt; \")\" &lt;&lt; endl;&#125;int main() &#123; Point* point1 = new Point; point1-&gt;Print(); Point* point2 = new Point(8, 9); (*point2).Print(); return 0;&#125; The member access operator12(*point2).Print();point2-&gt;Print(); The delete operator12345678910int main() &#123; Point* point1 = new Point(73, 19); cout &lt;&lt; \"X = \" &lt;&lt; point1-&gt;X &lt;&lt; endl; cout &lt;&lt; \"Y = \" &lt;&lt; point1-&gt;Y &lt;&lt; endl; delete point1; // Error: can't use point1 after deletion point1-&gt;Print();&#125; Allocating and deleting object arrays12345678910// Allocate pointsint pointCount = 4;Point* manyPoints = new Point[pointCount];// Display each pointfor (int i = 0; i &lt; pointCount; ++i) manyPoints[i].Print();// Free all points with one deletedelete[] manyPoints; 1234567A dynamically allocated array is freed with one statement. Objects in the array cannot be deleted individually.ERROR :for (;i &lt; n; i++) &#123; delete pointers[i];&#125; Deallocating memory12345678910111213141516171819class PaintContainer &#123; public: ~PaintContainer(); double gallonPaint;&#125;;PaintContainer::~PaintContainer() &#123; // Covered in section on Destructors. cout &lt;&lt; \"PaintContainer deallocated.\" &lt;&lt; endl;&#125;int main() &#123; PaintContainer* kitchenPaint; kitchenPaint = new PaintContainer; kitchenPaint-&gt;gallonPaint = 26.3; delete kitchenPaint; return 0;&#125; 1PaintContainer deallocated.","categories":[{"name":"Program Language","slug":"Program-Language","permalink":"http://yoursite.com/categories/Program-Language/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"}],"author":"isFibonacci"},{"title":"Greedy Algorithm (2)","slug":"Greedy Algorithm (2)","date":"2020-02-11T01:55:00.000Z","updated":"2020-02-12T16:49:37.102Z","comments":true,"path":"2020/02/10/Greedy Algorithm (2)/","link":"","permalink":"http://yoursite.com/2020/02/10/Greedy%20Algorithm%20(2)/","excerpt":"","text":"376. Wiggle Subsequence1234567The longest subsequences will always start at first, to the last one.Since it is subsequence, not need to successive.Proof : [1, -1, -1, -2, 3, 2, 5, 5][-1, -2, 3, 2, 5] can see as [1, -2, 3, 2, 5]Maintain two booleans to record the last is increase or decreaseMaintain previous to determind whether cur is valid 123456789101112131415161718def wiggleMaxLength(self, nums: List[int]) -&gt; int: if len(nums) &lt; 2 : return len(nums) incr, decr = True, True count = 1 prev = nums[0] for num in nums[1:] : if num &lt; prev and incr : count += 1 incr, decr = False, True elif num &gt; prev and decr : count += 1 incr, decr = True, False prev = num return count","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/categories/leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/tags/leetcode/"},{"name":"greedy algorithm","slug":"greedy-algorithm","permalink":"http://yoursite.com/tags/greedy-algorithm/"},{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}],"author":"isFibonacci"},{"title":"Greedy Algorithm (1)","slug":"greedy algorithm (1)","date":"2020-02-11T01:55:00.000Z","updated":"2020-02-11T18:32:40.688Z","comments":true,"path":"2020/02/10/greedy algorithm (1)/","link":"","permalink":"http://yoursite.com/2020/02/10/greedy%20algorithm%20(1)/","excerpt":"","text":"860. Lemonade Change1234567Input: [5,5,5,10,20]Output: trueExplanation: From the first 3 customers, we collect three $5 bills in order.From the fourth customer, we collect a $10 bill and give back a $5.From the fifth customer, we give a $10 bill and a $5 bill.Since all customers got correct change, we output true. 123451. Every time we choose the largest one to exchange, like 20 -&gt; 10 + 52. if use 10 to exchange 5 we will have 10, so ten +&#x3D; 13. for 20 case, we cannot just return false if there is not 10, since we can use 5+5+5 to exchange4. make sure temp &#x3D;&#x3D; 0t to quit, otherwise we will have negative temp 123456789101112131415161718192021222324252627282930313233class Solution: def lemonadeChange(self, bills: List[int]) -&gt; bool: five, ten = 0, 0 for cur in bills : if cur == 5 : five += 1 if cur == 10 : #need 5 if five : five -= 1 #exchange to ten, so ten +1 ten += 1 else : return False if cur == 20 : #need 15 temp = 15 if ten : ten -= 1 temp -= 10 #cannot return false, bc we can return 5+5+5 while five and temp: #make sure when temp = 0 quit, or it will loop to negative five -= 1 temp -= 5 if temp : return False return True 392. Is Subsequence123456789Example 1:s &#x3D; &quot;abc&quot;, t &#x3D; &quot;ahbgdc&quot;Return true.Example 2:s &#x3D; &quot;axc&quot;, t &#x3D; &quot;ahbgdc&quot;Return false. 11. Two pointers, make suer k lease than len(s) 123456789class Solution: def isSubsequence(self, s: str, t: str) -&gt; bool: i, k = 0, 0 while i &lt; len(t) and k &lt; len(s) : if s[k] == t[i] : k += 1 i += 1 return k == len(s) 455. Assign Cookies12345678Input: [1,2,3], [1,1]Output: 1Explanation: You have 3 children and 2 cookies. The greed factors of 3 children are 1, 2, 3. And even though you have 2 cookies, since their size is both 1, you could only make the child whose greed factor is 1 content.You need to output 1. 1234567891011121314151617181920class Solution: def findContentChildren(self, g: List[int], s: List[int]) -&gt; int: #who come first, give the cookies to him g = sorted(g) s = sorted(s) res, j = 0, 0 for i in range (len(g)) : #not satisified while j &lt; len(s) and s[j] &lt; g[i] : j += 1 #satisified if j &lt; len(s) : res += 1 #make sure j += 1, bc have used j += 1 return res 55. Jump Game1234Input: [3,2,1,0,4]Output: falseExplanation: You will always arrive at index 3 no matter what. Its maximum jump length is 0, which makes it impossible to reach the last index. 12345678910111213141516class Solution: def canJump(self, nums: List[int]) -&gt; bool: n = len(nums) if n == 0 : return True i, maxDist = 0, 0 #maxDist : the maximum position you can arrive so far while i &lt; n and i &lt;= maxDist : # if i &gt; maxDist, we cannnot get i position maxDist = max(i + nums[i], maxDist) i += 1 # [3, 1, 2, 0] -&gt; i = 0, maxDist = 3, we can arrive i = 3 maximum; # i = 2, maxDist = 2 + 2 = 4, arrive i = 4 maximum return maxDist &gt;= n-1 #not maxDist &gt;= i, bc after loop i+= 1 &gt; n-1 45. Jump Game II1234Input: [2,3,1,1,4]Output: 2Explanation: The minimum number of jumps to reach the last index is 2. Jump 1 step from index 0 to 1, then 3 steps to the last index. At i = 0, if choose jump 2 -&gt; i = 2, we can only jump 1 -&gt; i = 3we can only jump 1 -&gt; i = 4so total is 3 At i = 0, if choose jump 1 -&gt; i = 1, we can jump 3 -&gt; i = 4so total is 4 12345678910111213141516Proof : f[i] &gt; f[i+1] is wrongf[i] : the minimum steps to arrive if[i+1] : the minimum steps to arrive i+1we prove f[i] &lt;&#x3D; f[i+1] is correctAssume at j, we need to arrive at i+1. j+nums[j] &gt;&#x3D; i+1[2, 3, 1, 1, 4]j &#x3D; 0, i+1 &#x3D; 1j+nums[j] &#x3D; 0+2, we can arrive position at 2 maximumAssume we at j, and want to arrive at i+1, we need to jump plus 1f[i+1] &#x3D; f[j] + 1we can also arrive at i by f[j] + 1 steps at leastso f[i] &#x3D; f[j] + 1Hence, f[i] &lt;&#x3D; f[i+1] 123456789101112131415161718192021222324class Solution: def jump(self, nums: List[int]) -&gt; int: n = len(nums) if n == 0 or n == 1: return 0 l, r, step = 0, 0, 0 while l &lt;= r : # we check at each postion we can jump how far maxDist = 0 for i in range(l, r+1) : # want to check l == r, l &lt;= r so r+1 # maxDist : at i position, how far we can jump maxDist = max(i+nums[i], maxDist) l = r+1 # can arrive at r at least r = maxDist step += 1 if r &gt;= n-1 : break return step","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/categories/leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/tags/leetcode/"},{"name":"greedy algorithm","slug":"greedy-algorithm","permalink":"http://yoursite.com/tags/greedy-algorithm/"}],"author":"isFibonacci"},{"title":"Comparison of Greedy Search Algorithms","slug":"Comparison of Greedy Search Algo","date":"2020-02-10T22:18:00.000Z","updated":"2020-02-13T01:12:22.200Z","comments":true,"path":"2020/02/10/Comparison of Greedy Search Algo/","link":"","permalink":"http://yoursite.com/2020/02/10/Comparison%20of%20Greedy%20Search%20Algo/","excerpt":"","text":"best-first searches: weighted A*, greedy search, A∗ǫ , window A* multi-state commitment k-weighted A*. hill climbing algorithms : hill climb- ing LSS-LRTA* beam searches : BULB beam-stack search pathfinding in grids (Thayer, Ruml, and Bitton 2008), the traveling salesman problem (Pearl and Kim 1982), dynamic robot pathfinding (Likhachev, Gordon, and Thrun 2003), the sliding tile puzzle (Korf 1985), the pancake puzzle (Holte, Grajkowskic, and Tanner 2005), and a vacuum-robot domain (Russell and Norvig 2010).","categories":[{"name":"AI","slug":"AI","permalink":"http://yoursite.com/categories/AI/"}],"tags":[],"author":"isFibonacci"},{"title":"Informed search","slug":"Informed-search","date":"2020-02-10T22:18:00.000Z","updated":"2020-02-10T22:41:10.774Z","comments":true,"path":"2020/02/10/Informed-search/","link":"","permalink":"http://yoursite.com/2020/02/10/Informed-search/","excerpt":"","text":"In uninformed search, we only had the nodeinformation (parent, children, cost of actions) Now we will assume there is some additionalinformation, we will call a heuristic thatestimates the distance to the goal Previously, we had no idea how close we wereto goal, simply how far we had gone already 1. Greedy best-first searchThis search will simply repeatedly select thechild with the lowest heuristic(cost to goal est.) In fact, it is not guaranteed to converge (if apath reaches a dead-end, it will loop infinitely) 2. A* (a star) upload successful Priority queues can be used to efficiently storeand insert states and their f-values into the fringe Good heuristics can remove “bad” sections of the search space that will not be on any optimal solution (called pruning) A* is optimal and in fact, no optimal algorithm could expand less nodes (optimally efficient) However, the time and memory cost is still exponential (memory tighter constraint) 2.1 Iterative deepening A* Run DFS in IDS, but instead of using depthas cutoff, use f-cost If search fails to find goal, increase f-costto next smallest seen value (above old cost) Pros: Efficient on memory Cons: Large (LARGE) amount of re-searching","categories":[{"name":"AI","slug":"AI","permalink":"http://yoursite.com/categories/AI/"}],"tags":[],"author":"isFibonacci"},{"title":"Inheritance and Polymorphism in C++ (1)","slug":"Inheritance and Polymorphism in C++ (1)","date":"2020-02-07T22:56:00.000Z","updated":"2020-02-11T18:22:07.557Z","comments":true,"path":"2020/02/07/Inheritance and Polymorphism in C++ (1)/","link":"","permalink":"http://yoursite.com/2020/02/07/Inheritance%20and%20Polymorphism%20in%20C++%20(1)/","excerpt":"","text":"Access by members of derived classesThe members of a derived class have access to the public members of the base class, but not to the private members of the base class. 1234567891011121314151617181920212223class Business &#123; public: ... private: string name; string address;&#125;;class Restaurant : public Business &#123; public: ... void DisplayRestaurant() &#123; cout &lt;&lt; name &lt;&lt; endl; cout &lt;&lt; address &lt;&lt; endl; cout &lt;&lt; \" Rating: \" &lt;&lt; rating &lt;&lt; endl; &#125; private: int rating;&#125;; Solution :A third access specifier is protected, which provides access to derived classes but not by anyone else. But! Careful here : A third access specifier is protected, which provides access to derived classes but not by anyone else. 1234567891011121314151617181920212223242526272829303132333435363738394041class Business &#123; public: // Members accessible by anyone void PrintMembers(); protected: // Members accessible by self and derived classes string name; private: // Members accessible only by self string address;&#125;;class Restaurant : public Business &#123; ... // Attempted accesses PrintMembers(); // OK name = \"Gyro Hero\"; // OK (\"protected\" above made this possible) address = \"5 Fifth St\"; // ERROR ...&#125;;int main() &#123; ... Business business; Restaurant restaurant; ... // Attempted accesses business.PrintMembers(); // OK business.name = \"Gyro Hero\"; // ERROR (protected only applies to derived classes) business.address = \"5 Fifth St\"; // ERROR restaurant.PrintMembers(); // OK restaurant.name = \"Gyro Hero\"; // ERROR restaurant.rating = 5; // ERROR return 0;&#125;","categories":[{"name":"Program Language","slug":"Program-Language","permalink":"http://yoursite.com/categories/Program-Language/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"}],"author":"isFibonacci"},{"title":"Inheritance and Polymorphism in C++ (3)","slug":"Inheritance and Polymorphism in C++ (3)","date":"2020-02-07T22:56:00.000Z","updated":"2020-02-11T19:24:33.532Z","comments":true,"path":"2020/02/07/Inheritance and Polymorphism in C++ (3)/","link":"","permalink":"http://yoursite.com/2020/02/07/Inheritance%20and%20Polymorphism%20in%20C++%20(3)/","excerpt":"","text":"Abstract classes: Introduction (generic)Object-oriented programming (OOP) : Classes Inheritance Abstract classes Abstract classes A pure virtual function is a virtual function that is not implemented in the base class, thus all derived classes must override the function. A pure virtual function is declared with the “virtual” keyword and is assigned with 0. Ex: virtual double ComputeArea() const = 0; declares a pure virtual function ComputeArea(). An abstract class is a class that cannot be instantiated as an object, but is the superclass for a subclass and specifies how the subclass must be implemented. Any class with one or more pure virtual functions is abstract. A concrete class is a class that is not abstract, and hence can be instantiated. 123456789101112131415161718192021222324252627282930class Shape &#123; protected: Point position; public: virtual ~Shape() &#123; &#125; virtual double ComputeArea() const = 0; Point GetPosition() const &#123; return position; &#125; void SetPosition(Point newPosition) &#123; position = newPosition; &#125; void MovePositionRelative(Point otherPosition) &#123; double x = position.GetX() + otherPosition.GetX(); double y = position.GetY() + otherPosition.GetY(); position.SetX(x); position.SetY(y); &#125;&#125;;int main(int argc, const char* argv[]) &#123; Shape* shape = new Shape(); // &lt;- ERROR!!! ...&#125; Omitting ComputeArea() makes the Circle class abstract. To be concrete, all pure virtual functions from the superclass, Shape, must be implemented. In Shape.h 1234567class Shape &#123; ... public: virtual ~Shape() &#123; &#125; virtual double ComputeArea() const = 0; ...&#125; In Circle.h 1234567891011121314class Circle : public Shape &#123; private: double radius; public: Circle(Point center, double radius) &#123; this-&gt;radius = radius; this-&gt;position = center; &#125; double ComputeArea() const &#123; return (M_PI * pow(radius, 2)); &#125;&#125;; Is-a versus has-a relationshipsCompositionThe ‘has-a’ relationship. A MotherInfo object ‘has a’ string object and ‘has a’ vector of ChildInfo objects, but no inheritance is involved. 12345678910111213141516class ChildInfo &#123; string firstName; string birthDate; string schoolName; ...&#125;;class MotherInfo &#123; string firstname; string birthDate; string spouseName; vector&lt;ChildInfo&gt; childrenData; ...&#125;; Inheritance 12345678910111213141516171819class PersonInfo &#123; string firstName; string birthDate; ...&#125;;class ChildInfo : public PersonInfo &#123; string schoolName; ...&#125;;class MotherInfo : public PersonInfo &#123; string spouseName; vector&lt;ChildInfo&gt; childrenData; ...&#125;; UML","categories":[{"name":"Program Language","slug":"Program-Language","permalink":"http://yoursite.com/categories/Program-Language/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"}],"author":"isFibonacci"},{"title":"Inheritance and Polymorphism in C++ (2)","slug":"Inheritance and Polymorphism in C++ (2)","date":"2020-02-07T22:56:00.000Z","updated":"2020-02-11T18:22:17.857Z","comments":true,"path":"2020/02/07/Inheritance and Polymorphism in C++ (2)/","link":"","permalink":"http://yoursite.com/2020/02/07/Inheritance%20and%20Polymorphism%20in%20C++%20(2)/","excerpt":"","text":"Overriding member functionsOverriding vs. overloadingIn overloading, functions with the same name must have different parameter types. In overriding, a derived class member function takes precedence over a base class member function with the same name, regardless of the parameter types. Overloading is not performed if derived and base member functions have different parameter types; the member function of the derived class hides the member function of the base class. Restaurant’s GetDescription() must be identical to Business’s GetDescription() name, return type, and parameter list. 1234567891011121314151617181920212223class Business &#123; public: ... string GetDescription() const &#123; return name + \" -- \" + address; protected: string name; string address;&#125;;class Restaurant : public Business &#123; public: ... string GetDescription() const &#123; return name + \" -- \" + address + \"\\n Rating: \" + to_string(rating); private: int rating;&#125;; Or you can call it conveniently : 12345678910class Restaurant : public Business &#123; ... string GetDescription() const &#123; return Business::GetDescription() + \"\\n Rating: \" + to_string(rating); &#125;; ...&#125;; Without the prepended base class name, the call to GetDescription() refers to itself (a recursive call) 123456789101112131415161718192021222324252627282930class Computer &#123;public: void SetComputerStatus(string cpuStatus, string internetStatus) &#123; cpuUsage = cpuStatus; internet = internetStatus; &#125;; void PrintStatus() &#123; cout &lt;&lt; \"CPU: \" &lt;&lt; cpuUsage &lt;&lt; endl; cout &lt;&lt; \"Internet: \" &lt;&lt; internet &lt;&lt; endl; &#125;;protected: string cpuUsage; string internet;&#125;;class Laptop : public Computer &#123;public: void SetComputerStatus(string cpuStatus, string internetStatus, string wifiStatus) &#123; cpuUsage = cpuStatus; internet = internetStatus; wifiQuality = wifiStatus; &#125;; void PrintStatus() &#123; Computer::PrintStatus(); cout &lt;&lt; \"WiFi: \" &lt;&lt; wifiQuality &lt;&lt; endl; &#125;; Polymorphism and virtual member functions Compile-time polymorphism is when the compiler determines which function to call at compile-time. Runtime polymorphism is when the compiler is unable to determine which function to call at compile-time, so the determination is made while the program is running. Function overloading is an example of compile-time polymorphism where the compiler determines which of several identically-named functions to call based on the function’s arguments. compile-time polymorphismconvert the Restaurant pointer to a Business pointer 1234567891011void DriveTo(string restaurant) &#123; cout &lt;&lt; \"Driving to \" &lt;&lt; restaurant &lt;&lt; endl;&#125;void DriveTo(Restaurant restaurant) &#123; cout &lt;&lt; \"Driving to \" &lt;&lt; restaurant.GetDescription() &lt;&lt; endl;&#125;int main() &#123; DriveTo(\"Big Mac's\"); // Call string version&#125; runtime polymorphism12345678910111213141516void DriveTo(Business* businessPtr) &#123; cout &lt;&lt; \"Driving to \" &lt;&lt; businessPtr-&gt;GetDescription() &lt;&lt; endl;&#125;int main() &#123; int index; vector&lt;Business*&gt; businessList; Business* businessPtr; Restaurant* restaurantPtr; ... businessList.push_back(businessPtr); businessList.push_back(restaurantPtr); index = rand() % businessList.size(); DriveTo(businessList.at(index);&#125; derived/base class pointer conversion :a pointer to a derived class is converted to a pointer to the base class without explicit casting The above statement businessList.push_back(restaurantPtr); uses derived/base class pointer conversion to convert the Restaurant pointer to a Business pointer (businessList is a vector of Business pointers). When derived/base class pointer conversion takes place, the compiler is unable to use compile-time polymorphism. Virtual functionsA virtual function is a member function that may be overridden in a derived class and is used for runtime polymorphism. 123456789101112131415161718192021222324252627282930class Business &#123;public: string GetDescription() const &#123; return name + \" -- \" + address; &#125; ...&#125;;class Restaurant : public Business &#123;public: string GetDescription() const &#123; return name + \" -- \" + address + \"\\n Rating: \" + to_string(rating); &#125; ...&#125;;int main() &#123; Business* businessPtr; Restaurant favoriteCafe; favoriteCafe.SetName(\"Friends Cafe\"); favoriteCafe.SetAddress(\"500 2nd Ave\"); favoriteCafe.SetRating(5); // Point to favoriteCafe businessPtr = &amp;favoriteCafe; cout &lt;&lt; businessPtr-&gt;GetDescription();&#125; businessPtr points to favoriteCafe. businessPtr-&gt;GetDesciption() calls Business GetDescription()instead of Restaurant GetDescription() because runtime polymorphism does not work without virtual functions. 12345678910111213141516171819202122232425class Business &#123;public: virtual string GetDescription() const &#123; return name + \" -- \" + address; &#125; ...&#125;;class Restaurant : public Business &#123;public: string GetDescription() const override &#123; return name + \" -- \" + address + \"\\n Rating: \" + to_string(rating); &#125; ...&#125;;int main() &#123; ... vector&lt;Business*&gt; businessList; Business* businessPtr; Restaurant* restaurantPtr; ...&#125; The “virtual” keyword makes GetDescription() a virtual function. The “override” keyword indicates that Restaurant GetDescription() overrides the base class GetDescription(). Running the program with an overridden virtual function causes runtime polymorphism to call Restaurant GetDescription(). Another way : 123void PrintDescription(Business&amp; business) &#123; cout &lt;&lt; business.GetDescription() &lt;&lt; endl;&#125; Runtime polymorphism only works with pointers to derived classes. 12345Restaurant favoritePlace;favoritePlace.SetName(\"Friends Cafe\");favoritePlace.SetAddress(\"500 2nd Ave\");favoritePlace.SetRating(5);cout &lt;&lt; favoritePlace.GetDescription(); The compiler can tell from the code that a Restaurant object is calling GetDescription(), so the overridden GetDescription() is called. Pure virtual functionsA pure virtual function is a virtual function that provides no definition in the base class, and all derived classes must override the function A class that has at least one pure virtual function is known as an abstract base class. An abstract base class object cannot be declared. Ex: The variable declaration Business someBusiness; generates a syntax error if Business is an abstract base class. 1234567891011121314151617181920class Business &#123;public: void SetName(string busName) &#123; name = busName; &#125; void SetAddress(string busAddress) &#123; address = busAddress; &#125; virtual string GetDescription() const &#123; return name + \" -- \" + address; &#125; virtual string GetHours() const = 0; // pure virtual functionprotected: string name; string address;&#125;;","categories":[{"name":"Program Language","slug":"Program-Language","permalink":"http://yoursite.com/categories/Program-Language/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"}],"author":"isFibonacci"},{"title":"Uniformed Search","slug":"Search","date":"2020-02-07T01:55:00.000Z","updated":"2020-02-10T20:37:24.365Z","comments":true,"path":"2020/02/06/Search/","link":"","permalink":"http://yoursite.com/2020/02/06/Search/","excerpt":"","text":"Uniformed Searcha. In deterministic environments the search solution is a single sequence (list of actions) b. Stochastic environments need multiple sequences to account for all possible outcomes of actions c. There are 5 parts to search: 1. Initial state 2. Actions possible at each state 3. Transition model (result of each action) 4. Goal test (are we there yet?) 5. Path costs/weights (not stored in states) (related to performance measure) Search algorithm BFS: FIFO The search algorithms metrics/criteria: 1. Completeness (does it terminate with a valid solution) 2. Optimality (is the answer the best solution) 3. Time (in big-O notation) 4. Space (big-O) b = maximum branching factor d = minimum depth of a goal m = maximum length of any path a. Uniform-cost search The only modification is when exploring a node we cannot disregard it if it has already been explored by another node We might have found a shorter path and thus need to update the cost on that node We also do not terminate when we find a goal, but instead when the goal has the lowest cost in the queue. UCS is.. 1. Complete (if costs strictly greater than 0) 2. Optimal However.... 3&amp;4. Time complexity = space complexity = O(b1+C*/min(path cost)), where C* cost of optimal solution (much worse than BFS) b. Bidirectional search It starts from both the goal and start (using BFS) until the trees meet This is better as 2*(bd/2) &lt; bd (the space is much worse than IDS, so only applicable to small problems)![upload successful](/images/pasted-7.png =100x) DFS: FILOMetrics: 1. Might not terminate (not correct) (e.g. in vacuum world, if first expand is action L) 2. Non-optimal (just… no) 3. Time complexity = O(bd ) 4. Space complexity = O(b*d) Only way this is better than BFS is the space complexity… DFS by itself is not great, but it has two (very) useful modifications a. Depth limited search It runs normal DFS, but if it is at a specified depth limit, you cannot have children (i.e. take another action) However, if you pick the depth limit before d, you will not find a solution (not correct, but will terminate) b. iterative deepening DFSThis search performs depth limited search with maximum depth 1, then maximum depth 2, then 3… until it finds a solution The first few states do get re-checked multiple times in IDS, however it is not too many When you find the solution at depth d, depth 1 is expanded d times (at most b of them) The second depth are expanded d-1 times (at most b2 of them) Thus upload successful Metrics: 1. Complete 2. Non-optimal (unless uniform cost) 3. O(bd ) 4. O(b*d) Thus IDS is better in every way than BFS (asymptotically) Best uninformed we will talk about","categories":[{"name":"AI","slug":"AI","permalink":"http://yoursite.com/categories/AI/"}],"tags":[{"name":"Search","slug":"Search","permalink":"http://yoursite.com/tags/Search/"}],"author":"isFibonacci"},{"title":"Some thoughts on AI","slug":"Some-thoughts-about-AI","date":"2020-02-06T03:45:00.000Z","updated":"2020-02-10T01:53:04.424Z","comments":true,"path":"2020/02/05/Some-thoughts-about-AI/","link":"","permalink":"http://yoursite.com/2020/02/05/Some-thoughts-about-AI/","excerpt":"","text":"Recently, there has been a lot of concerns about AI(artificial intelligence), like AI will make people lose jobs and the tech oligarch will make wealth inequality; in brief, AI will raise abundant social issues over than its advantage to society. On the contrary, some people argues that AI will bring abundant jobs instead. Like in the past, some people concerned that industrial revolution will take away people’s jobs but we know this revolution promote society development and then bring many opening jobs. However, I still believe there are many reasons to be concerned about advances of AI. As the automation is developing, we can see in the near future; millions of people will be replaced by the machines. The reasons I concerned are that there are many advantages in automation over than humans. First, machines will never feel tired. Mentioned in this article, I believe ”the self-driving trucks promised by Tesla’s Elon Musk become widely available in the next decade.” (Bossmann, 2016). Human drivers need to take a break after long driving, but self-driving trucks not. Self-driving car can keep long driving during the midnight to avoid rush hours in the daytime, and self-driving car has a lower risk of accidents than humans after long driving. Absolutely, transportation company will hire robots to drive rather than humans in obvious these advances. Hence, we can see in the near future; AI will take away many people’s jobs, and the unemployment rate will be increasing rapidly. What if AI turn to hurt humans? Hollywood movies have presented many AI disasters for us. And in this article, the author mentioned a vivid example: in order to kill the cancer, the machine kills everyone on the planet instead, which is more efficient. (Bossmann, 2016). As we know, the real world is really complicated. It is hard to just use some if-else statements to cover all the cases, like we are hard to predicate the future. So, in more specific, how can we ensure that the robot will not hurt human in a complicate case like rescue hostages? How can we ensure human will still dominate the world if one day we totally lose the ingenuity and intelligence than AI? As one day AI can evolve them very efficiently by iteration? How can we protect ourselves if robots start to attack people? How can we ensure we can still dominate the world, not AI dominate us? Or AI can just create a pandemic breaks out the world, which is the most efficient way to kill all the organism on this planet. Or like the movie, The Matrix, people are imprisoned in a container as a energy source? Obviously, there are still many issues that AI will bring to us. So I believe govern- ments, industries, and academics should take some steps to address these issues. First, since the automation take place of many people’s job, the unemployment rate will be in- creasing. Government should make some effectual policy to against unemployment. For example, Andrew Yang proposes government to pay one thousand dollars each month to every American over the age of 18. This money is from company’s VAT(A Value-Added Tax), and then people use the money to consumer company’s product. (Yang, 2020). This is a double win. No need to say, there are still a lot of issues that AI will bring to us in the future, but government should take its strong right to control these issues. Second, industries and academics should make some principles or agreement during the AI development. Like The Institute for Ethical ML, this academic institute make 8 principles when designing and developing AI and ML.(for Ethical AI ML, 2020). In that 8 principles, the developer commit to assess and handle the impact of incorrect result. So I believe the developers can take a great effort to avoid accident due to AI, and even when the accident happens, they can reduce losses. In brief, We have reasons to be concerned about advances of AI.And there are still many steps to address these issues, but the only principle we need to make sure is, artificial intelligence is conducive to improving the efficiency of social work and promoting social development. References J. Bossmann. Top 9 ethical issues in artificial intelligence. 2016. URL https://www.weforum.org/agenda/2016/10/top-10-ethical-issues -in-artificial-intelligence.I. for Ethical AI ML. The 7 Most Pressing Ethical Issues in Artificial Intelligence. 2020. URL https://ethical.institute/principles.html.A. Yang. VALUE-ADDED TAX. 2020. URL https://www.yang2020.com/policies/value-added-tax/.","categories":[{"name":"AI","slug":"AI","permalink":"http://yoursite.com/categories/AI/"}],"tags":[],"author":"isFibonacci"},{"title":"Build your own blog","slug":"hello-world","date":"2020-02-01T15:22:00.000Z","updated":"2020-02-10T01:53:43.591Z","comments":true,"path":"2020/02/01/hello-world/","link":"","permalink":"http://yoursite.com/2020/02/01/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment Change ThemeThe theme I used in this blog is cited from yscoder 1.git clone -&gt; after all install -&gt; move theme to your hexo theme and 12hexo ghexo d Careful here, if in the _config.yml you set it as 123deploy: type: git branch: master The hexo d will delete your custom domin name!What should do is here","categories":[],"tags":[],"author":"isFibonacci"}]}