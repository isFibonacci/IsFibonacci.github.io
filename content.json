{"meta":{"title":"Hi There","subtitle":"If people do not believe that mathematics is simple, it is only because they do not realize how complicated life is. – John von Neumann.","description":"Computer Sicence | University of Minnesota, twin cities","author":"isFibonacci","url":"http://yoursite.com","root":"/"},"pages":[{"title":"","date":"2020-02-09T23:48:28.829Z","updated":"2020-02-09T23:48:28.829Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"","date":"2020-02-09T23:48:36.379Z","updated":"2020-02-09T23:48:36.379Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"Oops | 404","date":"2020-02-12T02:33:34.647Z","updated":"2020-02-12T02:33:34.647Z","comments":true,"path":"404.html","permalink":"http://yoursite.com/404.html","excerpt":"","text":""}],"posts":[{"title":"string (1)","slug":"title: string (1)","date":"2020-02-21T23:55:00.000Z","updated":"2020-02-27T05:50:43.264Z","comments":true,"path":"2020/02/21/title: string (1)/","link":"","permalink":"http://yoursite.com/2020/02/21/title:%20string%20(1)/","excerpt":"","text":"208. Implement Trie (Prefix Tree)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public: /** Initialize your data structure here. */ struct Node &#123; bool isEnd; Node *son[26]; Node() &#123; isEnd = false; for (int i = 0; i &lt; 26; i++) son[i] = NULL; &#125; &#125;* root; Trie() &#123; root = new Node(); &#125; /** Inserts a word into the trie. */ void insert(string word) &#123; auto p = root; for (auto c : word) &#123; int u = c - 'a'; // set that node is not NULL if (p-&gt;son[u] == NULL) p-&gt;son[u] = new Node(); p = p-&gt;son[u]; // p move to the son &#125; p-&gt;isEnd = true; &#125; /** Returns if the word is in the trie. */ bool search(string word) &#123; auto p = root; for (auto c : word) &#123; int u = c - 'a'; if (p-&gt;son[u] == NULL) return false; p = p-&gt;son[u]; &#125; return p-&gt;isEnd; &#125; /** Returns if there is any word in the trie that starts with the given prefix. */ bool startsWith(string prefix) &#123; auto p = root; for (auto c : prefix) &#123; int u = c - 'a'; if (p-&gt;son[u] == NULL) return false; p = p-&gt;son[u]; &#125; return true; // prefix &#125;&#125;; 273. Integer to English Words12345678Example 3:Input: 1234567Output: &quot;One Million Two Hundred Thirty Four Thousand Five Hundred Sixty Seven&quot;Example 4:Input: 1234567891Output: &quot;One Billion Two Hundred Thirty Four Million Five Hundred Sixty Seven Thousand Eight Hundred Ninety One&quot; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class Solution &#123;public: string small[20] = &#123;\"Zero\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\", \"Ten\", \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\"&#125;; string decade[10] = &#123;\"\", \"\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\"&#125;; string big[4] = &#123;\"Billion\", \"Million\", \"Thousand\", \"\"&#125;; string numberToWords(int num) &#123; if (!num) return small[0]; string res; for (int i = 1000000000, j = 0; i &gt; 0; i /= 1000, j++) &#123; if (num &gt;= i) &#123; res += getPart(num / i) + big[j] + ' '; num %= i; &#125; &#125; while (res.back() == ' ') res.pop_back(); return res; &#125; string getPart(int num) &#123; string res; if (num &gt;= 100) &#123; res += small[num /100] + \" Hundred \"; num %= 100; &#125; if (!num) return res; if (num &gt;= 20) &#123; res += decade[num /10] + ' '; num %= 10; &#125; if (!num) return res; res += small[num] + ' '; return res; &#125;&#125;;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/categories/leetcode/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"},{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/tags/leetcode/"},{"name":"string","slug":"string","permalink":"http://yoursite.com/tags/string/"}],"author":"isFibonacci"},{"title":"string (0)","slug":"string (0)","date":"2020-02-20T23:55:00.000Z","updated":"2020-02-27T02:38:25.953Z","comments":true,"path":"2020/02/20/string (0)/","link":"","permalink":"http://yoursite.com/2020/02/20/string%20(0)/","excerpt":"","text":"38. Count and Say123456781. 12. 113. 214. 12115. 1112211 is read off as &quot;one 1&quot; or 11.11 is read off as &quot;two 1s&quot; or 21.21 is read off as &quot;one 2, then one 1&quot; or 1211. 12345678910111213141516string countAndSay(int n) &#123; string ans = \"1\"; for (int i = 0; i &lt; n-1; i++) &#123; string temp; for (int j = 0; j &lt; ans.size(); j++) &#123; int k = j; while (k &lt; ans.size() &amp;&amp; ans[k] == ans[j]) k++; //count the repeat element temp += to_string(k - j) + ans[j]; // counter + cur num j = k - 1; // j jump to k pointer &#125; ans = temp; &#125; return ans;&#125; 49. Group Anagrams1234567Input: [&quot;eat&quot;, &quot;tea&quot;, &quot;tan&quot;, &quot;ate&quot;, &quot;nat&quot;, &quot;bat&quot;],Output:[ [&quot;ate&quot;,&quot;eat&quot;,&quot;tea&quot;], [&quot;nat&quot;,&quot;tan&quot;], [&quot;bat&quot;]] 12345678910111213vector&lt;vector&lt;string&gt;&gt; groupAnagrams(vector&lt;string&gt;&amp; strs) &#123; unordered_map&lt;string, vector&lt;string&gt;&gt; hash; for (auto str : strs) &#123; string key = str; sort(key.begin(), key.end()); hash[key].push_back(str); &#125; vector&lt;vector&lt;string&gt;&gt; res; for (auto item : hash) res.push_back(item.second); return res;&#125;// O(n*m*logm + n*m) : n word, m : word length 151. Reverse Words in a String12345678910111213141516171819202122232425262728293031string reverseWords(string s) &#123; int wordEnd = 0; for (int i = 0; i &lt; s.size(); i++) &#123; // erase spaces while (i &lt; s.size() &amp;&amp; s[i] == ' ') i++; if (i == s.size()) break; // reverse each word int j = i; while (j &lt; s.size() &amp;&amp; s[j] != ' ') j++; // [) not including j reverse(s.begin() + i, s.begin() + j); // insert space if (wordEnd) s[wordEnd++] = ' '; //move wordEnd pointer to word end // bc may have a lot of spaces between words // _hello______w, k = index after one space of 'o' // copy w to there while (i &lt; j) s[wordEnd++] = s[i++]; &#125; cout&lt;&lt;s&lt;&lt;endl; // erase the spaces of the string end s.erase(s.begin() + wordEnd, s.end()); // reverse the str by each word reverse(s.begin(), s.end()); return s;&#125; 165. Compare Version Numbers12345678910111213141516171819202122int compareVersion(string s1, string s2) &#123; int i = 0, j = 0; while (i &lt; s1.size() || j &lt; s2.size()) &#123; int x = i, y = j; //cut word while (x &lt; s1.size() &amp;&amp; s1[x] != '.') x++; while (y &lt; s2.size() &amp;&amp; s2[y] != '.') y++; // convert to int int a = i == x ? 0 : atoi(s1.substr(i, x - i).c_str()); // substr return pointer, so need to conver to char int b = j == y ? 0 : atoi(s2.substr(j, y - j).c_str()); if (a &gt; b) return 1; if (a &lt; b) return -1; //continue i = x + 1, j = y + 1; &#125; return 0;&#125; 929. Unique Email Addresses123456789101112131415int numUniqueEmails(vector&lt;string&gt;&amp; emails) &#123; unordered_set&lt;string&gt; set; for (auto email : emails) &#123; string name; int at = email.find('@'); for (auto c : email.substr(0, at)) &#123; if (c == '+') break; // ignore else if (c != '.') name += c; // a.b = ab &#125; string domain = email.substr(at + 1); set.insert(name + '@' + domain); &#125; return set.size();&#125; 5. Longest Palindromic Substring12345678910111213141516string longestPalindrome(string s) &#123; string res; for (int i = 0; i &lt; s.size(); i++) &#123; // odd for (int j = i, k = i; j &gt;= 0 &amp;&amp; k &lt; s.size() &amp;&amp; s[j] == s[k]; j--, k++) &#123; if (res.size() &lt; k - j + 1) res = s.substr(j, k -j + 1); &#125; // even for (int j = i, k = i + 1; j &gt;= 0 &amp;&amp; k &lt; s.size() &amp;&amp; s[j] == s[k]; j--, k++) &#123; if (res.size() &lt; k - j + 1) res = s.substr(j, k - j + 1); &#125; &#125; return res;&#125; 6. ZigZag Conversion123456 N &#x3D; 50 8 16 首项是0， 公差是2（N-1）的等差数列1 7 9 15 两个等差数列交错2 6 10 143 5 11 134 12 首项是N-1， 公差是2（N-1）的等差数列 12345678910111213141516171819string convert(string s, int n) &#123; if (n == 1) return s; // (n -1) string res; for (int i = 0 ; i &lt; n; i++) &#123; // the fisrt and the last row if (!i || i == n - 1) &#123; for (int j = i; j &lt; s.size(); j += 2*(n-1)) res += s[j]; &#125; else &#123; for (int j = i, k = 2*(n-1) - i; j &lt; s.size() || k &lt; s.size(); j += 2*(n-1), k += 2*(n-1)) &#123; if (j &lt; s.size()) res += s[j]; if (k &lt; s.size()) res += s[k]; // res += s[j]; // res += s[k]; -&gt; k may over the size first &#125; &#125; &#125; return res;&#125; 3. Longest Substring Without Repeating Characters12345678910111213141516int lengthOfLongestSubstring(string s) &#123; int res = 0; unordered_map&lt;char, int&gt; hash; for (int i = 0, j = 0; i &lt; s.size(); i++) &#123; hash[s[i]]++; // if the added element make hash[s[i]] &gt; 1 // repeat, move j to the repeat index // before j + 1(the repeat one) is the res // clean the hash while (hash[s[i]] &gt; 1) hash[s[j++]]--; res = max(res, i - j + 1); &#125; return res;&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/categories/leetcode/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"},{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/tags/leetcode/"},{"name":"string","slug":"string","permalink":"http://yoursite.com/tags/string/"}],"author":"isFibonacci"},{"title":"Slide Window (0)","slug":"title: Slide Window (0)","date":"2020-02-14T23:55:00.000Z","updated":"2020-02-28T03:16:41.582Z","comments":true,"path":"2020/02/14/title: Slide Window (0)/","link":"","permalink":"http://yoursite.com/2020/02/14/title:%20Slide%20Window%20(0)/","excerpt":"","text":"[167. Two Sum II - Input array is sorted] (https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/)123Input: numbers &#x3D; [2,7,11,15], target &#x3D; 9Output: [1,2]Explanation: The sum of 2 and 7 is 9. Therefore index1 &#x3D; 1, index2 &#x3D; 2. 12345678910vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; numbers, int target) &#123; // i &lt; numbers.size()-1 if only two element for (int i = 0, j = numbers.size() -1; i &lt; numbers.size()-1; i++) &#123; // fix i, move j while ( i &lt; j &amp;&amp; numbers[i] + numbers[j] &gt; target) j--; if (numbers[i] + numbers[j] == target) return &#123;i+1, j+1&#125;; &#125; return &#123;-1, -1&#125;;&#125; 88. Merge Sorted Array","categories":[{"name":"恰饭要紧","slug":"恰饭要紧","permalink":"http://yoursite.com/categories/%E6%81%B0%E9%A5%AD%E8%A6%81%E7%B4%A7/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"}],"author":"isFibonacci"},{"title":"Dynamic Program (0)","slug":"title: Dynamic Program (0)","date":"2020-02-14T23:55:00.000Z","updated":"2020-02-28T14:16:17.794Z","comments":true,"path":"2020/02/14/title: Dynamic Program (0)/","link":"","permalink":"http://yoursite.com/2020/02/14/title:%20Dynamic%20Program%20(0)/","excerpt":"","text":"120. Triangle123456789For example, given the following triangle[ [2], [3,4], [6,5,7], [4,1,8,3]]The minimum path sum from top to bottom is 11 (i.e., 2 + 3 + 5 + 1 &#x3D; 11). 1234567891011121314151617181920212223242526272829303132int minimumTotal(vector&lt;vector&lt;int&gt;&gt;&amp; nums) &#123; int row = nums.size(); vector&lt;vector&lt;long long&gt;&gt; dp(row, vector&lt;long long&gt; (row)); dp[0][0] = nums[0][0]; for (int i = 1; i &lt; row; i++) &#123; //each level for (int j = 0; j &lt; nums[i].size(); j++) &#123; dp[i][j] = INT_MAX; //like res = min(res, dp[row-1][i]); //from top left if (j &gt; 0) dp[i][j] = min(dp[i][j], dp[i-1][j-1] + nums[i][j]); //from top right if (j &lt; nums[i-1].size()) dp[i][j] = min(dp[i][j], dp[i-1][j] + nums[i][j]); &#125; &#125; //at last row long long res = INT_MAX; for (int i = 0 ; i &lt; nums[row-1].size(); i++) &#123; res = min(res, dp[row-1][i]); &#125; return res; &#125; 63. Unique Paths II1234567891011121314151617181920212223242526272829int uniquePathsWithObstacles(vector&lt;vector&lt;int&gt;&gt;&amp; g) &#123; int row = g.size(), col = g[0].size(); vector&lt;vector&lt;long long&gt;&gt; dp(row, vector&lt;long long&gt;(col)); // if [[1]] Expected : 0 // dp[0][0] = 1; for (int i = 0; i &lt; row; i++) &#123; for (int j = 0; j &lt; col; j++) &#123; //obstacles, should before !i&amp;&amp;!j bc [[1]], i = 1, j = 1 if (g[i][j]) continue; if (!i &amp;&amp; !j) dp[i][j] = 1; //not the first row, e.g i = 1; dp[1][0] = 1, down if (i &gt; 0) dp[i][j] += dp[i-1][j]; //else if is wrong if (j &gt; 0) dp[i][j] += dp[i][j-1]; &#125; &#125; //at [row-1][col]: down, at[row][col-1]: right return dp[row-1][col-1]; &#125; 198. House Robber12345678910111213141516171819int rob(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); vector&lt;int&gt; f(n+1), g(n+1); for (int i = 1; i &lt;= n; i++) &#123; //not choose i, so max(not choose i-1, choose i-1) f[i] = max(f[i-1], g[i-1]); //not choose i-1 so can choose i //nums[i-1] bc i start from 1, //for i = 0, g[1] = f[0] + nums[0] //don't choose f[0] choose nums[0] g[i] = f[i-1] + nums[i-1]; &#125; //n = 0, so n-1 is wrong return max(f[n], g[n]);&#125; [1143. Longest Common Subsequence] (https://leetcode.com/problems/longest-common-subsequence/)12345678910111213141516int longestCommonSubsequence(string text1, string text2) &#123; int len1 = text1.size(), len2 = text2.size(); vector&lt;vector&lt;int&gt;&gt; dp(len1+1, vector&lt;int&gt;(len2+1)); for (int i = 1; i &lt;= len1; i++) &#123; for (int j = 1; j &lt;= len2; j++) &#123; if (text1[i-1] == text2[j-1]) &#123; dp[i][j] = (dp[i-1][j-1] + 1); &#125; else &#123; dp[i][j] = max(dp[i-1][j], dp[i][j-1]); &#125; &#125; &#125; return dp[len1][len2];&#125;","categories":[{"name":"恰饭要紧","slug":"恰饭要紧","permalink":"http://yoursite.com/categories/%E6%81%B0%E9%A5%AD%E8%A6%81%E7%B4%A7/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"}],"author":"isFibonacci"},{"title":"binary-stack-queue (1)","slug":"title: binary-stack-queue (1)","date":"2020-02-14T23:55:00.000Z","updated":"2020-02-24T18:51:00.154Z","comments":true,"path":"2020/02/14/title: binary-stack-queue (1)/","link":"","permalink":"http://yoursite.com/2020/02/14/title:%20binary-stack-queue%20(1)/","excerpt":"","text":"496. Next Greater Element I12345678给定两个没有重复元素的数组 nums1 和 nums2 ，其中 nums1 是 nums2 的子集。找到 nums1 中每个元素在 nums2 中的下一个比其大的值。nums1 中数字 x 的下一个更大元素是指 x 在 nums2 中对应位置的右边的第一个比 x 大的元素。如果不存在，对应位置输出 -1输入: nums1 &#x3D; [4,1,2], nums2 &#x3D; [1,3,4,2].输出: [-1,3,-1]解释:对于 nums1 中的数字 4，你无法在第二个数组中找到下一个更大的数字，因此输出 -1。对于 nums1 中的数字 1，第二个数组中数字1右边的下一个较大数字是 3。对于 nums1 中的数字 2，第二个数组中没有下一个更大的数字，因此输出 -1。 121. use stack to save the next greater element in its right2. bc need to find its right, so we search from back 1234567891011121314vector&lt;int&gt; nextGreaterElement(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123; stack&lt;int&gt; stk; unordered_map&lt;int, int&gt; hash; for (int i = nums2.size() -1; i &gt;= 0; i--) &#123; int t = nums2[i]; while (stk.size() &amp;&amp; stk.top() &lt;= t) stk.pop(); hash[t] = stk.size() ? stk.top() : -1; stk.push(t); &#125; vector&lt;int&gt; res; for (auto t : nums1) res.push_back(hash[t]); return res;&#125; 84. Largest Rectangle in Histogram1234567891011121314151617181920int largestRectangleArea(vector&lt;int&gt;&amp; heights) &#123;int n = heights.size(), ans = 0;heights.push_back(-1); // [2, 3], i = 2// 为了算法书写方便，在数组末尾添加高度 -1// 这会使得栈中所有数字在最后出栈。stack&lt;int&gt; st; // index for (int i = 0; i &lt;= n; i++) &#123; while (!st.empty() &amp;&amp; heights[i] &lt; heights[st.top()]) &#123; int cur = st.top(); st.pop(); if (st.empty()) ans = max(ans, heights[cur] * i); // [2,1] height[cur] else ans = max(ans, heights[cur] * (i - st.top() - 1)); // weigth, - 1 is itself, limit by the shortest heigth &#125; st.push(i);&#125;return ans;&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/categories/leetcode/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"},{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/tags/leetcode/"},{"name":"binary","slug":"binary","permalink":"http://yoursite.com/tags/binary/"},{"name":"stack","slug":"stack","permalink":"http://yoursite.com/tags/stack/"},{"name":"heap","slug":"heap","permalink":"http://yoursite.com/tags/heap/"}],"author":"isFibonacci"},{"title":"binary-stack-queue (0)","slug":"title:BinarySearch-stack-queue","date":"2020-02-14T23:55:00.000Z","updated":"2020-02-24T06:07:13.919Z","comments":true,"path":"2020/02/14/title:BinarySearch-stack-queue/","link":"","permalink":"http://yoursite.com/2020/02/14/title:BinarySearch-stack-queue/","excerpt":"","text":"【模版】(https://www.acwing.com/blog/content/277/) 69. Sqrt(x)12345678910Example 1:Input: 4Output: 2Example 2:Input: 8Output: 2Explanation: The square root of 8 is 2.82842..., and since the decimal part is truncated, 2 is returned. 12345678910int mySqrt(int x) &#123; int l = 0, r = x; while (l &lt; r) &#123; unsigned long long int mid = (l + r &gt;&gt; 1) + 1; if (mid*mid*1ll &lt;= x) l = mid; else r = mid - 1; // let r including target &#125; return r;&#125; 34. Find First and Last Position of Element in Sorted Array12345678Example 1:Input: nums &#x3D; [5,7,7,8,8,10], target &#x3D; 8Output: [3,4]Example 2:Input: nums &#x3D; [5,7,7,8,8,10], target &#x3D; 6Output: [-1,-1] 123456789101112131415161718192021222324252627vector&lt;int&gt; searchRange(vector&lt;int&gt;&amp; nums, int target) &#123; if (nums.empty()) return vector&lt;int&gt; (&#123;-1, -1&#125;); vector&lt;int&gt; res; int l = 0, r = nums.size() - 1; //find up = right, so else is l while ( l &lt; r) &#123; int mid = l + r &gt;&gt; 1; if (nums[mid] &gt;= target) r = mid; else l = mid + 1; &#125; if (nums[r] != target) return vector&lt;int&gt; (&#123;-1, -1&#125;); res.push_back(r); // find down = left, so else is r, need to + 1 l = 0, r = nums.size() - 1; while (l &lt; r) &#123; int mid = l + r + 1&gt;&gt; 1; if (nums[mid] &lt;= target) l = mid; else r = mid - 1; &#125; res.push_back(r); // push (r) always return res;&#125; 74. Search a 2D Matrix123456789101112131415161718Input:matrix &#x3D; [ [1, 3, 5, 7], [10, 11, 16, 20], [23, 30, 34, 50]]target &#x3D; 3Output: trueExample 2:Input:matrix &#x3D; [ [1, 3, 5, 7], [10, 11, 16, 20], [23, 30, 34, 50]]target &#x3D; 13Output: false 1234567891011121314bool searchMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int target) &#123; if (matrix.size() == 0 || matrix[0].size() == 0) return false; int n = matrix.size(), m = matrix[0].size(); int l = 0, r = n * m -1; // see it as one dimension // find up = right while (l &lt; r) &#123; int mid = l + r &gt;&gt; 1; // mid / m - &gt; row, mid % m - &gt; col if (matrix[mid / m][mid % m] &gt;= target) r = mid; else l = mid + 1; &#125; return matrix[r / m][r % m] == target;&#125; 240. Search a 2D Matrix II12345678910[ [1, 4, 7, 11, 15], [2, 5, 8, 12, 19], [3, 6, 9, 16, 22], [10, 13, 14, 17, 24], [18, 21, 23, 26, 30]]Given target &#x3D; 5, return true.Given target &#x3D; 20, return false. 12345678910111213bool searchMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int target) &#123; if (matrix.empty()|| matrix[0].empty()) return false; int i = 0, j = matrix[0].size()-1; while (i &lt; matrix.size() &amp;&amp; j &gt;= 0) &#123; int t = matrix[i][j]; if (t == target) return true; if (t &gt; target) j--; // delete col else i++; &#125; return false;&#125; 153. Find Minimum in Rotated Sorted Array12345678Example 1:Input: [3,4,5,1,2] Output: 1Example 2:Input: [4,5,6,7,0,1,2]Output: 0 1234567891011121314int findMin(vector&lt;int&gt;&amp; nums) &#123; //if sorted if (nums[0] &lt; nums.back()) return nums[0]; int l = 0, r = nums.size() - 1; while ( l &lt; r) &#123; int mid = (l + r &gt;&gt; 1); // find down = left if (nums[mid] &gt;= nums[0]) l = mid + 1; else r = mid; &#125; return nums[r]; &#125; 162. Find Peak Element12345678910111213You may imagine that nums[-1] &#x3D; nums[n] &#x3D; -∞.Example 1:Input: nums &#x3D; [1,2,3,1]Output: 2Explanation: 3 is a peak element and your function should return the index number 2.Example 2:Input: nums &#x3D; [1,2,1,3,5,6,4]Output: 1 or 5 Explanation: Your function can return either index number 1 where the peak element is 2, or index number 5 where the peak element is 6. 12341. nums[i] &gt; i+1 must exist a peak at right, otherwise it is acending, then the most right is peak nums[i-1] &gt; nums[i], must exist a peak at left, otherwise it is decreasing, then the most left is peak 12345678910111213int findPeakElement(vector&lt;int&gt;&amp; nums) &#123; if (nums.size() == 1 || nums[0] &gt; nums[1] ) return 0; int l = 0, r = nums.size() - 1; while (l &lt; r) &#123; int mid = l + r + 1&gt;&gt; 1; if (nums[mid] &gt; nums[mid-1]) l = mid; else r = mid - 1; &#125; return r;&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/categories/leetcode/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"},{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/tags/leetcode/"},{"name":"binary","slug":"binary","permalink":"http://yoursite.com/tags/binary/"},{"name":"stack","slug":"stack","permalink":"http://yoursite.com/tags/stack/"},{"name":"heap","slug":"heap","permalink":"http://yoursite.com/tags/heap/"}],"author":"isFibonacci"},{"title":"Hash Table (1)","slug":"title: Hash Table (1)","date":"2020-02-14T23:55:00.000Z","updated":"2020-02-21T02:14:57.605Z","comments":true,"path":"2020/02/14/title: Hash Table (1)/","link":"","permalink":"http://yoursite.com/2020/02/14/title:%20Hash%20Table%20(1)/","excerpt":"","text":"350. Intersection of Two Arrays II12345678Example 1:Input: nums1 &#x3D; [1,2,2,1], nums2 &#x3D; [2,2]Output: [2,2]Example 2:Input: nums1 &#x3D; [4,9,5], nums2 &#x3D; [9,4,9,8,4]Output: [4,9] 1234560 . use table to record element in the less length nums for loop to search the x1. Only add the least frequency intersection : Input: nums1 &#x3D; [4,9,5], nums2 &#x3D; [9,4,9,8,4] Output: [4,9] So, need to erase that x in the table 1234567891011121314151617181920vector&lt;int&gt; intersect(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123; // exchange the pointer if (nums1.size() &gt; nums2.size()) return intersect(nums2, nums1); unordered_multiset&lt;int&gt; hash; for (auto num : nums1) hash.insert(num); vector&lt;int&gt; res; for (auto num : nums2) &#123; if (hash.count(num)) &#123; res.push_back(num); // erase [2,2,2] [2,2] -&gt; [2, 2] auto it = hash.find(num); hash.erase(it); &#125; if (hash.size() == 0) return res; &#125; return res;&#125; 1234567map, multimap, set, multiset : red black treesorted, O(nlogn)unordered_map, unordered_multimap, unordered_set, unordered_multiset,dictionary, O(1) 706. Design HashMap1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253class MyHashMap &#123;public: /** Initialize your data structure here. */ const static int N = 20011; vector&lt;list&lt;pair&lt;int, int&gt;&gt;&gt; hash; MyHashMap() &#123; hash = vector&lt;list&lt;pair&lt;int, int&gt;&gt;&gt;(N); &#125; list&lt;pair&lt;int, int&gt;&gt;::iterator find(int key) &#123; int t = key % N; auto it = hash[t].begin(); for (; it != hash[t].end(); it++) &#123; if (it-&gt;first == key) break; &#125; return it; &#125; /** value will always be non-negative. */ void put(int key, int value) &#123; int t = key % N; auto it = find(key); if (it == hash[t].end()) // not have hash[t].push_back(make_pair(key, value)); else it-&gt;second = value; &#125; /** Returns the value to which the specified key is mapped, or -1 if this map contains no mapping for the key */ int get(int key) &#123; int t = key % N; auto it = find(key); if (it == hash[t].end()) return -1; return it-&gt;second; &#125; /** Removes the mapping of the specified value key if this map contains a mapping for the key */ void remove(int key) &#123; int t = key % N; auto it = find(key); if (it != hash[t].end()) hash[t].erase(it); &#125;&#125;; 652. Find Duplicate Subtrees1234567891011121314151617Example 1: 1 &#x2F; \\ 2 3 &#x2F; &#x2F; \\ 4 2 4 &#x2F; 4The following are two duplicate subtrees: 2 &#x2F; 4and 4 1231. dfs, record the frequency of each subtree2. hash is O(1), copy string is O(n), recursion left and right so O(n^2) 12345678910111213141516171819// record the string frequencyunordered_map&lt;string, int&gt; hash;vector&lt;TreeNode*&gt; ans;string dfs(TreeNode* node) &#123; if (!node) return \" \"; string left = dfs(node-&gt;left); string right = dfs(node-&gt;right); string s = to_string(node-&gt;val) + ',' + left + ',' + right; if (++hash[s] == 2) ans.push_back(node); return s;&#125;vector&lt;TreeNode*&gt; findDuplicateSubtrees(TreeNode* root) &#123; dfs(root); return ans;&#125; 290. Word Pattern123456Input: pattern &#x3D; &quot;abba&quot;, str &#x3D; &quot;dog cat cat dog&quot;Output: trueExample 2:Input:pattern &#x3D; &quot;abba&quot;, str &#x3D; &quot;dog cat cat fish&quot;Output: false 1231. each word map to specific string string map to specific word worng: b -&gt; bc, c-&gt;bc 12345678910111213141516171819202122bool wordPattern(string pattern, string str) &#123; stringstream raw(str); vector&lt;string&gt; words; string word; while (raw &gt;&gt; word) words.push_back(word); if (pattern.size() != words.size()) return false; unordered_map&lt;char, string&gt; patString; unordered_map&lt;string, char&gt; stringPat; for (int i = 0; i &lt; words.size(); i++) &#123; char c = pattern[i]; string s = words[i]; if (!patString.count(c)) patString[c] = s; if (!stringPat.count(s)) stringPat[s] = c; if (patString[c] != s || stringPat[s] != c) return false; &#125; return true; &#125; 554. Brick Wall11. record the max count of same length 1234567891011121314151617int leastBricks(vector&lt;vector&lt;int&gt;&gt;&amp; wall) &#123; unordered_map&lt;int, int&gt; hash; int res = 0; for (auto blocks : wall) &#123; int sum = 0; // each row for (int i = 0; i + 1 &lt; blocks.size(); i++) &#123; sum += blocks[i]; hash[sum]++; res = max(res, hash[sum]); &#125; &#125; return wall.size() - res;&#125; 149. Max Points on a Line12341. set a point, record the slop2. if vertical slop &#x3D; infinite, duplicate3. If the last one is duplicate : need two loop, frist to find the duplicate and vertical 1234567891011121314151617181920212223242526272829303132int maxPoints(vector&lt;vector&lt;int&gt;&gt;&amp; points) &#123;if (points.empty()) return 0;int res = 1;for (int i = 0; i &lt; points.size(); i++) &#123; int vertical = 1, duplicate = 0; // duplicate, vertical for (int j = i + 1; j &lt; points.size(); j++) &#123; if (points[i][0] == points[j][0]) &#123; if (points[i][1] == points[j][1]) duplicate++; vertical++; &#125; &#125; // slop unordered_map&lt;long double, int&gt; hash; for (int j = i + 1; j &lt; points.size(); j++) &#123; if (points[i][0] != points[j][0]) &#123; long double slop = (long double) (points[i][1] - points[j][1]) / (points[i][0] - points[j][0]); if (hash.count(slop)) hash[slop]++; else hash[slop] = 2; res = max(res, duplicate + hash[slop]); &#125; &#125; // need to compare choose the vertical or slop res = max(res, vertical); &#125;return res;&#125; 355. Design Twitter123456789101112131415161718192021222324252627282930313233343536373839404142434445/** Initialize your data structure here. */unordered_map&lt;int, vector&lt;pair&lt;int, int&gt;&gt;&gt; posts; // UserID, &lt;postDate, postID&gt;unordered_map&lt;int, unordered_set&lt;int&gt;&gt; follows; // UserID map to followsint id = 0; // postDateTwitter() &#123; &#125;/** Compose a new tweet. */void postTweet(int userId, int tweetId) &#123; posts[userId].push_back(make_pair(id++, tweetId)); // postDate++&#125;/** Retrieve the 10 most recent tweet ids in the user's news feed. Each item in the news feed must be posted by users who the user followed or by the user herself. Tweets must be ordered from most recent to least recent. */vector&lt;int&gt; getNewsFeed(int userId) &#123; // find all the post he posted vector&lt;pair&lt;int, int&gt;&gt; ps; for (auto t : posts[userId]) ps.push_back(t); // find all the post his followee posts for (auto follow : follows[userId]) for (auto t : posts[follow]) ps.push_back(t); sort(ps.rbegin(), ps.rend()); // id greater, date newer, so reverse begin vector&lt;int&gt; res; for (int i = 0; i &lt; 10 &amp;&amp; i &lt; ps.size(); i++) &#123; res.push_back(ps[i].second); // postID &#125; return res;&#125;/** Follower follows a followee. If the operation is invalid, it should be a no-op. */void follow(int followerId, int followeeId) &#123; if (followerId != followeeId) &#123; follows[followerId].insert(followeeId); &#125;&#125;/** Follower unfollows a followee. If the operation is invalid, it should be a no-op. */void unfollow(int followerId, int followeeId) &#123; follows[followerId].erase(followeeId); &#125; 128. Longest Consecutive Sequence123456789Given an unsorted array of integers, find the length of the longest consecutive elements sequence.Your algorithm should run in O(n) complexity.Example:Input: [100, 4, 200, 1, 3, 2]Output: 4Explanation: The longest consecutive elements sequence is [1, 2, 3, 4]. Therefore its length is 4. 12345671. Because it is consecutive, hash[x-1] is the number of LEFT consecutive points hash[x+1] is the number of RIGHT consecutive points2. hash[x-left] &#x3D; during the left to x, the nubmer of points hash[x+right] &#x3D; during the x to right+x, the numbr of points hash[x+right] can be seen as x+right+1 point hash[x-left] 现在终点可以看成下一段的起点 1234567891011121314151617int longestConsecutive(vector&lt;int&gt;&amp; nums) &#123; int res = 0; unordered_map&lt;int, int&gt; hash; // key: idnex, value : val for (auto x : nums) &#123; if (hash[x]) continue; // repeat hash[x] = 1; // itself, mark int left = hash[x-1]; // the number points of left int right = hash[x+1]; // the number points of right // update hash[x-left] = left+right+1; hash[x+right] = left+right+1; res = max(res, left+right+1); &#125; return res; &#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/categories/leetcode/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"},{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/tags/leetcode/"},{"name":"Hash Table","slug":"Hash-Table","permalink":"http://yoursite.com/tags/Hash-Table/"}],"author":"isFibonacci"},{"title":"Hash Table (0)","slug":"title: Hash Table (0)","date":"2020-02-13T23:55:00.000Z","updated":"2020-02-21T02:46:23.153Z","comments":true,"path":"2020/02/13/title: Hash Table (0)/","link":"","permalink":"http://yoursite.com/2020/02/13/title:%20Hash%20Table%20(0)/","excerpt":"","text":"1. Two Sum1234Given nums &#x3D; [2, 7, 11, 15], target &#x3D; 9,Because nums[0] + nums[1] &#x3D; 2 + 7 &#x3D; 9,return [0, 1]. 1234567891011vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; unordered_map&lt;int, int&gt; hash; for (int i = 0; i &lt; nums.size(); i++) &#123; int t = target - nums[i]; if (hash.count(t)) return vector&lt;int&gt;(&#123;hash[t], i&#125;); // careful here hash[nums[i]] = i; &#125; return vector&lt;int&gt;();&#125; 454. 4Sum II12345678910111213Input:A &#x3D; [ 1, 2]B &#x3D; [-2,-1]C &#x3D; [-1, 2]D &#x3D; [ 0, 2]Output:2Explanation:The two tuples are:1. (0, 0, 0, 1) -&gt; A[0] + B[0] + C[0] + D[1] &#x3D; 1 + (-2) + (-1) + 2 &#x3D; 02. (1, 1, 0, 0) -&gt; A[1] + B[1] + C[0] + D[0] &#x3D; 2 + (-1) + (-1) + 0 &#x3D; 0 12It is euqal to find the opposite value of A+BBc, A+B + C+D &#x3D; 0 &#x3D;&gt; A+B &#x3D; -C-D 12345678910111213int fourSumCount(vector&lt;int&gt;&amp; A, vector&lt;int&gt;&amp; B, vector&lt;int&gt;&amp; C, vector&lt;int&gt;&amp; D) &#123; unordered_map&lt;int, int&gt; hash; int res = 0; for (auto a : A) for (auto b : B) hash[a+b]++; for (auto c : C) for (auto d : D) res += hash[-c-d]; return res;&#125; 560. Subarray Sum Equals K123Given an array of integers and an integer k, you need to find the total number of continuous subarrays whose sum equals to k.Input:nums &#x3D; [1,1,1], k &#x3D; 2Output: 2 1234前缀合思想Need to find sum[j] - sum[i] &#x3D; k -&gt; hash[sum-k]use hash table to record previous sumhash[sum]++; 1234567891011121314151617int subarraySum(vector&lt;int&gt;&amp; nums, int k) &#123; int res = 0, sum = 0; unordered_map&lt;int, int&gt; hash; hash[0] = 1; // if the previous two meet the requirement for (auto num : nums) &#123; sum += num; // sum[j] - sum[i] = k res += hash[sum-k]; hash[sum]++; &#125; return res;&#125; 525. Contiguous Array12345678Example 1:Input: [0,1]Output: 2Explanation: [0, 1] is the longest contiguous subarray with equal number of 0 and 1.Example 2:Input: [0,1,0]Output: 2Explanation: [0, 1] (or [1, 0]) is a longest contiguous subarray with equal number of 0 and 1. 123451. 0 -&gt; -1, 1 -&gt; 1, convert question to find the length previous sum &#x3D; 02. use hash table to record the first index of previous sum &#x3D; 0;3. the max length &#x3D; i - previous sum index res &#x3D; max(i-index, res)4. hash[0] &#x3D; -1 bc [0,1] - &gt; i &#x3D; 1, i-hash[0] &#x3D; 2 1234567891011121314151617int findMaxLength(vector&lt;int&gt;&amp; nums) &#123; unordered_map&lt;int, int&gt; hash; hash[0] = -1; int sum = 0, res = 0; for (int i = 0; i &lt; nums.size(); i++) &#123; sum += nums[i] ? 1 : -1; // 0 -&gt; -1, 1 -&gt; 1 //if have if (hash.count(sum)) res = max(res, i - hash[sum]); //not have, add it into hashtable else hash[sum] = i; &#125; return res;&#125; 187. Repeated DNA Sequences123Input: s &#x3D; &quot;AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT&quot;Output: [&quot;AAAAACCCCC&quot;, &quot;CCCCCAAAAA&quot;] 1231. key is the sub string, value is the times it appear2. ++hash[sub] : add into hash, if it &#x3D;&#x3D; 1, so it&#39;s the second times it appear since we have one sub now, and another is saved in the hash table 1234567891011vector&lt;string&gt; findRepeatedDnaSequences(string s) &#123; unordered_map&lt;string, int&gt; hash; vector&lt;string&gt; res; for (int i = 0; i + 10 &lt;= s.size(); i++) &#123; string str = s.substr(i, 10); hash[str]++; if (hash[str] == 2) res.push_back(str); &#125; return res;&#125; 347. Top K Frequent Elements1234567891011121314Given a non-empty array of integers, return the k most frequent elements.Example 1:Input: nums &#x3D; [1,1,1,2,2,3], k &#x3D; 2Output: [1,2]Example 2:Input: nums &#x3D; [1], k &#x3D; 1Output: [1]**1 ≤ k ≤ number of unique elements.****OUTPUT the k most frequency, e.g. k &#x3D; 2, two numbers, k &#x3D; 3, 3 numbers****NOT K frequency** 1234561. [Counting sort](https:&#x2F;&#x2F;www.geeksforgeeks.org&#x2F;counting-sort&#x2F;), the value as it&#39;s index array index2. In the index array, the value is the index of the places index remember to decrease3. In this question, the index is the frequency, use hashtable to record the frequency and number.4. Find the cut off, and before the cut off, add them to the res. 123456789101112131415161718192021222324252627vector&lt;int&gt; topKFrequent(vector&lt;int&gt;&amp; nums, int k) &#123; unordered_map&lt;int, int&gt; hash; // recored the frequency for (auto t : nums) hash[t]++; int n = nums.size(); // genereate array vector&lt;int&gt; arr(n+1, 0); // place num in arr by the frequency for (auto t : hash) arr[t.second]++; int cut = n, t = 0; while (t &lt; k) t += arr[cut--]; vector&lt;int&gt; res; for (auto t : hash) if (t.second &gt; cut &amp;&amp; res.size() &lt; k) res.push_back(t.first); return res; &#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/categories/leetcode/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"},{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/tags/leetcode/"},{"name":"Hash Table","slug":"Hash-Table","permalink":"http://yoursite.com/tags/Hash-Table/"}],"author":"isFibonacci"},{"title":"Pointers and Dynamic Memory Allocation(2)","slug":"title:  Pointers and Dynamic Memory  2","date":"2020-02-12T01:55:00.000Z","updated":"2020-02-13T19:07:15.217Z","comments":true,"path":"2020/02/11/title:  Pointers and Dynamic Memory  2/","link":"","permalink":"http://yoursite.com/2020/02/11/title:%20%20Pointers%20and%20Dynamic%20Memory%20%202/","excerpt":"","text":"String functions with pointersstrcmp, strcpy1234567891011121314151617181920int cmp1, cmp2;char string1[10] = \"abcxyz\";char string2[10] = \"xyz\";char newText[10];char* subStr = nullptr;cmp1 = strcmp(string1, string2);cout &lt;&lt; \"strcmp of \\\"\" &lt;&lt; string1 &lt;&lt; \"\\\" and \\\"\";cout &lt;&lt; string2 &lt;&lt; \"\\\" returned \" &lt;&lt; cmp1 &lt;&lt; endl;subStr = &amp;string1[3];cmp2 = strcmp(subStr, \"xyz\");cout &lt;&lt; \"strcmp of \\\"\" &lt;&lt; subStr;cout &lt;&lt; \"\\\" and \\\"xyz\\\" returned \";cout &lt;&lt; cmp2 &lt;&lt; endl;strcpy(newText, subStr);cout &lt;&lt; \"newText is now \\\"\" &lt;&lt; newText &lt;&lt; \"\\\"\";cout &lt;&lt; endl; OUTPUT 123strcmp of &quot;abcxyz&quot; and &quot;xyz&quot; returned -23strcmp of &quot;xyz&quot; and &quot;xyz&quot; returned 0newText is now &quot;xyz&quot; strchr(), strrchr(), strstr()123456789101112131415161718192021222324char orgName[100] = \"The Dept. of Redundancy Dept.\"; char newText[100]; char* subString = nullptr;...if (strchr(orgName, 'D') != nullptr) &#123; // 'D' exists in orgName? subString = strchr(orgName, 'D'); // Points to first 'D' strcpy(newText, subString); // newText now \"Dept. of Redundancy Dept.\"&#125;...if (strrchr(orgName, 'D') != nullptr) &#123; // 'D' exists in orgName? subString = strrchr(orgName, 'D'); // Points to last 'D' strcpy(newText, subString); // newText now \"Dept.\"&#125;...subString = strstr(orgName, \"Dept\"); // Points to first 'D'if (subString != nullptr) &#123; strcpy(newText, subString); // newText now \"Dept. of Redundancy Dept.\"&#125; Memory regions: Heap/Stack upload successful Destructors upload successful When the destructors call upload successful 12listToDisplay is passed by reference, so the destructor is not called at the end of the DisplayList function. 1234567void DisplayList(LinkedList&amp; listToDisplay) &#123; LinkedListNode* node = listToDisplay.head; while(node) &#123; cout &lt;&lt; node-&gt;data &lt;&lt; \" \"; node = node-&gt;next; &#125;&#125; 12listToDisplay is not passed by pointer or by reference and goes out of scope at the end of the DisplayList function. Thus, listToDisplay&#39;s destructor is called. 1234567void DisplayList(LinkedList listToDisplay) &#123; LinkedListNode* node = listToDisplay.head; while(node) &#123; cout &lt;&lt; node-&gt;data &lt;&lt; \" \"; node = node-&gt;next; &#125;&#125; Memory leaks upload successful 1234567int main() &#123; MyClass* ptrOne = new MyClass; MyClass* ptrTwo = new MyClass; ptrOne = ptrTwo; return 0;&#125; SO MAKE SURE INITIALIZE DESTRUCTOR 123456789101112131415161718192021222324class MyClass &#123; public: MyClass() &#123; subObject = new int; *subObject = 0; &#125; ~MyClass() &#123; delete subObject; &#125; private: int* subObject;&#125;;int main() &#123; MyClass* ptrOne = new MyClass; MyClass* ptrTwo = new MyClass; ... delete ptrOne; ptrOne = ptrTwo; return 0;&#125; ```C++Vector cubes(intnumCubes){ Vector vec; for (inti= 0; i&lt; numCubes; i++) vec.add(i* i* i); return vec;} // It does, but there is an issue.// The copy constructor of the Vector class is invoked because a value is being returned.// We do not want to make copies of large objects. Vector &amp;cubes(intnumCubes){ Vector vec; for (inti= 0; i&lt; numCubes; i++) vec.add(i* i* i); return vec;} /* This is really reallybad.The scope of vecis only within the function and once the function terminates the stack is cleaned up,thus the reference to the memory location is destroyed. */ Vector cubes(intnumCubes){ Vector vec; for (inti= 0; i&lt; numCubes; i++) vec.add(i i* i); return vec;} /* This is really reallyreallybad.The scope of vecis only within the function and once the function terminates the stack is cleaned up (all local variables are destroyed),thus the reference to the memory location is destroyed.Hence the pointer is pointing at a NULL reference which eventually will cause your program to crash. */","categories":[{"name":"Program Language","slug":"Program-Language","permalink":"http://yoursite.com/categories/Program-Language/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"}],"author":"isFibonacci"},{"title":"Tree (0)","slug":"Tree (0)","date":"2020-02-11T01:55:00.000Z","updated":"2020-02-14T04:28:30.206Z","comments":true,"path":"2020/02/10/Tree (0)/","link":"","permalink":"http://yoursite.com/2020/02/10/Tree%20(0)/","excerpt":"","text":"235. Lowest Common Ancestor of a Binary Search Tree1234567def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -&gt; 'TreeNode': if p.val &lt; root.val and q.val &lt; root.val : return self.lowestCommonAncestor(root.left, p, q) elif p.val &gt; root.val and q.val &gt; root.val : return self.lowestCommonAncestor(root.right, p, q) else : return root 236. Lowest Common Ancestor of a Binary Tree12345678910111213141516171819202122232425ans = None def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -&gt; 'TreeNode': #LCA : find the node that p and q seperate def dfs(cur) -&gt; 'boolean' : if not cur : return False left = dfs(cur.left) #if cur node is q or p, so don't need to dfs right mid = cur == q or cur == p right = dfs(cur.right) #so don't need to dfs deep if mid+right+left &gt;= 2 : self.ans = cur #bring the ans up to previous level return mid or left or right dfs(root) return self.ans","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/categories/leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/tags/leetcode/"},{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"},{"name":"tree","slug":"tree","permalink":"http://yoursite.com/tags/tree/"}],"author":"isFibonacci"},{"title":"Greedy Algorithm (2)","slug":"Greedy Algorithm (2)","date":"2020-02-11T01:55:00.000Z","updated":"2020-02-18T23:56:23.188Z","comments":true,"path":"2020/02/10/Greedy Algorithm (2)/","link":"","permalink":"http://yoursite.com/2020/02/10/Greedy%20Algorithm%20(2)/","excerpt":"","text":"376. Wiggle Subsequence1234567Input: [1,7,4,9,2,5]Output: 6Explanation: The entire sequence is a wiggle sequence.Input: [1,17,5,10,13,15,10,5,16,8]Output: 7Explanation: There are several subsequences that achieve this length. One is [1,17,10,13,10,16,8]. 1234567The longest subsequences will always start at first, to the last one.Since it is subsequence, not need to successive.Proof : [1, -1, -1, -2, 3, 2, 5, 5][-1, -2, 3, 2, 5] can see as [1, -2, 3, 2, 5]Maintain two booleans to record the previous is incr or decrMaintain previous to determind whether cur is valid 123456789101112131415161718def wiggleMaxLength(self, nums: List[int]) -&gt; int: if len(nums) &lt; 2 : return len(nums) incr, decr = True, True count = 1 prev = nums[0] for num in nums[1:] : if num &lt; prev and incr : count += 1 incr, decr = False, True elif num &gt; prev and decr : count += 1 incr, decr = True, False prev = num return count 406. Queue Reconstruction by Height123456789Suppose you have a random list of people standing in a queue. Each person is described by a pair of integers (h, k), where h is the height of the person and k is the number of people in front of this person who have a height greater than or equal to h. Write an algorithm to reconstruct the queue.Input:[[7,0], [4,4], [7,1], [5,0], [6,1], [5,2]]Output:[[5,0], [7,0], [5,2], [6,1], [4,4], [7,1]] 1234561. sort increasing2. map people higher you to index -&gt; pop() e.g [[4, 0], [5, 0]] : indexs : [0, 1] pop(0) -&gt; 0 so indexs : [1] pop(0) -&gt; 1 so pop will delete 0, and 1 will be at the index 0 12345678910111213141516171819202122def reconstructQueue(self, people: List[List[int]]) -&gt; List[List[int]]: n = len(people) if n == 0 or n == 1: return people res = [[]]*n #increasing people.sort(key = lambda x : (x[0], -x[1])) #map of index # [0, 1, 2, 3] -&gt; pop(0) = 0 : [1, 2, 3]-&gt; pop(0) = 1: [2, 3] indexs = [i for i in range(n)] for i, (_, pepHiger) in enumerate(people) : j = indexs.pop(pepHiger) #j is how many people higer and before you res[j] = people[i] return res 452. Minimum Number of Arrows to Burst Balloons12345678Input:[[10,16], [2,8], [1,6], [7,12]]Output:2Explanation:One way is to shoot one arrow for example at x &#x3D; 6 (bursting the balloons [2,8] and [1,6]) and another arrow at x &#x3D; 11 (bursting the other two balloons). 1234567891011def findMinArrowShots(self, points: List[List[int]]) -&gt; int: points.sort(key = lambda x : (x[1])) res, right = 0, float('-inf') for point in points : #new if right &lt; point[0] : res += 1 right = point[1] return res 402. Remove K Digits123Input: num &#x3D; &quot;10200&quot;, k &#x3D; 1Output: &quot;200&quot;Explanation: Remove the leading 1 and the number is 200. Note that the output must not contain leading zeroes. 123456789101112131415res = []n = len(num)if n == k : return '0'for char in num : while k and res and res[-1] &gt; char : res.pop() k -= 1 res.append(char)while k : res.pop() k -= 1return ''.join(res).lstrip('0') or \"0\"#remove leading 0, if \"\" need to return \"0\" 134. Gas Station1234567891011121314Input: gas &#x3D; [1,2,3,4,5]cost &#x3D; [3,4,5,1,2]Output: 3Explanation:Start at station 3 (index 3) and fill up with 4 unit of gas. Your tank &#x3D; 0 + 4 &#x3D; 4Travel to station 4. Your tank &#x3D; 4 - 1 + 5 &#x3D; 8Travel to station 0. Your tank &#x3D; 8 - 2 + 1 &#x3D; 7Travel to station 1. Your tank &#x3D; 7 - 3 + 2 &#x3D; 6Travel to station 2. Your tank &#x3D; 6 - 4 + 3 &#x3D; 5Travel to station 3. The cost is 5. Your gas is just enough to travel back to station 3.Therefore, return 3 as the starting index. 123451. brute force : for each station, run a loop2. # for i to j, i can only to j, i+1 can also to j, but # we don&#39;t need to try. bc when we start from i, and get to i+1 # we have more gas but still can only get to j. # Now we start from i, we have less gas, so we cannot get further than j 12345678910111213141516171819202122232425262728def canCompleteCircuit(self, gas: List[int], cost: List[int]) -&gt; int: n = len(gas) if n == 0 : return 0 i = 0 while i &lt; n : # for each station gasLeft = 0 j = 0 while j &lt; n : # j start from 0 is the same as start from i+1, a loop k = (i+j) % n gasLeft = gasLeft + gas[k] - cost[k] if gasLeft &lt; 0 : break j += 1 if j &gt;= n : # the gasLeft can make a loop return i i += j + 1 #for i to j, i can only to j, i+1 can also to j, but # we don't need to try. bc when we start from i, and get to i+1 # we have more gas but still can only get to j. #Now we start from i, we have less gas, so we cannot get further than j return -1","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/categories/leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/tags/leetcode/"},{"name":"greedy algorithm","slug":"greedy-algorithm","permalink":"http://yoursite.com/tags/greedy-algorithm/"},{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}],"author":"isFibonacci"},{"title":"Pointers and Dynamic Memory Allocation(1)","slug":"title:  Pointers and Dynamic Memory All","date":"2020-02-11T01:55:00.000Z","updated":"2020-02-14T04:17:01.314Z","comments":true,"path":"2020/02/10/title:  Pointers and Dynamic Memory All/","link":"","permalink":"http://yoursite.com/2020/02/10/title:%20%20Pointers%20and%20Dynamic%20Memory%20All/","excerpt":"","text":"PointerIn vecotr, if the capacity is over size, vector will expand the size, and point toanother continous memory. reference, deference123456789101112131415int someInt;int* valPointer; someInt = 5;cout &lt;&lt; \"someInt address is \" &lt;&lt; &amp;someInt &lt;&lt; endl;valPointer = &amp;someInt; cout &lt;&lt; \"valPointer is \" &lt;&lt; valPointer &lt;&lt; endl;cout &lt;&lt; \"*valPointer is \" &lt;&lt; *valPointer &lt;&lt; endl;*valPointer = 10; // Changes someInt to 10cout &lt;&lt; \"someInt is \" &lt;&lt; someInt &lt;&lt; endl;cout &lt;&lt; \"*valPointer is \" &lt;&lt; *valPointer &lt;&lt; endl; 12345someInt address is 76valPointer is 76*valPointer is76someInt is 10*valPointer is 10 COMMON ERROR 12345671. prog.cpp:10:13: error: invalid conversion from &#39;int&#39; to &#39;int*&#39; [-fpermissive] int *ptr &#x3D; var; CORRECT : int *ptr &#x3D; &amp;var;2. Segmentation Fault (SIGSEGV), dereferencing unknown address *ptr &#x3D; var; Three ways12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//Pass-by-Value int square1(int n) &#123; //Address of n in square1() is not the same as n1 in main() cout &lt;&lt; \"address of n1 in square1(): \" &lt;&lt; &amp;n &lt;&lt; \"\\n\"; // clone modified inside the function n *= n; return n; &#125; //Pass-by-Reference with Pointer Arguments void square2(int *n) &#123; //Address of n in square2() is the same as n2 in main() cout &lt;&lt; \"address of n2 in square2(): \" &lt;&lt; n &lt;&lt; \"\\n\"; // Explicit de-referencing to get the value pointed-to *n *= *n; &#125; //Pass-by-Reference with Reference Arguments void square3(int &amp;n) &#123; //Address of n in square3() is the same as n3 in main() cout &lt;&lt; \"address of n3 in square3(): \" &lt;&lt; &amp;n &lt;&lt; \"\\n\"; // Implicit de-referencing (without '*') n *= n; &#125; ... //Call-by-Value int n1=8; cout &lt;&lt; \"address of n1 in main(): \" &lt;&lt; &amp;n1 &lt;&lt; \"\\n\"; cout &lt;&lt; \"Square of n1: \" &lt;&lt; square1(n1) &lt;&lt; \"\\n\"; cout &lt;&lt; \"No change in n1: \" &lt;&lt; n1 &lt;&lt; \"\\n\"; //Call-by-Reference with Pointer Arguments int n2=8; cout &lt;&lt; \"address of n2 in main(): \" &lt;&lt; &amp;n2 &lt;&lt; \"\\n\"; square2(&amp;n2); cout &lt;&lt; \"Square of n2: \" &lt;&lt; n2 &lt;&lt; \"\\n\"; cout &lt;&lt; \"Change reflected in n2: \" &lt;&lt; n2 &lt;&lt; \"\\n\"; //Call-by-Reference with Reference Arguments int n3=8; cout &lt;&lt; \"address of n3 in main(): \" &lt;&lt; &amp;n3 &lt;&lt; \"\\n\"; square3(n3); cout &lt;&lt; \"Square of n3: \" &lt;&lt; n3 &lt;&lt; \"\\n\"; cout &lt;&lt; \"Change reflected in n3: \" &lt;&lt; n3 &lt;&lt; \"\\n\"; ... OUTPUT 123456789101112address of n1 in main(): 0x7ffcf4d06e2caddress of n1 in square1(): 0x7ffcf4d06e0cSquare of n1: 64No change in n1: 8address of n2 in main(): 0x7ffcf4d06e30address of n2 in square2(): 0x7ffcf4d06e30Square of n2: 64Change reflected in n2: 64address of n3 in main(): 0x7ffcf4d06e34address of n3 in square3(): 0x7ffcf4d06e34Square of n3: 64Change reflected in n3: 64 COMMON ERROR 12345678910cout &lt;&lt; &quot;Square of n1: &quot; &lt;&lt; square1(n1) &lt;&lt; &quot;\\n&quot;; void square1(n1) &#123; ... cout &lt;&lt; &quot;address of n1 in square1(): &quot; &lt;&lt; &amp;n &lt;&lt; &quot;\\n&quot;; ...&#125;call square1(n1) -&gt; call cout :address of n1 in square1(): 0x7ffcf4d06e0cSquare of n1: 64 Array Name as Pointers1234567891011121314void test() &#123; //Declare an array int val[3] = &#123; 5, 10, 20 &#125;; //declare pointer variable int *ptr; //Assign the address of val[0] to ptr // We can use ptr=&amp;val[0];(both are same) ptr = val ; cout &lt;&lt; \"Elements of the array are: \"; cout &lt;&lt; ptr[0] &lt;&lt; \" \" &lt;&lt; *(++ptr) &lt;&lt; \" \" &lt;&lt; val[2]; &#125; OUTPUT 1Elements of the array are: 5 10 20 NULLWhen a pointer is declared, the pointer variable holds an unknown address until the pointer is initialized.A programmer may wish to indicate that a pointer points to “nothing” by initializing a pointer to null 12345678910111213141516171819void PrintValue(int* valuePointer) &#123; if (valuePointer == nullptr) &#123; cout &lt;&lt; \"Pointer is null\" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; *valuePointer &lt;&lt; endl; &#125;&#125;int main() &#123; int someInt = 5; int* valPointer = nullptr; PrintValue(valPointer); valPointer = &amp;someInt; PrintValue(valPointer); return 0;&#125; Operators:new, delete, and -&gt; The new operator allocates memory for the given type and returns a pointer to the allocated memory. If the type is a class, the new operator calls the class’s constructor after allocating memory for the class’s member variables. 12345678910111213141516171819202122232425262728class Point &#123;public: Point(double xValue = 0, double yValue = 0); void Print(); double X; double Y;&#125;;Point:: Point(double xValue, double yValue) &#123; X = xValue; Y = yValue;&#125;void Point::Print() &#123; cout &lt;&lt; \"(\" &lt;&lt; X &lt;&lt; \", \"; cout &lt;&lt; Y &lt;&lt; \")\" &lt;&lt; endl;&#125;int main() &#123; Point* point1 = new Point; point1-&gt;Print(); Point* point2 = new Point(8, 9); (*point2).Print(); return 0;&#125; 12type *variable &#x3D; new type; &#x2F;&#x2F; allocates one elementortype *variable &#x3D; new type[n];&#x2F;&#x2F; allocates n elements I.e. an array of type The member access operator12(*point2).Print();point2-&gt;Print(); The delete operator12345678910int main() &#123; Point* point1 = new Point(73, 19); cout &lt;&lt; \"X = \" &lt;&lt; point1-&gt;X &lt;&lt; endl; cout &lt;&lt; \"Y = \" &lt;&lt; point1-&gt;Y &lt;&lt; endl; delete point1; // Error: can't use point1 after deletion point1-&gt;Print();&#125; Allocating and deleting object arrays12345678910// Allocate pointsint pointCount = 4;Point* manyPoints = new Point[pointCount];// Display each pointfor (int i = 0; i &lt; pointCount; ++i) manyPoints[i].Print();// Free all points with one deletedelete[] manyPoints; 1234567A dynamically allocated array is freed with one statement. Objects in the array cannot be deleted individually.ERROR :for (;i &lt; n; i++) &#123; delete pointers[i];&#125; Deallocating memory12345678910111213141516171819class PaintContainer &#123; public: ~PaintContainer(); double gallonPaint;&#125;;PaintContainer::~PaintContainer() &#123; // Covered in section on Destructors. cout &lt;&lt; \"PaintContainer deallocated.\" &lt;&lt; endl;&#125;int main() &#123; PaintContainer* kitchenPaint; kitchenPaint = new PaintContainer; kitchenPaint-&gt;gallonPaint = 26.3; delete kitchenPaint; return 0;&#125; OUTOU 1PaintContainer deallocated. 12345678910111213141516171819202122class Fun&#123; public: Fun(int_size = 10):size(_size)&#123; nums= new int[size]; for(inti= 0; i&lt; size; i++) nums[i] = i + 1; &#125; void display()&#123; for(inti= 0; i&lt; size; i++) cout&lt;&lt; nums[i] &lt;&lt; “ “;std::cout&lt;&lt; ‘\\n’; &#125; ~Fun()&#123; delete [] nums; &#125; private: int size; int*nums;&#125;;int main()&#123; Fun funstuff; funstuff.display(); // destructor will be called when the block is terminated. No need to call delete return 0;&#125; 12345678...int main()&#123; Fun *moreFunstuff; // instance of Fun allocated on the heap moreFunstuff-&gt;display(); // destructor will not be called automatically. Need to call delete delete moreFunstuff; return 0;&#125; Challenge12345678910111213141516171819202122232425262728293031int k = 3, j = 5, *p = &amp;k, *q = &amp;j, *r;if (p == &amp;k) cout&lt;&lt;1&lt;&lt;endl; *p = k + 7; cout&lt;&lt;\"k = \" &lt;&lt;k&lt;&lt;\"*p =\" &lt;&lt;*p&lt;&lt;endl; cout&lt;&lt; &amp;*&amp;p &lt;&lt;endl; cout&lt;&lt; 7 * *p / *q + 7 &lt;&lt;endl; int x[10] = &#123;1, 2, 3, 4, 5&#125;; int *ptr = x; for(int i = 0; i &lt; 10; i++) cout &lt;&lt; *ptr++&lt;&lt;\" \"; cout&lt;&lt;endl; // for(int i = 0; i &lt; 10; i++) cout &lt;&lt; *x++ &lt;&lt; “ “; // *x refers to x[0] *(x+1) refers to x[1] int**intArray; intArray= new int*[8]; for(int k = 0; k &lt; 8 ; k++) intArray[k] = new int[8]; for(int r = 0; r &lt; 8; r++)&#123; for(int c = 0; c &lt; 8; c++)&#123; intArray[r][c] = 1 + rand() %100; cout&lt;&lt; setw(4) &lt;&lt; intArray[r][c] ; &#125; cout&lt;&lt; endl; &#125; for(int k = 0; k &lt; 8 ; k++) delete []intArray[k];","categories":[{"name":"Program Language","slug":"Program-Language","permalink":"http://yoursite.com/categories/Program-Language/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"}],"author":"isFibonacci"},{"title":"Inheritance and Polymorphism in C++ (3)","slug":"Inheritance and Polymorphism in C++ (3)","date":"2020-02-08T22:56:00.000Z","updated":"2020-02-14T04:16:39.649Z","comments":true,"path":"2020/02/08/Inheritance and Polymorphism in C++ (3)/","link":"","permalink":"http://yoursite.com/2020/02/08/Inheritance%20and%20Polymorphism%20in%20C++%20(3)/","excerpt":"","text":"Abstract classes: Introduction (generic)Object-oriented programming (OOP) : Classes Inheritance Abstract classes Abstract classes A pure virtual function is a virtual function that is not implemented in the base class, thus all derived classes must override the function. A pure virtual function is declared with the “virtual” keyword and is assigned with 0. Ex: virtual double ComputeArea() const = 0; declares a pure virtual function ComputeArea(). An abstract class is a class that cannot be instantiated as an object, but is the superclass for a subclass and specifies how the subclass must be implemented. Any class with one or more pure virtual functions is abstract. A concrete class is a class that is not abstract, and hence can be instantiated. 123456789101112131415161718192021222324252627282930class Shape &#123; protected: Point position; public: virtual ~Shape() &#123; &#125; virtual double ComputeArea() const = 0; Point GetPosition() const &#123; return position; &#125; void SetPosition(Point newPosition) &#123; position = newPosition; &#125; void MovePositionRelative(Point otherPosition) &#123; double x = position.GetX() + otherPosition.GetX(); double y = position.GetY() + otherPosition.GetY(); position.SetX(x); position.SetY(y); &#125;&#125;;int main(int argc, const char* argv[]) &#123; Shape* shape = new Shape(); // &lt;- ERROR!!! ...&#125; Omitting ComputeArea() makes the Circle class abstract. To be concrete, all pure virtual functions from the superclass, Shape, must be implemented. In Shape.h 1234567class Shape &#123; ... public: virtual ~Shape() &#123; &#125; virtual double ComputeArea() const = 0; ...&#125; In Circle.h 1234567891011121314class Circle : public Shape &#123; private: double radius; public: Circle(Point center, double radius) &#123; this-&gt;radius = radius; this-&gt;position = center; &#125; double ComputeArea() const &#123; return (M_PI * pow(radius, 2)); &#125;&#125;; Is-a versus has-a relationshipsCompositionThe ‘has-a’ relationship. A MotherInfo object ‘has a’ string object and ‘has a’ vector of ChildInfo objects, but no inheritance is involved. 12345678910111213141516class ChildInfo &#123; string firstName; string birthDate; string schoolName; ...&#125;;class MotherInfo &#123; string firstname; string birthDate; string spouseName; vector&lt;ChildInfo&gt; childrenData; ...&#125;; Inheritance 12345678910111213141516171819class PersonInfo &#123; string firstName; string birthDate; ...&#125;;class ChildInfo : public PersonInfo &#123; string schoolName; ...&#125;;class MotherInfo : public PersonInfo &#123; string spouseName; vector&lt;ChildInfo&gt; childrenData; ...&#125;; UML","categories":[{"name":"Program Language","slug":"Program-Language","permalink":"http://yoursite.com/categories/Program-Language/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"}],"author":"isFibonacci"},{"title":"Inheritance and Polymorphism in C++ (2)","slug":"Inheritance and Polymorphism in C++ (2)","date":"2020-02-07T22:56:00.000Z","updated":"2020-02-11T18:22:17.857Z","comments":true,"path":"2020/02/07/Inheritance and Polymorphism in C++ (2)/","link":"","permalink":"http://yoursite.com/2020/02/07/Inheritance%20and%20Polymorphism%20in%20C++%20(2)/","excerpt":"","text":"Overriding member functionsOverriding vs. overloadingIn overloading, functions with the same name must have different parameter types. In overriding, a derived class member function takes precedence over a base class member function with the same name, regardless of the parameter types. Overloading is not performed if derived and base member functions have different parameter types; the member function of the derived class hides the member function of the base class. Restaurant’s GetDescription() must be identical to Business’s GetDescription() name, return type, and parameter list. 1234567891011121314151617181920212223class Business &#123; public: ... string GetDescription() const &#123; return name + \" -- \" + address; protected: string name; string address;&#125;;class Restaurant : public Business &#123; public: ... string GetDescription() const &#123; return name + \" -- \" + address + \"\\n Rating: \" + to_string(rating); private: int rating;&#125;; Or you can call it conveniently : 12345678910class Restaurant : public Business &#123; ... string GetDescription() const &#123; return Business::GetDescription() + \"\\n Rating: \" + to_string(rating); &#125;; ...&#125;; Without the prepended base class name, the call to GetDescription() refers to itself (a recursive call) 123456789101112131415161718192021222324252627282930class Computer &#123;public: void SetComputerStatus(string cpuStatus, string internetStatus) &#123; cpuUsage = cpuStatus; internet = internetStatus; &#125;; void PrintStatus() &#123; cout &lt;&lt; \"CPU: \" &lt;&lt; cpuUsage &lt;&lt; endl; cout &lt;&lt; \"Internet: \" &lt;&lt; internet &lt;&lt; endl; &#125;;protected: string cpuUsage; string internet;&#125;;class Laptop : public Computer &#123;public: void SetComputerStatus(string cpuStatus, string internetStatus, string wifiStatus) &#123; cpuUsage = cpuStatus; internet = internetStatus; wifiQuality = wifiStatus; &#125;; void PrintStatus() &#123; Computer::PrintStatus(); cout &lt;&lt; \"WiFi: \" &lt;&lt; wifiQuality &lt;&lt; endl; &#125;; Polymorphism and virtual member functions Compile-time polymorphism is when the compiler determines which function to call at compile-time. Runtime polymorphism is when the compiler is unable to determine which function to call at compile-time, so the determination is made while the program is running. Function overloading is an example of compile-time polymorphism where the compiler determines which of several identically-named functions to call based on the function’s arguments. compile-time polymorphismconvert the Restaurant pointer to a Business pointer 1234567891011void DriveTo(string restaurant) &#123; cout &lt;&lt; \"Driving to \" &lt;&lt; restaurant &lt;&lt; endl;&#125;void DriveTo(Restaurant restaurant) &#123; cout &lt;&lt; \"Driving to \" &lt;&lt; restaurant.GetDescription() &lt;&lt; endl;&#125;int main() &#123; DriveTo(\"Big Mac's\"); // Call string version&#125; runtime polymorphism12345678910111213141516void DriveTo(Business* businessPtr) &#123; cout &lt;&lt; \"Driving to \" &lt;&lt; businessPtr-&gt;GetDescription() &lt;&lt; endl;&#125;int main() &#123; int index; vector&lt;Business*&gt; businessList; Business* businessPtr; Restaurant* restaurantPtr; ... businessList.push_back(businessPtr); businessList.push_back(restaurantPtr); index = rand() % businessList.size(); DriveTo(businessList.at(index);&#125; derived/base class pointer conversion :a pointer to a derived class is converted to a pointer to the base class without explicit casting The above statement businessList.push_back(restaurantPtr); uses derived/base class pointer conversion to convert the Restaurant pointer to a Business pointer (businessList is a vector of Business pointers). When derived/base class pointer conversion takes place, the compiler is unable to use compile-time polymorphism. Virtual functionsA virtual function is a member function that may be overridden in a derived class and is used for runtime polymorphism. 123456789101112131415161718192021222324252627282930class Business &#123;public: string GetDescription() const &#123; return name + \" -- \" + address; &#125; ...&#125;;class Restaurant : public Business &#123;public: string GetDescription() const &#123; return name + \" -- \" + address + \"\\n Rating: \" + to_string(rating); &#125; ...&#125;;int main() &#123; Business* businessPtr; Restaurant favoriteCafe; favoriteCafe.SetName(\"Friends Cafe\"); favoriteCafe.SetAddress(\"500 2nd Ave\"); favoriteCafe.SetRating(5); // Point to favoriteCafe businessPtr = &amp;favoriteCafe; cout &lt;&lt; businessPtr-&gt;GetDescription();&#125; businessPtr points to favoriteCafe. businessPtr-&gt;GetDesciption() calls Business GetDescription()instead of Restaurant GetDescription() because runtime polymorphism does not work without virtual functions. 12345678910111213141516171819202122232425class Business &#123;public: virtual string GetDescription() const &#123; return name + \" -- \" + address; &#125; ...&#125;;class Restaurant : public Business &#123;public: string GetDescription() const override &#123; return name + \" -- \" + address + \"\\n Rating: \" + to_string(rating); &#125; ...&#125;;int main() &#123; ... vector&lt;Business*&gt; businessList; Business* businessPtr; Restaurant* restaurantPtr; ...&#125; The “virtual” keyword makes GetDescription() a virtual function. The “override” keyword indicates that Restaurant GetDescription() overrides the base class GetDescription(). Running the program with an overridden virtual function causes runtime polymorphism to call Restaurant GetDescription(). Another way : 123void PrintDescription(Business&amp; business) &#123; cout &lt;&lt; business.GetDescription() &lt;&lt; endl;&#125; Runtime polymorphism only works with pointers to derived classes. 12345Restaurant favoritePlace;favoritePlace.SetName(\"Friends Cafe\");favoritePlace.SetAddress(\"500 2nd Ave\");favoritePlace.SetRating(5);cout &lt;&lt; favoritePlace.GetDescription(); The compiler can tell from the code that a Restaurant object is calling GetDescription(), so the overridden GetDescription() is called. Pure virtual functionsA pure virtual function is a virtual function that provides no definition in the base class, and all derived classes must override the function A class that has at least one pure virtual function is known as an abstract base class. An abstract base class object cannot be declared. Ex: The variable declaration Business someBusiness; generates a syntax error if Business is an abstract base class. 1234567891011121314151617181920class Business &#123;public: void SetName(string busName) &#123; name = busName; &#125; void SetAddress(string busAddress) &#123; address = busAddress; &#125; virtual string GetDescription() const &#123; return name + \" -- \" + address; &#125; virtual string GetHours() const = 0; // pure virtual functionprotected: string name; string address;&#125;;","categories":[{"name":"Program Language","slug":"Program-Language","permalink":"http://yoursite.com/categories/Program-Language/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"}],"author":"isFibonacci"},{"title":"Uniformed Search","slug":"Search","date":"2020-02-07T01:55:00.000Z","updated":"2020-02-14T04:16:45.693Z","comments":true,"path":"2020/02/06/Search/","link":"","permalink":"http://yoursite.com/2020/02/06/Search/","excerpt":"","text":"Uniformed Searcha. In deterministic environments the search solution is a single sequence (list of actions) b. Stochastic environments need multiple sequences to account for all possible outcomes of actions c. There are 5 parts to search: 1. Initial state 2. Actions possible at each state 3. Transition model (result of each action) 4. Goal test (are we there yet?) 5. Path costs/weights (not stored in states) (related to performance measure) Search algorithm BFS: FIFO The search algorithms metrics/criteria: 1. Completeness (does it terminate with a valid solution) 2. Optimality (is the answer the best solution) 3. Time (in big-O notation) 4. Space (big-O) b = maximum branching factor d = minimum depth of a goal m = maximum length of any path a. Uniform-cost search The only modification is when exploring a node we cannot disregard it if it has already been explored by another node We might have found a shorter path and thus need to update the cost on that node We also do not terminate when we find a goal, but instead when the goal has the lowest cost in the queue. UCS is.. 1. Complete (if costs strictly greater than 0) 2. Optimal However.... 3&amp;4. Time complexity = space complexity = O(b1+C*/min(path cost)), where C* cost of optimal solution (much worse than BFS) b. Bidirectional search It starts from both the goal and start (using BFS) until the trees meet This is better as 2*(bd/2) &lt; bd (the space is much worse than IDS, so only applicable to small problems)![upload successful](/images/pasted-7.png =100x) DFS: FILOMetrics: 1. Might not terminate (not correct) (e.g. in vacuum world, if first expand is action L) 2. Non-optimal (just… no) 3. Time complexity = O(bd ) 4. Space complexity = O(b*d) Only way this is better than BFS is the space complexity… DFS by itself is not great, but it has two (very) useful modifications a. Depth limited search It runs normal DFS, but if it is at a specified depth limit, you cannot have children (i.e. take another action) However, if you pick the depth limit before d, you will not find a solution (not correct, but will terminate) b. iterative deepening DFSThis search performs depth limited search with maximum depth 1, then maximum depth 2, then 3… until it finds a solution The first few states do get re-checked multiple times in IDS, however it is not too many When you find the solution at depth d, depth 1 is expanded d times (at most b of them) The second depth are expanded d-1 times (at most b2 of them) Thus upload successful Metrics: 1. Complete 2. Non-optimal (unless uniform cost) 3. O(bd ) 4. O(b*d) Thus IDS is better in every way than BFS (asymptotically) Best uninformed we will talk about","categories":[{"name":"AI","slug":"AI","permalink":"http://yoursite.com/categories/AI/"}],"tags":[{"name":"Search","slug":"Search","permalink":"http://yoursite.com/tags/Search/"}],"author":"isFibonacci"},{"title":"Greedy Algorithm (1)","slug":"greedy algorithm (1)","date":"2020-02-06T01:55:00.000Z","updated":"2020-02-14T04:16:06.928Z","comments":true,"path":"2020/02/05/greedy algorithm (1)/","link":"","permalink":"http://yoursite.com/2020/02/05/greedy%20algorithm%20(1)/","excerpt":"","text":"860. Lemonade Change1234567Input: [5,5,5,10,20]Output: trueExplanation: From the first 3 customers, we collect three $5 bills in order.From the fourth customer, we collect a $10 bill and give back a $5.From the fifth customer, we give a $10 bill and a $5 bill.Since all customers got correct change, we output true. 123451. Every time we choose the largest one to exchange, like 20 -&gt; 10 + 52. if use 10 to exchange 5 we will have 10, so ten +&#x3D; 13. for 20 case, we cannot just return false if there is not 10, since we can use 5+5+5 to exchange4. make sure temp &#x3D;&#x3D; 0t to quit, otherwise we will have negative temp 123456789101112131415161718192021222324252627282930313233class Solution: def lemonadeChange(self, bills: List[int]) -&gt; bool: five, ten = 0, 0 for cur in bills : if cur == 5 : five += 1 if cur == 10 : #need 5 if five : five -= 1 #exchange to ten, so ten +1 ten += 1 else : return False if cur == 20 : #need 15 temp = 15 if ten : ten -= 1 temp -= 10 #cannot return false, bc we can return 5+5+5 while five and temp: #make sure when temp = 0 quit, or it will loop to negative five -= 1 temp -= 5 if temp : return False return True 392. Is Subsequence123456789Example 1:s &#x3D; &quot;abc&quot;, t &#x3D; &quot;ahbgdc&quot;Return true.Example 2:s &#x3D; &quot;axc&quot;, t &#x3D; &quot;ahbgdc&quot;Return false. 11. Two pointers, make suer k lease than len(s) 123456789class Solution: def isSubsequence(self, s: str, t: str) -&gt; bool: i, k = 0, 0 while i &lt; len(t) and k &lt; len(s) : if s[k] == t[i] : k += 1 i += 1 return k == len(s) 455. Assign Cookies12345678Input: [1,2,3], [1,1]Output: 1Explanation: You have 3 children and 2 cookies. The greed factors of 3 children are 1, 2, 3. And even though you have 2 cookies, since their size is both 1, you could only make the child whose greed factor is 1 content.You need to output 1. 1234567891011121314151617181920class Solution: def findContentChildren(self, g: List[int], s: List[int]) -&gt; int: #who come first, give the cookies to him g = sorted(g) s = sorted(s) res, j = 0, 0 for i in range (len(g)) : #not satisified while j &lt; len(s) and s[j] &lt; g[i] : j += 1 #satisified if j &lt; len(s) : res += 1 #make sure j += 1, bc have used j += 1 return res 55. Jump Game1234Input: [3,2,1,0,4]Output: falseExplanation: You will always arrive at index 3 no matter what. Its maximum jump length is 0, which makes it impossible to reach the last index. 12345678910111213141516class Solution: def canJump(self, nums: List[int]) -&gt; bool: n = len(nums) if n == 0 : return True i, maxDist = 0, 0 #maxDist : the maximum position you can arrive so far while i &lt; n and i &lt;= maxDist : # if i &gt; maxDist, we cannnot get i position maxDist = max(i + nums[i], maxDist) i += 1 # [3, 1, 2, 0] -&gt; i = 0, maxDist = 3, we can arrive i = 3 maximum; # i = 2, maxDist = 2 + 2 = 4, arrive i = 4 maximum return maxDist &gt;= n-1 #not maxDist &gt;= i, bc after loop i+= 1 &gt; n-1 45. Jump Game II1234Input: [2,3,1,1,4]Output: 2Explanation: The minimum number of jumps to reach the last index is 2. Jump 1 step from index 0 to 1, then 3 steps to the last index. At i = 0, if choose jump 2 -&gt; i = 2, we can only jump 1 -&gt; i = 3we can only jump 1 -&gt; i = 4so total is 3 At i = 0, if choose jump 1 -&gt; i = 1, we can jump 3 -&gt; i = 4so total is 4 12345678910111213141516Proof : f[i] &gt; f[i+1] is wrongf[i] : the minimum steps to arrive if[i+1] : the minimum steps to arrive i+1we prove f[i] &lt;&#x3D; f[i+1] is correctAssume at j, we need to arrive at i+1. j+nums[j] &gt;&#x3D; i+1[2, 3, 1, 1, 4]j &#x3D; 0, i+1 &#x3D; 1j+nums[j] &#x3D; 0+2, we can arrive position at 2 maximumAssume we at j, and want to arrive at i+1, we need to jump plus 1f[i+1] &#x3D; f[j] + 1we can also arrive at i by f[j] + 1 steps at leastso f[i] &#x3D; f[j] + 1Hence, f[i] &lt;&#x3D; f[i+1] 123456789101112131415161718192021222324class Solution: def jump(self, nums: List[int]) -&gt; int: n = len(nums) if n == 0 or n == 1: return 0 l, r, step = 0, 0, 0 while l &lt;= r : # we check at each postion we can jump how far maxDist = 0 for i in range(l, r+1) : # want to check l == r, l &lt;= r so r+1 # maxDist : at i position, how far we can jump maxDist = max(i+nums[i], maxDist) l = r+1 # can arrive at r at least r = maxDist step += 1 if r &gt;= n-1 : break return step","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/categories/leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/tags/leetcode/"},{"name":"greedy algorithm","slug":"greedy-algorithm","permalink":"http://yoursite.com/tags/greedy-algorithm/"},{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}],"author":"isFibonacci"},{"title":"Inheritance and Polymorphism in C++ (1)","slug":"Inheritance and Polymorphism in C++ (1)","date":"2020-02-05T22:56:00.000Z","updated":"2020-02-14T04:16:27.498Z","comments":true,"path":"2020/02/05/Inheritance and Polymorphism in C++ (1)/","link":"","permalink":"http://yoursite.com/2020/02/05/Inheritance%20and%20Polymorphism%20in%20C++%20(1)/","excerpt":"","text":"Access by members of derived classesThe members of a derived class have access to the public members of the base class, but not to the private members of the base class. 1234567891011121314151617181920212223class Business &#123; public: ... private: string name; string address;&#125;;class Restaurant : public Business &#123; public: ... void DisplayRestaurant() &#123; cout &lt;&lt; name &lt;&lt; endl; cout &lt;&lt; address &lt;&lt; endl; cout &lt;&lt; \" Rating: \" &lt;&lt; rating &lt;&lt; endl; &#125; private: int rating;&#125;; Solution :A third access specifier is protected, which provides access to derived classes but not by anyone else. But! Careful here : A third access specifier is protected, which provides access to derived classes but not by anyone else. 1234567891011121314151617181920212223242526272829303132333435363738394041class Business &#123; public: // Members accessible by anyone void PrintMembers(); protected: // Members accessible by self and derived classes string name; private: // Members accessible only by self string address;&#125;;class Restaurant : public Business &#123; ... // Attempted accesses PrintMembers(); // OK name = \"Gyro Hero\"; // OK (\"protected\" above made this possible) address = \"5 Fifth St\"; // ERROR ...&#125;;int main() &#123; ... Business business; Restaurant restaurant; ... // Attempted accesses business.PrintMembers(); // OK business.name = \"Gyro Hero\"; // ERROR (protected only applies to derived classes) business.address = \"5 Fifth St\"; // ERROR restaurant.PrintMembers(); // OK restaurant.name = \"Gyro Hero\"; // ERROR restaurant.rating = 5; // ERROR return 0;&#125;","categories":[{"name":"Program Language","slug":"Program-Language","permalink":"http://yoursite.com/categories/Program-Language/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"}],"author":"isFibonacci"},{"title":"并查集","slug":"title: 并查集","date":"2020-02-01T23:55:00.000Z","updated":"2020-02-22T21:47:01.001Z","comments":true,"path":"2020/02/01/title: 并查集/","link":"","permalink":"http://yoursite.com/2020/02/01/title:%20%E5%B9%B6%E6%9F%A5%E9%9B%86/","excerpt":"","text":"【Disjoint-set】1234567891011操作 ： 1. 将两个集合合并2. 询问两个元素是否在一个集合中基本原理 ： 将每个集合用一颗树来表示。树根的编号就是整个集合的编号。每个节点存储它的父节点， p[x]表示x的父节点问题 ： 1. 如何判断树根： if(p[x] &#x3D;&#x3D; x)2. 如何求x的集合编号： while (p[x] !&#x3D; x) x &#x3D; p[x];3. 如何合并两个集合： px 是 x 的集合编号， py 是 y的集合编号。p[x] &#x3D; y 836. 合并集合12345678910111213141516171819202122232425262728293031const int N = 100010;int n, m;int p[N];// return x's ancestor (path compress)int find(int x) &#123; if (p[x] != x) // find it's ancestor p[x] = find(p[x]); // update x's father is it's father's ancestor return p[x];&#125;int main() &#123; scanf(\"%d%d\", &amp;n, &amp;m); // make initial for (int i = 1; i &lt;= n; i++) p[i] = i; while (m--) &#123; char op[2]; int a, b; scanf(\"%s%d%d\", op, &amp;a, &amp;b); // find a reutrn a's ancestor, find b return b's ... // let a's ancestor's father become b'ancestor if (op[0] == 'M') p[find(a)] = find(b); else &#123; if (find(a) == find(b)) puts(\"Yes\"); else puts(\"No\"); &#125; &#125; return 0;&#125; 547. Friend Circles123456789101112131415Input: [[1,1,0], [1,1,0], [0,0,1]]Output: 2Explanation:The 0th and 1st students are direct friends, so they are in a friend circle. The 2nd student himself is in a friend circle. So return 2.Input: [[1,1,0], [1,1,1], [0,1,1]]Output: 1Explanation:The 0th and 1st students are direct friends, the 1st and 2nd students are direct friends, so the 0th and 2nd students are indirect friends. All of them are in the same friend circle, so return 1. 121. each person as a set2. if p[i] !&#x3D; i, that means there is a circle 1234567891011121314151617181920212223242526272829303132class Solution &#123;public: vector&lt;int&gt; p; int find(int x) &#123; if (p[x] != x) p[x] = find(p[x]); return p[x]; &#125; int findCircleNum(vector&lt;vector&lt;int&gt;&gt;&amp; M) &#123; int n = M[0].size(); for (int i = 0; i &lt; n; i++) p.push_back(i); // let each person as a set int res = n; for (int i = 0; i &lt; n; i++) &#123; // only need to check one half // has checked 0th and 1th, don't need to check 1th and 0th // and don't need to check ourself for (int j = 0; j &lt; i; j++) &#123; if (M[i][j] == 0) continue; // if ith don't belong to i // i = 0, find(0) = 1 if (find(i) != find(j)) &#123; p[find(i)] = find(j); res --; // combine 0 and 1, so the number of sets --; &#125; &#125; &#125; return res; &#125;&#125;; 684. Redundant Connection1234567891011121314Example 1:Input: [[1,2], [1,3], [2,3]]Output: [2,3]Explanation: The given undirected graph will be like this: 1 &#x2F; \\2 - 3Example 2:Input: [[1,2], [2,3], [3,4], [1,4], [1,5]]Output: [1,4]Explanation: The given undirected graph will be like this:5 - 1 - 2 | | 4 - 3 1231. add each edge into a set, if two edge has the same ancestorthat means we find a aboundant, otherwise we update the ancestor with current edge 1234567891011121314151617181920212223class Solution &#123;public: vector&lt;int&gt; p; int find(int x) &#123; if (p[x] != x) return p[x] = find(p[x]); return p[x]; &#125; vector&lt;int&gt; findRedundantConnection(vector&lt;vector&lt;int&gt;&gt;&amp; edges) &#123; for (int i = 0 ; i &lt;= edges.size(); i++) p.push_back(i); for (auto e : edges) &#123; int a = e[0], b = e[1]; // [3,4], [1,4], // find(3) = 3, find(4) = 3, find(1) = 3 -&gt; return &#123;1, 4&#125; if (find(a) == find(b)) return &#123;a, b&#125;; p[find(a)] = find(b); &#125; return &#123;-1, -1&#125;; &#125;&#125;;","categories":[{"name":"yxcNb","slug":"yxcNb","permalink":"http://yoursite.com/categories/yxcNb/"}],"tags":[{"name":"-Data Structure","slug":"Data-Structure","permalink":"http://yoursite.com/tags/Data-Structure/"}],"author":"isFibonacci"},{"title":"Heap","slug":"title: Heap","date":"2020-02-01T23:55:00.000Z","updated":"2020-02-23T15:39:07.941Z","comments":true,"path":"2020/02/01/title: Heap/","link":"","permalink":"http://yoursite.com/2020/02/01/title:%20Heap/","excerpt":"","text":"AcWing 838. 堆排序123451. Insert : hedp[++size] &#x3D; x; up(size) O(logn)2. Min : heap[1]3. Delete min : heap[1] &#x3D; heap[size]; size--; down(1);4. Delete any : heap[k] &#x3D; heap[size]; size--; down(k); up(k);5. heap[k] &#x3D; x; down(k); up(k); 12345678910111213141516171819202122232425262728const int N = 100010;int n, m;int h[N], size;void down(int root) &#123; int min = root; if (root*2 &lt;= size &amp;&amp; h[root*2] &lt; h[min]) min = root*2; // left if (root*2 + 1 &lt;= size &amp;&amp; h[root*2+1] &lt; h[min]) min = root*2 + 1; //right if (root != min) &#123; swap(h[root], h[min]); down(min); &#125;&#125;int main() &#123; scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 0; i &lt;= n; i++) scanf(\"%d\", &amp;h[i]); size = n; for (int i = n / 2; i; i--) down(i); while (m--) &#123; printf(\"%d\", h[1]); h[1] = h[size]; size--; down(1); &#125;&#125; 839. 模拟堆12345678void heap_swap(itn a, int b) &#123; // heap pointer : index map to element // pointer heap : map index // ph[j] = k, hp[k] = j -&gt; ph[hp[k]] swap(ph[hp[a]], ph[hp[b]]); swap(hp[a], hp[b]); //index swap(h[a], h[b]);&#125; 692. Top K Frequent Words12345678910Example 1:Input: [&quot;i&quot;, &quot;love&quot;, &quot;leetcode&quot;, &quot;i&quot;, &quot;love&quot;, &quot;coding&quot;], k &#x3D; 2Output: [&quot;i&quot;, &quot;love&quot;]Explanation: &quot;i&quot; and &quot;love&quot; are the two most frequent words. Note that &quot;i&quot; comes before &quot;love&quot; due to a lower alphabetical order.Example 2:Input: [&quot;the&quot;, &quot;day&quot;, &quot;is&quot;, &quot;sunny&quot;, &quot;the&quot;, &quot;the&quot;, &quot;the&quot;, &quot;sunny&quot;, &quot;is&quot;, &quot;is&quot;], k &#x3D; 4Output: [&quot;the&quot;, &quot;is&quot;, &quot;sunny&quot;, &quot;day&quot;]Explanation: &quot;the&quot;, &quot;is&quot;, &quot;sunny&quot; and &quot;day&quot; are the four most frequent words, with the number of occurrence being 4, 3, 2 and 1 respectively. 1234561. Priority queue is max-heap, -item.second -&gt; min-heap bc pop the top, will remove the most frequency, but we want the most frequency2. if the heap is full, pop out the worest.3. WARNING : priority queue. if the frequency is the same, choose the bigger alphabet but we want lower alphabetical order comes first. 123456789101112131415161718192021222324252627vector&lt;string&gt; topKFrequent(vector&lt;string&gt;&amp; words, int k) &#123; unordered_map&lt;string, int&gt; hash; //&lt;frequency, string&gt; typedef pair&lt;int, string&gt; obj; // same above, for push into heap priority_queue&lt;obj&gt; heap; for (auto word : words) hash[word]++; for (auto item : hash) &#123; // make pair, -frequency is the lowest in the max-heap obj temp(-item.second, item.first); heap.push(temp); // if full, pop if (heap.size() &gt; k) heap.pop(); &#125; // 3. add to res vector&lt;string&gt; res(k); // -frequency is the max, top is the min, so reverse for (int i = k-1 ; i &gt;= 0; i--) &#123; res[i] = heap.top().second; heap.pop(); &#125; return res;&#125; 295. Find Median from Data Stream123456Median is the middle value in an ordered integer list. If the size of the list is even, there is no middle value. So the median is the mean of the two middle value.For example,[2,3,4], the median is 3[2,3], the median is (2 + 3) &#x2F; 2 &#x3D; 2.5 12345678up : min-heap, down : max-heap;if x &gt;&#x3D; down.top(), insert up, if x &lt; down.top(), insert down 7 8 \\ &#x2F; 6 5 &#x2F; \\ 3 4 123456789101112131415161718192021222324252627282930class MedianFinder &#123;public: /** initialize your data structure here. */ priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; up; //min- priority_queue&lt;int&gt; down; // max-heap MedianFinder() &#123; &#125; void addNum(int num) &#123; if (down.empty() || num &gt;= down.top()) up.push(num); else &#123; // every time also add to up, so we only need to maintiain one side down.push(num); up.push(down.top()); down.pop(); &#125; if (up.size() &gt; down.size()+1) &#123; down.push(up.top()); up.pop(); &#125; &#125; double findMedian() &#123; // odd if (down.size() + up.size() &amp; 1) return up.top(); else return ( down.top() + up.top()) / 2.0; &#125;&#125;; 352. Data Stream as Disjoint Intervals123456789Given a data stream input of non-negative integers a1, a2, ..., an, ..., summarize the numbers seen so far as a list of disjoint intervals.For example, suppose the integers from the data stream are 1, 3, 7, 2, 6, ..., then the summary will be:[1, 1][1, 1], [3, 3][1, 1], [3, 3], [7, 7][1, 3], [7, 7][1, 3], [6, 7] 1234567891011121314151617181920212223242526272829303132333435363738394041class SummaryRanges &#123;public: /** Initialize your data structure here. */ map&lt;int, int&gt; L, R; SummaryRanges() &#123; &#125; void addNum(int x) &#123; if (L.size()) &#123; auto it = L.lower_bound(x); if (it != L.end() &amp;&amp; it -&gt;second &lt;= x) return; // x 已经在某个区间 &#125; int left = L.count(x-1), right = R.count(x+1); if (left &amp;&amp; right) &#123; R[L[x-1]] = R[x+1]; L[R[x+1]] = L[x-1]; L.erase(x-1), R.erase(x+1); &#125; else if (left) &#123; R[L[x-1]] = x; L[x] = L[x-1]; L.erase(x-1); &#125; else if (right) &#123; L[R[x + 1]] = x; R[x] = R[x + 1]; R.erase(x + 1); &#125; else &#123; R[x] = L[x] = x; &#125; &#125; vector&lt;vector&lt;int&gt;&gt; getIntervals() &#123; vector&lt;vector&lt;int&gt;&gt; res; for(auto item : R) res.push_back(&#123;item.first, item.second&#125;); return res; &#125;&#125;;","categories":[{"name":"yxcNb","slug":"yxcNb","permalink":"http://yoursite.com/categories/yxcNb/"}],"tags":[{"name":"Data Structure","slug":"Data-Structure","permalink":"http://yoursite.com/tags/Data-Structure/"}],"author":"isFibonacci"},{"title":"Informed search","slug":"Informed-search","date":"2020-01-17T22:18:00.000Z","updated":"2020-02-14T04:16:18.442Z","comments":true,"path":"2020/01/17/Informed-search/","link":"","permalink":"http://yoursite.com/2020/01/17/Informed-search/","excerpt":"","text":"In uninformed search, we only had the nodeinformation (parent, children, cost of actions) Now we will assume there is some additionalinformation, we will call a heuristic thatestimates the distance to the goal Previously, we had no idea how close we wereto goal, simply how far we had gone already 1. Greedy best-first searchThis search will simply repeatedly select thechild with the lowest heuristic(cost to goal est.) In fact, it is not guaranteed to converge (if apath reaches a dead-end, it will loop infinitely) 2. A* (a star) upload successful Priority queues can be used to efficiently storeand insert states and their f-values into the fringe Good heuristics can remove “bad” sections of the search space that will not be on any optimal solution (called pruning) A* is optimal and in fact, no optimal algorithm could expand less nodes (optimally efficient) However, the time and memory cost is still exponential (memory tighter constraint) 2.1 Iterative deepening A* Run DFS in IDS, but instead of using depthas cutoff, use f-cost If search fails to find goal, increase f-costto next smallest seen value (above old cost) Pros: Efficient on memory Cons: Large (LARGE) amount of re-searching","categories":[{"name":"AI","slug":"AI","permalink":"http://yoursite.com/categories/AI/"}],"tags":[],"author":"isFibonacci"},{"title":"Comparison of Greedy Search Algorithms","slug":"Comparison of Greedy Search Algo","date":"2020-01-10T22:18:00.000Z","updated":"2020-02-14T04:15:52.496Z","comments":true,"path":"2020/01/10/Comparison of Greedy Search Algo/","link":"","permalink":"http://yoursite.com/2020/01/10/Comparison%20of%20Greedy%20Search%20Algo/","excerpt":"","text":"best-first searches: weighted A*, greedy search, A∗ǫ , window A* multi-state commitment k-weighted A*. hill climbing algorithms : hill climb- ing LSS-LRTA* beam searches : BULB beam-stack search pathfinding in grids (Thayer, Ruml, and Bitton 2008), the traveling salesman problem (Pearl and Kim 1982), dynamic robot pathfinding (Likhachev, Gordon, and Thrun 2003), the sliding tile puzzle (Korf 1985), the pancake puzzle (Holte, Grajkowskic, and Tanner 2005), and a vacuum-robot domain (Russell and Norvig 2010).","categories":[{"name":"AI","slug":"AI","permalink":"http://yoursite.com/categories/AI/"}],"tags":[],"author":"isFibonacci"},{"title":"Some thoughts on AI","slug":"Some-thoughts-about-AI","date":"2020-01-06T03:45:00.000Z","updated":"2020-02-14T04:15:26.160Z","comments":true,"path":"2020/01/05/Some-thoughts-about-AI/","link":"","permalink":"http://yoursite.com/2020/01/05/Some-thoughts-about-AI/","excerpt":"","text":"Recently, there has been a lot of concerns about AI(artificial intelligence), like AI will make people lose jobs and the tech oligarch will make wealth inequality; in brief, AI will raise abundant social issues over than its advantage to society. On the contrary, some people argues that AI will bring abundant jobs instead. Like in the past, some people concerned that industrial revolution will take away people’s jobs but we know this revolution promote society development and then bring many opening jobs. However, I still believe there are many reasons to be concerned about advances of AI. As the automation is developing, we can see in the near future; millions of people will be replaced by the machines. The reasons I concerned are that there are many advantages in automation over than humans. First, machines will never feel tired. Mentioned in this article, I believe ”the self-driving trucks promised by Tesla’s Elon Musk become widely available in the next decade.” (Bossmann, 2016). Human drivers need to take a break after long driving, but self-driving trucks not. Self-driving car can keep long driving during the midnight to avoid rush hours in the daytime, and self-driving car has a lower risk of accidents than humans after long driving. Absolutely, transportation company will hire robots to drive rather than humans in obvious these advances. Hence, we can see in the near future; AI will take away many people’s jobs, and the unemployment rate will be increasing rapidly. What if AI turn to hurt humans? Hollywood movies have presented many AI disasters for us. And in this article, the author mentioned a vivid example: in order to kill the cancer, the machine kills everyone on the planet instead, which is more efficient. (Bossmann, 2016). As we know, the real world is really complicated. It is hard to just use some if-else statements to cover all the cases, like we are hard to predicate the future. So, in more specific, how can we ensure that the robot will not hurt human in a complicate case like rescue hostages? How can we ensure human will still dominate the world if one day we totally lose the ingenuity and intelligence than AI? As one day AI can evolve them very efficiently by iteration? How can we protect ourselves if robots start to attack people? How can we ensure we can still dominate the world, not AI dominate us? Or AI can just create a pandemic breaks out the world, which is the most efficient way to kill all the organism on this planet. Or like the movie, The Matrix, people are imprisoned in a container as a energy source? Obviously, there are still many issues that AI will bring to us. So I believe govern- ments, industries, and academics should take some steps to address these issues. First, since the automation take place of many people’s job, the unemployment rate will be in- creasing. Government should make some effectual policy to against unemployment. For example, Andrew Yang proposes government to pay one thousand dollars each month to every American over the age of 18. This money is from company’s VAT(A Value-Added Tax), and then people use the money to consumer company’s product. (Yang, 2020). This is a double win. No need to say, there are still a lot of issues that AI will bring to us in the future, but government should take its strong right to control these issues. Second, industries and academics should make some principles or agreement during the AI development. Like The Institute for Ethical ML, this academic institute make 8 principles when designing and developing AI and ML.(for Ethical AI ML, 2020). In that 8 principles, the developer commit to assess and handle the impact of incorrect result. So I believe the developers can take a great effort to avoid accident due to AI, and even when the accident happens, they can reduce losses. In brief, We have reasons to be concerned about advances of AI.And there are still many steps to address these issues, but the only principle we need to make sure is, artificial intelligence is conducive to improving the efficiency of social work and promoting social development. References J. Bossmann. Top 9 ethical issues in artificial intelligence. 2016. URL https://www.weforum.org/agenda/2016/10/top-10-ethical-issues -in-artificial-intelligence.I. for Ethical AI ML. The 7 Most Pressing Ethical Issues in Artificial Intelligence. 2020. URL https://ethical.institute/principles.html.A. Yang. VALUE-ADDED TAX. 2020. URL https://www.yang2020.com/policies/value-added-tax/.","categories":[{"name":"AI","slug":"AI","permalink":"http://yoursite.com/categories/AI/"}],"tags":[],"author":"isFibonacci"},{"title":"Build your own blog","slug":"hello-world","date":"2020-01-01T15:22:00.000Z","updated":"2020-02-14T15:52:44.720Z","comments":true,"path":"2020/01/01/hello-world/","link":"","permalink":"http://yoursite.com/2020/01/01/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment Change ThemeThe theme I used in this blog is cited from yscoder 1.git clone -&gt; after all install -&gt; move theme to your hexo theme and 12hexo ghexo d Careful here, if in the _config.yml you set it as 123deploy: type: git branch: master The hexo d will delete your custom domin name!What should do is here","categories":[],"tags":[],"author":"isFibonacci"}]}