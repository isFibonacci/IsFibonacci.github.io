{"meta":{"title":"Hi There","subtitle":"If people do not believe that mathematics is simple, it is only because they do not realize how complicated life is. – John von Neumann.","description":"Computer Sicence | University of Minnesota, twin cities","author":"isFibonacci","url":"http://yoursite.com","root":"/"},"pages":[{"title":"","date":"2020-02-09T23:48:28.829Z","updated":"2020-02-09T23:48:28.829Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"","date":"2020-02-09T23:48:36.379Z","updated":"2020-02-09T23:48:36.379Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"Oops | 404","date":"2020-02-12T02:33:34.647Z","updated":"2020-02-12T02:33:34.647Z","comments":true,"path":"404.html","permalink":"http://yoursite.com/404.html","excerpt":"","text":""}],"posts":[{"title":"Facebook 面试题","slug":"Facebook 面试题","date":"2020-03-15T22:55:00.000Z","updated":"2020-03-16T05:01:29.361Z","comments":true,"path":"2020/03/15/Facebook 面试题/","link":"","permalink":"http://yoursite.com/2020/03/15/Facebook%20%E9%9D%A2%E8%AF%95%E9%A2%98/","excerpt":"","text":"278. First Bad Version123456789101112131415// Forward declaration of isBadVersion API.bool isBadVersion(int version);class Solution &#123;public: int firstBadVersion(int n) &#123; int l = 1, mid = 1, r = n; while (l &lt; r) &#123; mid = (l + 0ll + r) / 2; if (isBadVersion(mid)) r = mid; else l = mid + 1; &#125; return r; &#125;&#125;; 238. Product of Array Except Self123456789101112131415161718192021222324252627282930class Solution &#123;public: vector&lt;int&gt; productExceptSelf(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); vector&lt;int&gt; output(n, 1); // 0*1*2* i-1... for (int i = 1; i &lt; n; i++) &#123; output[i] = output[i-1] * nums[i-1]; &#125; int end = 1; // n-1 .. i + 1 for (int i = n - 1; i &gt;= 0; i--) &#123; output[i] *= end; end *= nums[i]; &#125; return output; &#125;&#125;;/*output[i] = 0 * 1 * ... i -1 * i + 1 * (i+2) ...* n -1[2,3,1,4]i : 3output[0] = 1 * 12 = 12, end = 24output[1] = output[0] * nums[0] = 2, 2 * 4 = 8, end = 12output[2] = output[1] * nums[1] = 6, 6 * 4 = 24, end = 4output[3] = output[2] * nums[2] = 6, 6 * 1 = 6, end = 4output[4] = output[3] * nums[3] = 24, 6 * 1 = 1, end = 4*/ 133. Clone Graph1234567891011121314151617181920212223242526class Solution &#123;public: unordered_map&lt;Node*, Node*&gt; hash; Node* cloneGraph(Node* node) &#123; if (!node) return node; auto p = new Node(node-&gt;val); hash[node] = p; dfs(node); return p; &#125; void dfs(Node* node) &#123; for (auto ver : node-&gt;neighbors) &#123; if (!hash.count(ver)) &#123; hash[ver] = new Node(ver-&gt;val); dfs(ver); &#125; hash[node]-&gt;neighbors.push_back(hash[ver]); &#125; &#125;&#125;;/*1. copy each point into hash map2. traverse each vertics, between each point, build new vertics*/","categories":[{"name":"yxcNb","slug":"yxcNb","permalink":"http://yoursite.com/categories/yxcNb/"}],"tags":[{"name":"-Data Structure","slug":"Data-Structure","permalink":"http://yoursite.com/tags/Data-Structure/"}],"author":"isFibonacci"},{"title":"模拟专题（0）","slug":"模拟专题 (0)","date":"2020-03-13T22:55:00.000Z","updated":"2020-03-15T21:50:52.304Z","comments":true,"path":"2020/03/13/模拟专题 (0)/","link":"","permalink":"http://yoursite.com/2020/03/13/%E6%A8%A1%E6%8B%9F%E4%B8%93%E9%A2%98%20(0)/","excerpt":"","text":"263. Ugly Number123456789bool isUgly(int num) &#123; int d[] = &#123;2, 3, 5&#125;; for (auto prime : d) &#123; while (num &gt; 0 &amp;&amp; num % prime == 0) &#123; num /= prime; &#125; &#125; return num == 1;&#125; 67. Add Binary1234567891011121314151617181920212223string addBinary(string a, string b) &#123;reverse(a.begin(), a.end());reverse(b.begin(), b.end());int t = 0; // 进位string ans;for (int i = 0; i &lt; a.size() || i &lt; b.size(); i++) &#123; int va = i &gt;= a.size() ? 0 : a[i] - '0'; int vb = i &gt;= b.size() ? 0 : b[i] - '0'; int s = va + vb + t; // 1 + 1 + 1 t = s / 2, s %= 2; // 3 / 2 = 1, ans += to_string(s);&#125;if (t) ans += '1';return string(ans.rbegin(), ans.rend()); // string reverse&#125;/*a : 1011 b : 100 -&gt; 1111 | a : 11, b : 11101 001 -&gt; 1111 | 11 1 -&gt; 100s : 1 1 1 1 2 2(1+t)t : 0 0 0 0 (3/2 = 1) 1 1res : 1 1 1 1 0 0 -&gt; if(t) 001 -&gt; 100*/ 504. Base 712345678910111213141516171819string convertToBase7(int num) &#123; string ans; bool isNegative = false; if (num &lt; 0) num *= -1, isNegative = true; // convert negative to positive else if (!num) ans = '0'; while (num) &#123; ans += to_string(num % 7); num /= 7; &#125; if (isNegative) ans += '-'; return string(ans.rbegin(), ans.rend());&#125;/*123 123 % 10 -&gt; 312 % 10 -&gt; 21 % 10 -&gt; 1reverse(321) -&gt; 123 */ 54. Spiral Matrix123456789101112131415161718192021222324252627vector&lt;int&gt; spiralOrder(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123; vector&lt;int&gt; ans; if (matrix.empty()) return ans; int n = matrix.size(), m = matrix[0].size(); // recored used or not vector&lt;vector&lt;bool&gt;&gt; st(n, vector&lt;bool&gt;(m, false)); int dx[4] = &#123;-1, 0, 1, 0&#125;, dy[4] = &#123;0, 1, 0, -1&#125;; int x = 0, y = 0, d = 1; for (int k = 0; k &lt; n*m; k++) &#123; ans.push_back(matrix[x][y]); st[x][y] = true; int newX = x + dx[d], newY = y + dy[d]; if (newX &lt; 0 || newX &gt;=n || newY &lt; 0 || newY &gt;= m || st[newX][newY]) &#123; d = (d+1) % 4; // turn around newX = x + dx[d], newY = y + dy[d]; &#125; x = newX, y = newY; &#125; return ans;&#125;&#125;;/*d : 1 2 3 0 dx : 0 1 0 -1dy : 1 0 -1 0*/ 299. Bulls and Cows1234567891011121314151617181920string getHint(string secret, string guess) &#123; int a = 0, b = 0, n = guess.size(); int da[10] = &#123;0&#125;, db[10] = &#123;0&#125;; // record a, b = min same subsequence len - the same num in the same location for (int i = 0; i &lt; n; i++) &#123; int x = secret[i] - '0', y = guess[i] - '0'; if (x == y) a++; // same num in same location da[x]++, db[y]++; // record each num frequency &#125; // calculate b for (int i = 0; i &lt; 10; i++) b += min(da[i], db[i]); b -= a; // same num in diff location, if not equal, will be 0 return to_string(a) + 'A' + to_string(b) + 'B';&#125;/*1123 0145 da[1:2] db[0:1, ] a = 1 b = 1 - 1 = 01, 0 : */ 481. Magical String12345678910111213141516int magicalString(int n) &#123; string s = \"122\"; for (int i = 2, k = 1; i &lt; n; i++, k = 3 -k) &#123; // k is 1 or 2 for (int j = 0; j &lt; s[i] - '0'; j++) s += to_string(k); &#125; int ans = 0; for (int i = 0; i &lt; n; i++) ans += s[i] == '1'; return ans;&#125;/*i = 6s[2] = 2, s = 12211s[3] = 1 s = 122112s[4] = 1 s = 1221122s[5] = 2 s = 122112211*/ 71. Simplify Path1234567891011121314151617181920212223242526272829class Solution &#123;public: string simplifyPath(string path) &#123; path += '/'; // if not: /a/..\" -&gt; \"/a\" string ans, temp; for (auto c : path) &#123; if (ans.empty()) ans += c; // '/' else if (c != '/') temp += c; else &#123; // c == '/' if (temp == \"..\") &#123; if (ans.size() &gt; 1) &#123; // if == 1 -&gt; '/' // return to up level, clean the ans ans.pop_back(); // /a/../ -&gt; / while (ans.back() != '/') ans.pop_back(); &#125; // if temp == \"\" will not add into new path, \"/home//foo/\" &#125; else if (temp != \"\" &amp;&amp; temp != \".\") ans += temp + '/'; // new path temp = \"\"; // clean temp &#125; &#125; if (ans.size() &gt; 1) ans.pop_back(); return ans; &#125;&#125;;/*c : /a/.. ans : /a/ -&gt; pop_back, /a, so if have /, -&gt; /temp : ..*/ 12. Integer to Roman123456789101112131415161718192021class Solution &#123;public: string intToRoman(int num) &#123; int value[] = &#123;1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1&#125;; string reps[] = &#123;\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"&#125;; string ans; for (int i = 0; i &lt; 13; i++) &#123; while (num &gt;= value[i]) &#123; num -= value[i]; ans += reps[i]; &#125; &#125; return ans; &#125;&#125;;/*287CC, 87CCLXXX 7CCLXXXVII*/ 68. Text Justification12345678910111213141516171819202122232425262728293031323334353637class Solution &#123;public: string spaces(int x) &#123; string res; while (x--) res += ' '; return res; &#125; vector&lt;string&gt; fullJustify(vector&lt;string&gt;&amp; words, int maxWidth) &#123; vector&lt;string&gt; ans; for (int i = 0; i &lt; words.size();) &#123; int j = i + 1, s = words[i].size(), rs = words[i].size(); while (j &lt; words.size() &amp;&amp; s + 1 + words[j].size() &lt;= maxWidth) &#123; s += words[j].size() + 1; rs += words[j].size(); j++; &#125; rs = maxWidth - rs; string line = words[i]; if (j == words.size()) &#123; for (int k = i + 1; k &lt; j; k++) line += ' ' + words[k]; line += spaces(maxWidth - line.size()); &#125; else if (j - i == 1) &#123; line += spaces(maxWidth - line.size()); &#125; else &#123; int base = rs / (j - i -1); int rem = rs % (j - i - 1); i ++; for (int k = 0; i &lt; j; i++, k++) &#123; line += spaces(base + (k &lt; rem)) + words[i]; &#125; &#125; i = j; ans.push_back(line); &#125; return ans; &#125;&#125;;","categories":[{"name":"yxcNb","slug":"yxcNb","permalink":"http://yoursite.com/categories/yxcNb/"}],"tags":[{"name":"-Data Structure","slug":"Data-Structure","permalink":"http://yoursite.com/tags/Data-Structure/"}],"author":"isFibonacci"},{"title":"Math（0）","slug":"Math（0)","date":"2020-03-11T22:55:00.000Z","updated":"2020-03-14T22:01:43.100Z","comments":true,"path":"2020/03/11/Math（0)/","link":"","permalink":"http://yoursite.com/2020/03/11/Math%EF%BC%880)/","excerpt":"","text":"268. Missing Number12345int missingNumber(vector&lt;int&gt;&amp; nums) &#123; int sum = 0; for (auto num : nums) sum += num; return nums.size() * (nums.size()+ 1) / 2 - sum; // (0+1+3)*3/2 = 6, 6 -4 = 2&#125; 62. Unique Paths1234567891011121314151617(0,0) -&gt; (m-1, n-1), each time choose move x, or y,so no matter what, we need m+n-2 stepsfirst choose m-1, then n -1total times: c(n+m-2, n-1) int uniquePaths(int m, int n) &#123; vector&lt;vector&lt;int&gt;&gt; dp(m, vector&lt;int&gt;(n, 0)); dp[0][0] = 1; for (int i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; if (i || j) &#123; if (i) dp[i][j] += dp[i-1][j]; if (j) dp[i][j] += dp[i][j-1]; &#125; &#125; &#125; return dp[m-1][n-1]; &#125; 462. Minimum Moves to Equal Array Elements II1234567891011121314// x0, x1, ... x(n-1)// [x0, x(n-1)], [x1, x(n-2)], [x2, x(n-3)]// if odd, choose the mid one, if even, each point between them is equal, so no matterint minMoves2(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); // find the mid, the left of mid is smaller, the right is greater // only rearrange, not sort nth_element(nums.begin(), nums.begin()+n /2, nums.end()); int mid = nums[n/2]; int sum = 0; for (auto num : nums) sum += abs(num - mid); // the distance of each point to the mid return sum;&#125; 458. Poor Pigs1234567int poorPigs(int buckets, int minutesToDie, int minutesToTest) &#123; int b = minutesToTest/minutesToDie + 1; // +1 to display not die int k = 0, n = 1; while (n &lt; buckets) k++, n *= b; return k;&#125; 319. Bulb Switcher123int bulbSwitch(int n) &#123; return sqrt(n); &#125; 343. Integer Break12345678int integerBreak(int n) &#123; if (n &lt;= 3) return 1 * (n-1); int ans = 1; if (n % 3 == 1) ans = 4, n -= 4; else if (n % 3 == 2) ans = 2, n-= 2; while (n) ans *= 3, n -= 3; return ans;&#125; 650. 2 Keys Keyboard123456789101112131415161718192021// // currently we have x A's// p = ij, i &gt;= 1, j &gt;= 1// x-&gt;ix-&gt;ijx, via i+j times operation// ij, i + j// (i-1)(j-1) &gt;= 1, ij - i - j &gt;= 0// ij &gt;= i + jint minSteps(int n) &#123; int ans = 0; for (int i = 2; n &gt; 1; i++) &#123; while (n % i == 0) &#123; ans += i; n /= i; &#125; &#125; return ans; // n = 4// i 2 // ans 2 4// n 2 1&#125; 829. Consecutive Numbers Sum123456789101112131415161718/*n = a + (a+1) + (a+2) + ...(a+b-1)(a+a+b-1)*b / 2 = n -&gt; a = (2n/b-(b-1)) / 2if meet :1.所有除法都可以整除2. a &gt; 01. b is 2 的 约数， 2 ｜ (2n / b - (b-1))2. 2n &gt; b(b-1)*/int consecutiveNumbersSum(int N) &#123; int ans = 0; for (int b = 1; b * (b-1) &lt; 2 * N; b++) &#123; if (2 * N % b == 0 &amp;&amp; (2 * N / b - (b-1)) % 2 == 0) ans ++; &#125; return ans;&#125; 891. Sum of Subsequence Widths123456789101112int mod = 1e9+7; int sumSubseqWidths(vector&lt;int&gt;&amp; A) &#123; sort(A.begin(), A.end()); long long ans = 0, p = 1, sum = 0; for (auto num : A) &#123; ans = (ans + num * (p-1) - sum) % mod; sum = (sum * 2 + num) % mod; p = p*2%mod; &#125; return (ans+mod) % mod;&#125;","categories":[{"name":"yxcNb","slug":"yxcNb","permalink":"http://yoursite.com/categories/yxcNb/"}],"tags":[{"name":"-Data Structure","slug":"Data-Structure","permalink":"http://yoursite.com/tags/Data-Structure/"}],"author":"isFibonacci"},{"title":"DFS （1）","slug":"DFS （1）","date":"2020-03-03T23:55:00.000Z","updated":"2020-03-06T19:04:45.135Z","comments":true,"path":"2020/03/03/DFS （1）/","link":"","permalink":"http://yoursite.com/2020/03/03/DFS%20%EF%BC%881%EF%BC%89/","excerpt":"","text":"90. Subsets II12345671, 2, 2, 2, 3, 31: 0, 12: 0, 1, 2, 33: 0, 1, 2result:&#123; [], [1], [2], [3], [1,2], [1,3]...[1,2,2,2,3,3]&#125; 12345678910111213141516171819202122232425262728vector&lt;vector&lt;int&gt;&gt; ans;vector&lt;int&gt; path;vector&lt;vector&lt;int&gt;&gt; subsetsWithDup(vector&lt;int&gt;&amp; nums) &#123; sort(nums.begin(), nums.end()); dfs(nums, 0); return ans;&#125;void dfs(vector&lt;int&gt; &amp; nums, int level) &#123; if (level == nums.size()) &#123; ans.push_back(path); return; &#125; // count number of current num int k = 0; while (level+ k &lt; nums.size() &amp;&amp; nums[level+k] == nums[level]) k++; // ??? for (int i = 0; i &lt;= k; i++) &#123; dfs(nums, level+k); // skip the duplicate num? path.push_back(nums[level]); &#125; // recover for (int i = 0; i &lt;= k; i++) path.pop_back();&#125; 216. Combination Sum III12345678910111213Input: k &#x3D; 3, n &#x3D; 7Output: [[1,2,4]]Input: k &#x3D; 3, n &#x3D; 9Output: [[1,2,6], [1,3,5], [2,3,4]]n &#x3D; 3 : [1, 1,1][2,2,2,]...[9,9,9]dfs(枚举到的第几个数字，开始枚举的位置，当前选择的所有数的和)i~9 起码有k个数，9 - i + 1 &gt;&#x3D; k &#x3D;&gt; 10 - k &gt;&#x3D; i; 1234567891011121314151617181920212223vector&lt;vector&lt;int&gt;&gt; ans;vector&lt;int&gt; path;vector&lt;vector&lt;int&gt;&gt; combinationSum3(int k, int n) &#123; // enumerate ith number, start position of enumerate, cur sum; dfs(k, 1, n); // from end return ans; &#125;void dfs(int k, int start, int n) &#123; if (!k) &#123; if (!n) ans.push_back(path); return; &#125; // enumerate each positon for (int i = start; i &lt;= 9; i++) &#123; path.push_back(i); dfs(k-1, i+1, n-i); path.pop_back(); &#125;&#125; 52. N-Queens II123451.enumerate each row2. each col, diagonal can only have one queen y &#x3D; x+b x+y &#x3D;&gt; row+col[0+2] &#x3D; [1+1] &#x3D; [2+0] x-y+n &#x3D;&gt; row+col-n &#x3D; [0-0+3] &#x3D; [1-1+3] &#x3D; [2-2+3] 1234567891011121314151617181920212223242526int ans, n;vector&lt;bool&gt; col, d, ud;int totalNQueens(int _n) &#123; n = _n; // golbal col = vector&lt;bool&gt;(n); d = ud = vector&lt;bool&gt;(n*2); dfs(0); return ans;&#125;void dfs(int level) &#123; if (level == n) &#123; ans++; return; &#125; for (int i = 0; i &lt; n; i++) &#123; if (!col[i] &amp;&amp; !d[level+i] &amp;&amp; !ud[level-i+n]) &#123; col[i] = d[level+i] = ud[level-i+n] = true; dfs(level+1); col[i] = d[level+i] = ud[level-i+n] = false; &#125; &#125; &#125; 37. Sudoku Solver12enumerate each num in row[9][9], col[9][9], cell[3][3][9] 123456789101112131415161718192021222324252627282930313233343536bool row[9][9] = &#123;0&#125;, col[9][9] = &#123;0&#125;, cell[3][3][9] = &#123;0&#125;;// [#row][num] = used/ no-usevoid solveSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) &#123; for (int i = 0; i &lt; 9; i++) &#123; for (int j = 0; j &lt; 9; j++) &#123; char c = board[i][j]; if (c != '.') &#123; // this num has been used int temp = c -'1'; // num // the num in cur row, col and cell has been used, cannot repeat row[i][temp] = col[j][temp] = cell[i/3][j/3][temp] = true; &#125; &#125; &#125; dfs(board, 0, 0);&#125;bool dfs(vector&lt;vector&lt;char&gt;&gt;&amp; board, int x, int y) &#123; if (y == 9) x++, y = 0; // this row is done, next level, set y = 0 if (x == 9) return true; // x to 9 and still true, so this is a solution if (board[x][y] != '.') return dfs(board, x, y+1); // this is num, next enumerate for (int i = 0; i &lt; 9; i++) &#123; // each num if (!row[x][i] &amp;&amp; !col[y][i] &amp;&amp; !cell[x/3][y/3][i]) &#123; // not used board[x][y] = '1' + i; row[x][i] = col[y][i] = cell[x/3][y/3][i] = true; //used if (dfs(board, x, y+1)) return true; // go next num row[x][i] = col[y][i] = cell[x/3][y/3][i] = false;// recover board[x][y] = '.'; // this is '.' before get into dfs &#125; &#125; // if current status in dfs not meet the requirement return false;&#125; 473. Matchsticks to Square123456789101112131415enumaerate each martchstick to square :prunning :1. from lagest to small : 2 cases, 3 cases, 6 cases, 8caeseif start from the bigeest, totoal branches to cut : below 2 cases, branches : 3 * 6 * 8 -&gt; so we can cut more below 3 cases, branches : 2 * 6 * 82. avoid repeat enumerate : for each side, choose the largest to small3. if cur martchstick fail, skip all the same length4. if cur martchstick fail, &amp;&amp; it is the first one, this whole stratege is fail also, cur this whole branch5. if cur martchstick fail, &amp;&amp; it is the last one, this fail also, since we can swtich it to other places 12345678910111213141516171819202122232425262728293031323334353637vector&lt;bool&gt; st; // this matchstick used or notbool makesquare(vector&lt;int&gt;&amp; nums) &#123; // check the sum % 4 == 0 int sum = 0; for (auto u : nums) sum += u; if (!sum || sum % 4) return false; sort(nums.begin(), nums.end()); reverse(nums.begin(), nums.end()); // largest to smallest st = vector&lt;bool&gt;(nums.size()); return dfs(nums, 0, 0, sum/4); // cur side, cur length, total need length &#125;bool dfs(vector&lt;int&gt; &amp;nums, int side, int cur, int length) &#123; if (cur == length) side++, cur = 0; // next side, recover cur = 0 if (side == 4) return true; // enumerate all sides for (int i = 0; i &lt; nums.size(); i++) &#123; // this stick not used &amp;&amp; &lt;= if (!st[i] &amp;&amp; cur + nums[i] &lt;= length) &#123; st[i] = true; if (dfs(nums, side, cur+nums[i], length)) return true; //fail, recover the status st[i] = false; if (!cur) return false; // if fail and cur stick is the first one, no need to go deep if (cur+nums[i] == length) return false;// if fail, and cur stick is the last one while (i+1 &lt; nums.size() &amp;&amp; nums[i+1] == nums[i]) i++; //if fail skip all the same length stick &#125; &#125; return false;&#125;","categories":[{"name":"yxcNb","slug":"yxcNb","permalink":"http://yoursite.com/categories/yxcNb/"}],"tags":[{"name":"-Data Structure","slug":"Data-Structure","permalink":"http://yoursite.com/tags/Data-Structure/"}],"author":"isFibonacci"},{"title":"DFS （0）","slug":"DFS（0)","date":"2020-03-01T23:55:00.000Z","updated":"2020-03-03T19:19:18.943Z","comments":true,"path":"2020/03/01/DFS（0)/","link":"","permalink":"http://yoursite.com/2020/03/01/DFS%EF%BC%880)/","excerpt":"","text":"842. 排列数字123456731 2 31 3 22 1 32 3 13 1 23 2 1 123456789101112131415161718void dfs(int u) &#123; // the end if (u == n) &#123; for (int i = 0; i &lt; n; i++) printf(\"%d \", path[i]); puts(\"\"); return; &#125; // each number for (int i = 1; i &lt;= n; i++) &#123; if (!st[i]) &#123; // haven't used path[u] = i; st[i] = true; // used dfs(u+1); //each postion st[i] = false; &#125; &#125;&#125; 843. n-皇后问题1234567891011121314151617181920212223void dfs(int u) &#123; // all state if (u == n) &#123; for (int i = 0; i &lt; n; i++) &#123; puts(g[i]); &#125; puts(\"\"); return; &#125; //each row for (int i = 0; i &lt; n; i++) &#123; // each col, diagonal, opposite diagonal haven't been used if (!col[i] &amp;&amp; !dg[u+i] &amp;&amp; !udg[n-u+i]) &#123; // dg[1+1] = false g[u][i] = 'Q'; col[i] = dg[u+i] = udg[n-u+i] = true; dfs(u+1); //recover col[i] = dg[u+i] = udg[n-u+i] = false; g[u][i] = '.'; &#125; &#125;&#125; 17. Letter Combinations of a Phone Number12345678910111213state0 &#x3D; &#123;&quot;&quot;&#125;for 2 : for a, b, c : for &quot;&quot; &quot;a&quot;, &quot;b&quot;, &quot;c&quot;for 3 : for d, e, f : for &quot;a&quot;, &quot;b&quot;, &quot;c&quot; : &quot;ad&quot;, &quot;bd&quot;, &quot;cd&quot;, &quot;ae&quot;,&quot;be&quot;, &quot;cf&quot;, &quot;af&quot;, &quot;bf&quot;, &quot;cf&quot;state2 &#x3D; &#123;&quot;ad&quot;, &quot;bd&quot;, &quot;cd&quot;, &quot;ae&quot;,&quot;be&quot;, &quot;cf&quot;, &quot;af&quot;, &quot;bf&quot;, &quot;cf&quot;&#125; 1234567891011121314151617string chars[8] = &#123;\"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"&#125;;vector&lt;string&gt; letterCombinations(string digits) &#123; if (digits.empty()) return vector&lt;string&gt;(); vector&lt;string&gt; state(1, \"\"); for (auto digit : digits) &#123; vector&lt;string&gt; now; for (auto cha : chars[digit - '2']) &#123; // 2-9 for (auto s : state) &#123; now.push_back(s+cha); &#125; &#125; state = now; &#125; return state;&#125; 79. Word Search1234567891011121314151617181920212223242526272829303132int row, col;int dx[4] = &#123;-1, 0, 1, 0&#125;, dy[4] = &#123; 0, -1, 0, 1&#125;;bool exist(vector&lt;vector&lt;char&gt;&gt;&amp; board, string word) &#123; if (board.empty() || board[0].empty()) return false; row = board.size(), col = board[0].size(); for (int i = 0; i &lt; row; i++) &#123; for (int j = 0; j &lt; col; j++) &#123; if (dfs(board, i, j, word, 0)) return true; &#125; &#125; return false;&#125; bool dfs(vector&lt;vector&lt;char&gt;&gt; &amp; board, int x, int y, string &amp;word, int curLen) &#123; if (board[x][y] != word[curLen]) return false; // if all match, if (curLen == word.size()-1) return true; // used, if not match will return, so at this point, it is matched board[x][y] = '.'; // each direction for (int i = 0; i &lt; 4; i++) &#123; int newX = x + dx[i], newY = y + dy[i]; if (newX &gt;= 0 &amp;&amp; newX &lt; row &amp;&amp; newY &gt;= 0 &amp;&amp; newY &lt; col) &#123; // next word if (dfs(board, newX, newY, word, curLen+1)) return true; &#125; &#125; // backtracking, recover board[x][y] = word[curLen]; return false;&#125; 46. Permutations1234567891011121314151617181920212223242526272829303132int n; vector&lt;vector&lt;int&gt;&gt; ans;vector&lt;int&gt; path; // each permutationvector&lt;bool&gt; st; // record this number has been used or not vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;&amp; nums) &#123; n = nums.size(); st = vector&lt;bool&gt;(n); dfs(nums, 0); return ans;&#125;void dfs(vector&lt;int&gt; &amp;nums, int level) &#123; if (level == n) &#123; ans.push_back(path); return; &#125; // each number in different position for (int i = 0; i &lt; n; i++) &#123; if (!st[i]) &#123; // haven't been used st[i] = true; path.push_back(nums[i]); dfs(nums, level+1); // recover path.pop_back(); st[i] = false; &#125; &#125;&#125; 47. Permutations II123456789101. place all the same number, sort2. the 1th &#39;1&#39; -&gt; 5 the 2th &#39;1&#39; -&gt; 6 e.g : 1 1 only one permutation3. place each number on position [1,_,_] ; [_,1,_] ; [_,_,1] place each position on number [1,_,_] ; [2,_,_] ; [3,_,_] 12345678910111213141516171819202122232425262728293031323334int n;vector&lt;int&gt; path;vector&lt;bool&gt; st;vector&lt;vector&lt;int&gt;&gt; ans;vector&lt;vector&lt;int&gt;&gt; permuteUnique(vector&lt;int&gt;&amp; nums) &#123; n = nums.size(); path = vector&lt;int&gt;(n); st = vector&lt;bool&gt;(n); sort(nums.begin(), nums.end()); dfs(nums, 0, 0); return ans;&#125;void dfs(vector&lt;int&gt;&amp; nums, int level, int start) &#123; if (level == n) &#123; ans.push_back(path); return ; &#125; for (int i = start; i &lt; n; i++) &#123; if (!st[i]) &#123; st[i] = true; path[i] = nums[level]; // sorted // the next num is the same then put it in the next position //1th '1' -&gt; 5, 2th '1' -&gt; 6 // else start from 0, since place each number on diff position dfs(nums, level+1, level+1 &lt; n &amp;&amp; nums[level+1] == nums[level] ? i+1 : 0); st[i] = false; &#125; &#125;&#125;","categories":[{"name":"yxcNb","slug":"yxcNb","permalink":"http://yoursite.com/categories/yxcNb/"}],"tags":[{"name":"-Data Structure","slug":"Data-Structure","permalink":"http://yoursite.com/tags/Data-Structure/"}],"author":"isFibonacci"},{"title":"Bit Manipulate（0）","slug":"Bit Manipulate（0）","date":"2020-03-01T23:55:00.000Z","updated":"2020-03-09T00:55:30.936Z","comments":true,"path":"2020/03/01/Bit Manipulate（0）/","link":"","permalink":"http://yoursite.com/2020/03/01/Bit%20Manipulate%EF%BC%880%EF%BC%89/","excerpt":"","text":"1234567891011121314151617181920211101 &gt;&gt; 2 &#x3D; 11 ( &#x2F; 2^2)1101 &lt;&lt; 3 &#x3D; 1101000 ( * 2^3)5 &#x3D; 101 &#x3D; 1*2^2 + 0*2^1 + 1*2^0-5 :|-5| &#x3D; 5 &#x3D; 0......0101-5 : ~x+1 &#x3D; 010 + 1 &#x3D; 1.....1011x &#x3D; 11011-x &#x3D; 00100x&amp;-x &#x3D; 00000x&amp;-x &#x3D;&gt; x的二进制最右边的14 &#x3D; 100-4 &#x3D; ~x+1 &#x3D; 011 + 1 &#x3D; 100x&amp;-x &#x3D; 100 &#x3D; x : power of 23 &#x3D; 011-1 &#x3D; 100 + 1 &#x3D; 1011&amp;-1 &#x3D; 001 &lt; 011 -&gt; not power of 2-x+1 &#x3D; 00101 231. Power of Two123456bool isPowerOfTwo(int n) &#123; // 1. 1 &lt;&lt; 30 = : 1 * 2^30 // return n &gt; 0 &amp;&amp; (1&lt;&lt;30) % n == 0; return n &gt; 0 &amp;&amp; (n &amp; -n) == n;&#125; 123456789101112131415161710 : 1010 [3,2,1,0]for (int k &#x3D; 3; k &gt;&#x3D; 0; k--) x&gt;&gt;1 &amp; 1;x&amp;(-x) &#x3D; x&amp;(~x+1)x &#x3D; 1010...1000~x &#x3D; 0101...0111~x+1 &#x3D; 0101...1000x&amp;(~x+1)&#x3D; 0000...1000the last 1 postionx &#x3D; 1010sign and magnitude : 1010one&#39;s complement: 0101two&#39;s complement: 0110 801. 二进制中1的个数123456789101112131415 return x&amp;(~x+1);// the last one position&#125;int main() &#123; int n; cin &gt;&gt; n; while (n--) &#123; int x; cin &gt;&gt; x; int res = 0; // record the number of 1 while (x) x -= lowbit(x), res++; cout&lt;&lt; res &lt;&lt;\" \"; &#125; return 0;&#125; 78. Subsets123456789101112131415i-&gt; 2^n-11230~7 case000 : &#123;&#125;001 : &#123;1&#125;010 : &#123;2&#125;011 : &#123;1,2&#125;100 : &#123;3&#125;101 : &#123;1,3&#125;110 : &#123;2,3&#125;111 : &#123;1,2,3&#125;(i&gt;&gt;j) &amp; 1 : j&#39;th position of i is 1 or not1&lt;&lt; nums.size() move left 3 times &#x3D; 2^3bc : 2^3 &#x3D; 8, 8 &#x3D; (1000)2 123456789101112131415vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) &#123; vector&lt;vector&lt;int&gt;&gt; res; for (int i = 0; i &lt; 1&lt;&lt;nums.size(); i++) &#123; // i &lt; 2^3, 8 = (1000)2 vector&lt;int&gt; now; for (int j = 0; j &lt; nums.size(); j++) &#123; if (i &gt;&gt; j &amp; 1) &#123;// jth position of i is 1 or not now.push_back(nums[j]); &#125; &#125; res.push_back(now); &#125; return res;&#125; 762. Prime Number of Set Bits in Binary Representation1234567891011121314151617int countPrimeSetBits(int L, int R) &#123; unordered_set&lt;int&gt; primes(&#123;2, 3, 5, 7, 9, 11, 13, 17, 19&#125;); // [1, 10^6] =&gt; 2 ^ 20 int ans = 0; for (int i = L; i &lt;= R; i++) &#123; int res = 0; // find the number of 1 in this number // k &gt;&gt;= 1, move right 1 bit for (int k = i; k; k &gt;&gt;= 1) res += k &amp; 1; // 1&amp;1 = 1, 1&amp;0 = 0 // check prime if (primes.count(res)) ans++; &#125; return ans; &#125; 136. Single Number123456int singleNumber(vector&lt;int&gt;&amp; nums) &#123; // a^a = 0, 0 ^ a = a, 001 ^ 011 = 010, 010 ^ 010 = 000 so 001 int ans = 0; for (auto num : nums) ans ^= num; return ans;&#125; [476. Number Complement] (https://leetcode.com/problems/number-complement/)12345678int findComplement(int num) &#123; int ans = 0, t = 0; while (num) &#123; ans += !(num &amp; 1) &lt;&lt; t; // ~num, num &gt;&gt;= 1, t++; // num &gt;&gt;= 1, move 1 bit &#125; return ans;&#125; 137. Single Number IIanother solution(https://www.acwing.com/solution/LeetCode/content/232/) 12345678910111213141516int singleNumber(vector&lt;int&gt;&amp; nums) &#123; // origin : 0, 0 // one 1 : 1, 0 // two 1 : 0, 1 //three 1 : 0, 0 // num % 3 = 1 -&gt; 1 times, // num % 3 = 0 -&gt; 3 times int ones = 0, twoes = 0; for (auto num : nums) &#123; ones = (ones ^ num) &amp; ~twoes; // twoes = (twoes ^ num) &amp; ~ones; &#125; return ones; &#125; 260. Single Number III1234567891011121314151617vector&lt;int&gt; singleNumber(vector&lt;int&gt;&amp; nums) &#123; int s = 0; for (auto num : nums) s ^= num; // a^a^b^c=b^c // find b int k = 0; while (!(s&gt;&gt;k &amp; 1)) k++; int s2 = 0; for (auto num : nums) &#123; if (num &gt;&gt; k &amp; 1) &#123; // find b s2 ^= num; // s = a ^ b, s2 = a, s2^s = b; &#125; &#125; return vector&lt;int&gt;(&#123;s^s2, s2&#125;);&#125; 371. Sum of Two Integers123456789// 1101//^ 1001// 0100// 1001 &lt;&lt; 1 = 10010int getSum(int a, int b) &#123; if (!b) return a; // at most, 32times, int sum = a ^ b, carry = uint(a&amp;b)&lt;&lt;1; // 0&amp;0 &lt;&lt; 1 = 0, uint = unsight int(0, 2^32-1) return getSum(sum, carry); // b will be 0 &#125; 201. Bitwise AND of Numbers Range1234567891011int rangeBitwiseAnd(int m, int n) &#123; int res = 0; for (int i = 0; (1ll &lt;&lt; i) &lt;= m; i++) &#123; if (m &gt;&gt; i &amp; 1) &#123; if ((m&amp; ~((1&lt;&lt;i) - 1ll)) + (1 &lt;&lt; i) &gt; n) &#123; res += 1 &lt;&lt; i; &#125; &#125; &#125; return res;&#125; 477. Total Hamming Distance1234567891011121314int totalHammingDistance(vector&lt;int&gt;&amp; nums) &#123; int res = 0; for (int i = 0; i &lt; 30; i++) &#123; int ones = 0; for (auto num : nums) &#123; if (num &gt;&gt; i &amp; 1) &#123; ones++; &#125; &#125; res += ones * (nums.size() - ones); &#125; return res;&#125; 421. Maximum XOR of Two Numbers in an Array123456789101112131415161718192021222324252627282930313233343536373839404142struct Node &#123; int son[2]; // left and right&#125;;vector&lt;Node&gt; nodes;int findMaximumXOR(vector&lt;int&gt;&amp; nums) &#123; nodes.push_back(Node(&#123;0, 0&#125;)); // create tire for (auto num : nums) &#123; int p = 0; for (int i = 30; i &gt;= 0; i--) &#123; int t = num &gt;&gt; i &amp; 1; // the higest bit // if not this node if (!nodes[p].son[t]) &#123; nodes.push_back(Node(&#123;0, 0&#125;)); nodes[p].son[t] = nodes.size()-1; // index &#125; // move p pointer to its son p = nodes[p].son[t]; &#125; &#125; // greedy int ans = 0; for (auto num : nums) &#123; int p = 0, maxXOR = 0; // for lagest bit for (int i = 30; i &gt;= 0; i--) &#123; int t = num &gt;&gt; i &amp; 1; if (nodes[p].son[!t]) &#123; // have son p = nodes[p].son[!t]; maxXOR += 1 &lt;&lt; i; &#125; else &#123; // not son p = nodes[p].son[t]; &#125; &#125; ans = max(ans, maxXOR); &#125; return ans;&#125;","categories":[{"name":"yxcNb","slug":"yxcNb","permalink":"http://yoursite.com/categories/yxcNb/"}],"tags":[{"name":"-Data Structure","slug":"Data-Structure","permalink":"http://yoursite.com/tags/Data-Structure/"}],"author":"isFibonacci"},{"title":"string (1)","slug":"title: string (1)","date":"2020-02-21T23:55:00.000Z","updated":"2020-02-27T05:50:43.264Z","comments":true,"path":"2020/02/21/title: string (1)/","link":"","permalink":"http://yoursite.com/2020/02/21/title:%20string%20(1)/","excerpt":"","text":"208. Implement Trie (Prefix Tree)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public: /** Initialize your data structure here. */ struct Node &#123; bool isEnd; Node *son[26]; Node() &#123; isEnd = false; for (int i = 0; i &lt; 26; i++) son[i] = NULL; &#125; &#125;* root; Trie() &#123; root = new Node(); &#125; /** Inserts a word into the trie. */ void insert(string word) &#123; auto p = root; for (auto c : word) &#123; int u = c - 'a'; // set that node is not NULL if (p-&gt;son[u] == NULL) p-&gt;son[u] = new Node(); p = p-&gt;son[u]; // p move to the son &#125; p-&gt;isEnd = true; &#125; /** Returns if the word is in the trie. */ bool search(string word) &#123; auto p = root; for (auto c : word) &#123; int u = c - 'a'; if (p-&gt;son[u] == NULL) return false; p = p-&gt;son[u]; &#125; return p-&gt;isEnd; &#125; /** Returns if there is any word in the trie that starts with the given prefix. */ bool startsWith(string prefix) &#123; auto p = root; for (auto c : prefix) &#123; int u = c - 'a'; if (p-&gt;son[u] == NULL) return false; p = p-&gt;son[u]; &#125; return true; // prefix &#125;&#125;; 273. Integer to English Words12345678Example 3:Input: 1234567Output: &quot;One Million Two Hundred Thirty Four Thousand Five Hundred Sixty Seven&quot;Example 4:Input: 1234567891Output: &quot;One Billion Two Hundred Thirty Four Million Five Hundred Sixty Seven Thousand Eight Hundred Ninety One&quot; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class Solution &#123;public: string small[20] = &#123;\"Zero\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\", \"Ten\", \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\"&#125;; string decade[10] = &#123;\"\", \"\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\"&#125;; string big[4] = &#123;\"Billion\", \"Million\", \"Thousand\", \"\"&#125;; string numberToWords(int num) &#123; if (!num) return small[0]; string res; for (int i = 1000000000, j = 0; i &gt; 0; i /= 1000, j++) &#123; if (num &gt;= i) &#123; res += getPart(num / i) + big[j] + ' '; num %= i; &#125; &#125; while (res.back() == ' ') res.pop_back(); return res; &#125; string getPart(int num) &#123; string res; if (num &gt;= 100) &#123; res += small[num /100] + \" Hundred \"; num %= 100; &#125; if (!num) return res; if (num &gt;= 20) &#123; res += decade[num /10] + ' '; num %= 10; &#125; if (!num) return res; res += small[num] + ' '; return res; &#125;&#125;;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/categories/leetcode/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"},{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/tags/leetcode/"},{"name":"string","slug":"string","permalink":"http://yoursite.com/tags/string/"}],"author":"isFibonacci"},{"title":"string (0)","slug":"string (0)","date":"2020-02-20T23:55:00.000Z","updated":"2020-02-27T02:38:25.953Z","comments":true,"path":"2020/02/20/string (0)/","link":"","permalink":"http://yoursite.com/2020/02/20/string%20(0)/","excerpt":"","text":"38. Count and Say123456781. 12. 113. 214. 12115. 1112211 is read off as &quot;one 1&quot; or 11.11 is read off as &quot;two 1s&quot; or 21.21 is read off as &quot;one 2, then one 1&quot; or 1211. 12345678910111213141516string countAndSay(int n) &#123; string ans = \"1\"; for (int i = 0; i &lt; n-1; i++) &#123; string temp; for (int j = 0; j &lt; ans.size(); j++) &#123; int k = j; while (k &lt; ans.size() &amp;&amp; ans[k] == ans[j]) k++; //count the repeat element temp += to_string(k - j) + ans[j]; // counter + cur num j = k - 1; // j jump to k pointer &#125; ans = temp; &#125; return ans;&#125; 49. Group Anagrams1234567Input: [&quot;eat&quot;, &quot;tea&quot;, &quot;tan&quot;, &quot;ate&quot;, &quot;nat&quot;, &quot;bat&quot;],Output:[ [&quot;ate&quot;,&quot;eat&quot;,&quot;tea&quot;], [&quot;nat&quot;,&quot;tan&quot;], [&quot;bat&quot;]] 12345678910111213vector&lt;vector&lt;string&gt;&gt; groupAnagrams(vector&lt;string&gt;&amp; strs) &#123; unordered_map&lt;string, vector&lt;string&gt;&gt; hash; for (auto str : strs) &#123; string key = str; sort(key.begin(), key.end()); hash[key].push_back(str); &#125; vector&lt;vector&lt;string&gt;&gt; res; for (auto item : hash) res.push_back(item.second); return res;&#125;// O(n*m*logm + n*m) : n word, m : word length 151. Reverse Words in a String12345678910111213141516171819202122232425262728293031string reverseWords(string s) &#123; int wordEnd = 0; for (int i = 0; i &lt; s.size(); i++) &#123; // erase spaces while (i &lt; s.size() &amp;&amp; s[i] == ' ') i++; if (i == s.size()) break; // reverse each word int j = i; while (j &lt; s.size() &amp;&amp; s[j] != ' ') j++; // [) not including j reverse(s.begin() + i, s.begin() + j); // insert space if (wordEnd) s[wordEnd++] = ' '; //move wordEnd pointer to word end // bc may have a lot of spaces between words // _hello______w, k = index after one space of 'o' // copy w to there while (i &lt; j) s[wordEnd++] = s[i++]; &#125; cout&lt;&lt;s&lt;&lt;endl; // erase the spaces of the string end s.erase(s.begin() + wordEnd, s.end()); // reverse the str by each word reverse(s.begin(), s.end()); return s;&#125; 165. Compare Version Numbers12345678910111213141516171819202122int compareVersion(string s1, string s2) &#123; int i = 0, j = 0; while (i &lt; s1.size() || j &lt; s2.size()) &#123; int x = i, y = j; //cut word while (x &lt; s1.size() &amp;&amp; s1[x] != '.') x++; while (y &lt; s2.size() &amp;&amp; s2[y] != '.') y++; // convert to int int a = i == x ? 0 : atoi(s1.substr(i, x - i).c_str()); // substr return pointer, so need to conver to char int b = j == y ? 0 : atoi(s2.substr(j, y - j).c_str()); if (a &gt; b) return 1; if (a &lt; b) return -1; //continue i = x + 1, j = y + 1; &#125; return 0;&#125; 929. Unique Email Addresses123456789101112131415int numUniqueEmails(vector&lt;string&gt;&amp; emails) &#123; unordered_set&lt;string&gt; set; for (auto email : emails) &#123; string name; int at = email.find('@'); for (auto c : email.substr(0, at)) &#123; if (c == '+') break; // ignore else if (c != '.') name += c; // a.b = ab &#125; string domain = email.substr(at + 1); set.insert(name + '@' + domain); &#125; return set.size();&#125; 5. Longest Palindromic Substring12345678910111213141516string longestPalindrome(string s) &#123; string res; for (int i = 0; i &lt; s.size(); i++) &#123; // odd for (int j = i, k = i; j &gt;= 0 &amp;&amp; k &lt; s.size() &amp;&amp; s[j] == s[k]; j--, k++) &#123; if (res.size() &lt; k - j + 1) res = s.substr(j, k -j + 1); &#125; // even for (int j = i, k = i + 1; j &gt;= 0 &amp;&amp; k &lt; s.size() &amp;&amp; s[j] == s[k]; j--, k++) &#123; if (res.size() &lt; k - j + 1) res = s.substr(j, k - j + 1); &#125; &#125; return res;&#125; 6. ZigZag Conversion123456 N &#x3D; 50 8 16 首项是0， 公差是2（N-1）的等差数列1 7 9 15 两个等差数列交错2 6 10 143 5 11 134 12 首项是N-1， 公差是2（N-1）的等差数列 12345678910111213141516171819string convert(string s, int n) &#123; if (n == 1) return s; // (n -1) string res; for (int i = 0 ; i &lt; n; i++) &#123; // the fisrt and the last row if (!i || i == n - 1) &#123; for (int j = i; j &lt; s.size(); j += 2*(n-1)) res += s[j]; &#125; else &#123; for (int j = i, k = 2*(n-1) - i; j &lt; s.size() || k &lt; s.size(); j += 2*(n-1), k += 2*(n-1)) &#123; if (j &lt; s.size()) res += s[j]; if (k &lt; s.size()) res += s[k]; // res += s[j]; // res += s[k]; -&gt; k may over the size first &#125; &#125; &#125; return res;&#125; 3. Longest Substring Without Repeating Characters12345678910111213141516int lengthOfLongestSubstring(string s) &#123; int res = 0; unordered_map&lt;char, int&gt; hash; for (int i = 0, j = 0; i &lt; s.size(); i++) &#123; hash[s[i]]++; // if the added element make hash[s[i]] &gt; 1 // repeat, move j to the repeat index // before j + 1(the repeat one) is the res // clean the hash while (hash[s[i]] &gt; 1) hash[s[j++]]--; res = max(res, i - j + 1); &#125; return res;&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/categories/leetcode/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"},{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/tags/leetcode/"},{"name":"string","slug":"string","permalink":"http://yoursite.com/tags/string/"}],"author":"isFibonacci"},{"title":"binary-stack-queue (1)","slug":"title: binary-stack-queue (1)","date":"2020-02-14T23:55:00.000Z","updated":"2020-02-24T18:51:00.154Z","comments":true,"path":"2020/02/14/title: binary-stack-queue (1)/","link":"","permalink":"http://yoursite.com/2020/02/14/title:%20binary-stack-queue%20(1)/","excerpt":"","text":"496. Next Greater Element I12345678给定两个没有重复元素的数组 nums1 和 nums2 ，其中 nums1 是 nums2 的子集。找到 nums1 中每个元素在 nums2 中的下一个比其大的值。nums1 中数字 x 的下一个更大元素是指 x 在 nums2 中对应位置的右边的第一个比 x 大的元素。如果不存在，对应位置输出 -1输入: nums1 &#x3D; [4,1,2], nums2 &#x3D; [1,3,4,2].输出: [-1,3,-1]解释:对于 nums1 中的数字 4，你无法在第二个数组中找到下一个更大的数字，因此输出 -1。对于 nums1 中的数字 1，第二个数组中数字1右边的下一个较大数字是 3。对于 nums1 中的数字 2，第二个数组中没有下一个更大的数字，因此输出 -1。 121. use stack to save the next greater element in its right2. bc need to find its right, so we search from back 1234567891011121314vector&lt;int&gt; nextGreaterElement(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123; stack&lt;int&gt; stk; unordered_map&lt;int, int&gt; hash; for (int i = nums2.size() -1; i &gt;= 0; i--) &#123; int t = nums2[i]; while (stk.size() &amp;&amp; stk.top() &lt;= t) stk.pop(); hash[t] = stk.size() ? stk.top() : -1; stk.push(t); &#125; vector&lt;int&gt; res; for (auto t : nums1) res.push_back(hash[t]); return res;&#125; 84. Largest Rectangle in Histogram1234567891011121314151617181920int largestRectangleArea(vector&lt;int&gt;&amp; heights) &#123;int n = heights.size(), ans = 0;heights.push_back(-1); // [2, 3], i = 2// 为了算法书写方便，在数组末尾添加高度 -1// 这会使得栈中所有数字在最后出栈。stack&lt;int&gt; st; // index for (int i = 0; i &lt;= n; i++) &#123; while (!st.empty() &amp;&amp; heights[i] &lt; heights[st.top()]) &#123; int cur = st.top(); st.pop(); if (st.empty()) ans = max(ans, heights[cur] * i); // [2,1] height[cur] else ans = max(ans, heights[cur] * (i - st.top() - 1)); // weigth, - 1 is itself, limit by the shortest heigth &#125; st.push(i);&#125;return ans;&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/categories/leetcode/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"},{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/tags/leetcode/"},{"name":"binary","slug":"binary","permalink":"http://yoursite.com/tags/binary/"},{"name":"stack","slug":"stack","permalink":"http://yoursite.com/tags/stack/"},{"name":"heap","slug":"heap","permalink":"http://yoursite.com/tags/heap/"}],"author":"isFibonacci"},{"title":"Linked List(0)","slug":"Linked List(0)","date":"2020-02-14T23:55:00.000Z","updated":"2020-03-03T02:49:35.300Z","comments":true,"path":"2020/02/14/Linked List(0)/","link":"","permalink":"http://yoursite.com/2020/02/14/Linked%20List(0)/","excerpt":"","text":"82. Remove Duplicates from Sorted List II1234567891011121314151617181920212223ListNode* deleteDuplicates(ListNode* head) &#123; ListNode* dummy = new ListNode(0); dummy-&gt;next = head; ListNode* pre = dummy; ListNode* cur = head; bool equal = false; while (cur &amp;&amp; cur-&gt;next) &#123; while (cur-&gt;next &amp;&amp; cur-&gt;val == cur-&gt;next-&gt;val) &#123; equal = true; cur = cur-&gt;next; &#125; if (equal) &#123; pre-&gt;next = cur-&gt;next; equal = false; &#125; else &#123; pre = cur; &#125; cur = cur-&gt;next; &#125; return dummy-&gt;next;&#125; [83. Remove Duplicates from Sorted List] (https://leetcode.com/problems/remove-duplicates-from-sorted-list/)1234567891011ListNode* deleteDuplicates(ListNode* head) &#123; ListNode* cur = head; while (cur) &#123; if (cur-&gt;next &amp;&amp; cur-&gt;val == cur-&gt;next-&gt;val) &#123; cur-&gt;next = cur-&gt;next-&gt;next; &#125; else &#123; cur = cur-&gt;next; &#125; &#125; return head;&#125;","categories":[{"name":"恰饭要紧","slug":"恰饭要紧","permalink":"http://yoursite.com/categories/%E6%81%B0%E9%A5%AD%E8%A6%81%E7%B4%A7/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"}],"author":"isFibonacci"},{"title":"Slide Window (0)","slug":"title: Slide Window (0)","date":"2020-02-14T23:55:00.000Z","updated":"2020-03-02T00:00:14.710Z","comments":true,"path":"2020/02/14/title: Slide Window (0)/","link":"","permalink":"http://yoursite.com/2020/02/14/title:%20Slide%20Window%20(0)/","excerpt":"","text":"[167. Two Sum II - Input array is sorted] (https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/)123Input: numbers &#x3D; [2,7,11,15], target &#x3D; 9Output: [1,2]Explanation: The sum of 2 and 7 is 9. Therefore index1 &#x3D; 1, index2 &#x3D; 2. 12345678910vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; numbers, int target) &#123; // i &lt; numbers.size()-1 if only two element for (int i = 0, j = numbers.size() -1; i &lt; numbers.size()-1; i++) &#123; // fix i, move j while ( i &lt; j &amp;&amp; numbers[i] + numbers[j] &gt; target) j--; if (numbers[i] + numbers[j] == target) return &#123;i+1, j+1&#125;; &#125; return &#123;-1, -1&#125;;&#125; 88. Merge Sorted Array1234567891011void merge(vector&lt;int&gt;&amp; nums1, int m, vector&lt;int&gt;&amp; nums2, int n) &#123; int i = m -1, j = n -1, k = m + n -1; while (i &gt;= 0 &amp;&amp; j &gt;= 0) &#123; // if use ||, j = 0 -&gt;else -1 if (nums1[i] &gt; nums2[j]) nums1[k--] = nums1[i--]; else nums1[k--] = nums2[j--]; &#125; // if nums2 not empty, means have smaller while (j &gt;= 0) nums1[k--] = nums2[j--]; // if nums2 bigger, do need to move i&#125; 26. Remove Duplicates from Sorted Array1234567891011Given nums &#x3D; [1,1,2],Your function should return length &#x3D; 2, with the first two elements of nums being 1 and 2 respectively.It doesn&#39;t matter what you leave beyond the returned length.Given nums &#x3D; [0,0,1,1,1,2,2,3,3,4],Your function should return length &#x3D; 5, with the first five elements of nums being modified to 0, 1, 2, 3, and 4 respectively.It doesn&#39;t matter what values are set beyond the returned length. 1234567891011int removeDuplicates(vector&lt;int&gt;&amp; nums) &#123; if (nums.empty()) return 0; int k = 1; for (int j = 1; j &lt; nums.size(); j++) &#123; if (nums[j] != nums[j-1]) &#123; nums[k++] = nums[j]; // cover it &#125; &#125; return k;&#125; [76. Minimum Window Substring] (https://leetcode.com/problems/minimum-window-substring/)12Input: S &#x3D; &quot;ABBBBDABC&quot;, T &#x3D; &quot;ABBC&quot;Output: &quot;BDABC&quot; 1234567891011121314151617string minWindow(string s, string t) &#123; unordered_map&lt;char,int&gt; hash; for (auto c : t) hash[c]++; int cnt = hash.size(); // cout&lt;&lt;hash.size()&lt;&lt;endl; // 3 string res; for (int i = 0, j = 0, c = 0; i &lt; s.size(); i++) &#123; if (hash[s[i]] == 1) c++; hash[s[i]]--; while (hash[s[j]] &lt; 0) hash[s[j++]]++; if (c == cnt) &#123; if (res.empty() || res.size() &gt; i - j + 1) res = s.substr(j, i - j + 1); &#125; &#125; return res;&#125; 32. Longest Valid Parentheses123456789合法的括号序列 &#x3D; 前缀和 》&#x3D; 0 &amp;&amp; 总和 &#x3D; 0start ： 当前枚举的这一段的开头cnt ： 前缀和( &#x3D; 1, ) &#x3D; -11. cnt &lt; &#x3D;&gt; start &#x3D; i + 1, cnt &#x3D; 02. cnt &gt; 0 &#x3D;&gt; 继续做3. cnt &#x3D;&#x3D; 0 &#x3D;&gt; 【start, i] 是一段合法的括号序列4. （（（（（）） cnt 一直 &gt;0 so 反过来再做一次 (()))) 123456789101112131415161718192021int work(string s) &#123; int res = 0; for (int i = 0, start = 0, cnt = 0; i &lt; s.size(); i++) &#123; if (s[i] == '(') cnt++; else &#123; cnt --; if (cnt &lt; 0) start = i + 1, cnt = 0; else if (!cnt) res = max(res, i - start + 1); // valid parentheses &#125; &#125; return res;&#125;int longestValidParentheses(string s) &#123; int res = work(s); // （（（（（）） cnt 一直 &gt;0 so 反过来再做一次 (()))) reverse(s.begin(), s.end()); for (auto &amp;c : s) c ^= 1; // convert ( -&gt; ) return max(res, work(s));&#125; 42. Trapping Rain Water12单调栈 ： 左侧第一个比它小的数单调队列： 滑动窗口最值 1234567891011121314151617181920int trap(vector&lt;int&gt;&amp; height) &#123; int res = 0; stack&lt;int&gt; stk; for (int i = 0; i &lt; height.size(); i++) &#123; int last = 0; // last height while (stk.size() &amp;&amp; height[i] &gt;= height[stk.top()]) &#123; int t = stk.top(); stk.pop(); res += (i - t - 1) * (height[t] - last); // level, leftHight-rightLow last = height[t]; &#125; // if still have, that means left &gt; height[i] if (stk.size()) res += (i - stk.top() -1) * (height[i] - last); // rightHigh - leftLow stk.push(i); &#125; return res;&#125; 239. Sliding Window Maximum1234567891011121314151617vector&lt;int&gt; maxSlidingWindow(vector&lt;int&gt;&amp; nums, int k) &#123; vector&lt;int&gt; res; deque&lt;int&gt; q; for (int i = 0; i &lt; nums.size(); i++) &#123; // move window, if full, move it out if (q.size() &amp;&amp; i - k + 1 &gt; q.front()) q.pop_front(); // decreasing queue, the front is always the max while (q.size() &amp;&amp; nums[q.back()] &lt;= nums[i]) q.pop_back(); q.push_back(i); // each maximum in the window if (i &gt;= k - 1) res.push_back(nums[q.front()]); &#125; return res;&#125; 918. Maximum Sum Circular Subarray123456789101112131415161718192021int maxSubarraySumCircular(vector&lt;int&gt;&amp; A) &#123; int n = A.size(); //make A to 2n for (int i = 0; i &lt; n; i++) A.push_back(A[i]); //find n length window, the maximum sum of 1~n vector&lt;int&gt; sum(2*n+1); for (int i = 1; i &lt;= 2*n; i++) sum[i] = sum[i-1] + A[i-1]; int res = INT_MIN; deque&lt;int&gt; q; q.push_back(0); for (int i = 1; i &lt;= 2*n; i++) &#123; if (q.size() &amp;&amp; i - n &gt; q.front()) q.pop_front(); if (q.size()) res = max(res, sum[i]-sum[q.front()]); // q.front is the smallest while (q.size() &amp;&amp; sum[q.back()] &gt;= sum[i]) q.pop_back(); // increasing q.push_back(i); &#125; return res;&#125;","categories":[{"name":"恰饭要紧","slug":"恰饭要紧","permalink":"http://yoursite.com/categories/%E6%81%B0%E9%A5%AD%E8%A6%81%E7%B4%A7/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"}],"author":"isFibonacci"},{"title":"Dynamic Program (0)","slug":"title: Dynamic Program (0)","date":"2020-02-14T23:55:00.000Z","updated":"2020-03-13T03:00:53.373Z","comments":true,"path":"2020/02/14/title: Dynamic Program (0)/","link":"","permalink":"http://yoursite.com/2020/02/14/title:%20Dynamic%20Program%20(0)/","excerpt":"","text":"120. Triangle123456789For example, given the following triangle[ [2], [3,4], [6,5,7], [4,1,8,3]]The minimum path sum from top to bottom is 11 (i.e., 2 + 3 + 5 + 1 &#x3D; 11). 123456789101112131415161718192021222324252627int minimumTotal(vector&lt;vector&lt;int&gt;&gt;&amp; nums) &#123; int row = nums.size(); vector&lt;vector&lt;long long&gt;&gt; dp(row, vector&lt;long long&gt; (row)); dp[0][0] = nums[0][0]; for (int i = 1; i &lt; row; i++) &#123; //each level for (int j = 0; j &lt; nums[i].size(); j++) &#123; dp[i][j] = INT_MAX; //like res = min(res, dp[row-1][i]); //from top left if (j &gt; 0) dp[i][j] = min(dp[i][j], dp[i-1][j-1] + nums[i][j]); //from top right if (j &lt; nums[i-1].size()) dp[i][j] = min(dp[i][j], dp[i-1][j] + nums[i][j]); &#125; &#125; //at last row long long res = INT_MAX; for (int i = 0 ; i &lt; nums[row-1].size(); i++) &#123; res = min(res, dp[row-1][i]); &#125; return res;&#125; 63. Unique Paths II123456789101112131415161718192021222324int uniquePathsWithObstacles(vector&lt;vector&lt;int&gt;&gt;&amp; g) &#123; int row = g.size(), col = g[0].size(); vector&lt;vector&lt;long long&gt;&gt; dp(row, vector&lt;long long&gt;(col)); // if [[1]] Expected : 0 // dp[0][0] = 1; for (int i = 0; i &lt; row; i++) &#123; for (int j = 0; j &lt; col; j++) &#123; //obstacles, should before !i&amp;&amp;!j bc [[1]], i = 1, j = 1 if (g[i][j]) continue; if (!i &amp;&amp; !j) dp[i][j] = 1; //not the first row, e.g i = 1; dp[1][0] = 1, down if (i &gt; 0) dp[i][j] += dp[i-1][j]; //else if is wrong if (j &gt; 0) dp[i][j] += dp[i][j-1]; &#125; &#125; //at [row-1][col]: down, at[row][col-1]: right return dp[row-1][col-1];&#125; 198. House Robber12345678910111213int rob(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); if (n == 0) return 0; int rob = 0, notRob = 0; for(int i = 0; i &lt; n; i++) &#123; int preRob = rob, preNotRob = notRob; rob = preNotRob + nums[i]; notRob = max(preRob, preNotRob); &#125; return max(rob, notRob);&#125; [1143. Longest Common Subsequence] (https://leetcode.com/problems/longest-common-subsequence/)12345678910111213141516int longestCommonSubsequence(string text1, string text2) &#123; int len1 = text1.size(), len2 = text2.size(); vector&lt;vector&lt;int&gt;&gt; dp(len1+1, vector&lt;int&gt;(len2+1)); for (int i = 1; i &lt;= len1; i++) &#123; for (int j = 1; j &lt;= len2; j++) &#123; if (text1[i-1] == text2[j-1]) &#123; dp[i][j] = (dp[i-1][j-1] + 1); &#125; else &#123; dp[i][j] = max(dp[i-1][j], dp[i][j-1]); &#125; &#125; &#125; return dp[len1][len2];&#125; 354. Russian Doll Envelopes12345678910111213141516171819202122232425262728static bool cmp(vector&lt;int&gt;&amp;a, vector&lt;int&gt; &amp;b) &#123; if (a[0] != b[0]) return a[0] &lt; b[0]; return a[1] &gt; b[1]; // if a.first == b.first&#125; // [1,2], [1,4], [2,4], [2,3], so increasing y won't have the same x, [x,y] int maxEnvelopes(vector&lt;vector&lt;int&gt;&gt;&amp; envelopes) &#123; int n = envelopes.size(); sort(envelopes.begin(), envelopes.end(), cmp); vector&lt;int&gt; q; for (auto item : envelopes) &#123; int y = item[1]; // save second if (q.empty() || y &gt; q.back()) &#123; q.push_back(y); &#125; else &#123; int l = 0, r = q.size() -1; while (l &lt; r) &#123; int mid = l + r &gt;&gt; 1; if (q[mid] &gt;= y) r = mid; else l = mid + 1; &#125; q[l] = min(q[l], y); // save more evelopes as you can, // so choose the min &#125; &#125; return q.size();&#125; 338. Counting Bits12345678910111213141516// 001 : f[1] = 0 + 1 = 1// 010 : f[2] = 010, f[2&gt;&gt;1] = 001// 010 : f[2] = f[1] + 1, 1 + (010 &amp; 001 = 0) = 1// 011 : f[3] = f[1] + (011 &amp; 001) = 1 + 1 = 2 // 001, 010, 011, 100, 4/2 = 2-&gt; 100&gt;&gt;1 = 010// f[4] = f[2] + (100 &amp; 001) = 1 + 0 = 1// each num is 1 or 2, so + (i&amp;1)vector&lt;int&gt; countBits(int num) &#123; vector&lt;int&gt; f(num+1); f[0] = 0; for (int i = 1; i &lt;= num; i++) &#123; f[i] = f[i&gt;&gt;1] + (i&amp;1); &#125; return f; &#125; 526. Beautiful Arrangement1234567891011121314151617181920int countArrangement(int N) &#123; vector&lt;int&gt; f(1 &lt;&lt; N, 0); for (int i = 0; i &lt; N; i++) f[1 &lt;&lt; i] = 1; for (int s = 1; s &lt; (1 &lt;&lt; N); s++) if (f[s] &gt; 0) &#123; int tot = 0; for (int i = 0; i &lt; N; i++) if (s &amp; (1 &lt;&lt; i)) tot++; for (int i = 0; i &lt; N; i++) if (!(s &amp; (1 &lt;&lt; i)) &amp;&amp; ((tot + 1) % (i + 1) == 0 || (i + 1) % (tot + 1) == 0)) f[s | 1 &lt;&lt; i] += f[s]; &#125; return f[(1 &lt;&lt; N) - 1]; &#125; 486. Predict the Winner12345678910111213141516171819202122bool PredictTheWinner(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); vector&lt;vector&lt;int&gt;&gt; f(n, vector&lt;int&gt;(n)); // f[i][j], [i, j] player1 score, total score - player1 = player2 // problem -&gt; max player1 score if (n &amp; 1) // if only 0 and that num, we only need to check odd case for (int i = 0; i &lt; n; i++) f[i][i] = nums[i]; // the last num will be choosed by player1 for (int i = 2; i &lt;= n; i++) &#123; // length 2 cases for (int j = 0; j + i - 1 &lt; n; j++) &#123; // j+i-1 the last num in this section int l = j, r = j + i - 1; if ((n - (r - l + 1)) % 2 == 0) f[l][r] = max(f[l+1][r] + nums[l], f[l][r-1] + nums[r]); else f[l][r] = min(f[l+1][r], f[l][r - 1]); &#125; &#125; int sum = 0; for(auto x : nums) sum += x; return f[0][n-1] &gt;= sum - f[0][n-1];&#125;","categories":[{"name":"恰饭要紧","slug":"恰饭要紧","permalink":"http://yoursite.com/categories/%E6%81%B0%E9%A5%AD%E8%A6%81%E7%B4%A7/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"}],"author":"isFibonacci"},{"title":"Hash Table (1)","slug":"title: Hash Table (1)","date":"2020-02-14T23:55:00.000Z","updated":"2020-02-21T02:14:57.605Z","comments":true,"path":"2020/02/14/title: Hash Table (1)/","link":"","permalink":"http://yoursite.com/2020/02/14/title:%20Hash%20Table%20(1)/","excerpt":"","text":"350. Intersection of Two Arrays II12345678Example 1:Input: nums1 &#x3D; [1,2,2,1], nums2 &#x3D; [2,2]Output: [2,2]Example 2:Input: nums1 &#x3D; [4,9,5], nums2 &#x3D; [9,4,9,8,4]Output: [4,9] 1234560 . use table to record element in the less length nums for loop to search the x1. Only add the least frequency intersection : Input: nums1 &#x3D; [4,9,5], nums2 &#x3D; [9,4,9,8,4] Output: [4,9] So, need to erase that x in the table 1234567891011121314151617181920vector&lt;int&gt; intersect(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123; // exchange the pointer if (nums1.size() &gt; nums2.size()) return intersect(nums2, nums1); unordered_multiset&lt;int&gt; hash; for (auto num : nums1) hash.insert(num); vector&lt;int&gt; res; for (auto num : nums2) &#123; if (hash.count(num)) &#123; res.push_back(num); // erase [2,2,2] [2,2] -&gt; [2, 2] auto it = hash.find(num); hash.erase(it); &#125; if (hash.size() == 0) return res; &#125; return res;&#125; 1234567map, multimap, set, multiset : red black treesorted, O(nlogn)unordered_map, unordered_multimap, unordered_set, unordered_multiset,dictionary, O(1) 706. Design HashMap1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253class MyHashMap &#123;public: /** Initialize your data structure here. */ const static int N = 20011; vector&lt;list&lt;pair&lt;int, int&gt;&gt;&gt; hash; MyHashMap() &#123; hash = vector&lt;list&lt;pair&lt;int, int&gt;&gt;&gt;(N); &#125; list&lt;pair&lt;int, int&gt;&gt;::iterator find(int key) &#123; int t = key % N; auto it = hash[t].begin(); for (; it != hash[t].end(); it++) &#123; if (it-&gt;first == key) break; &#125; return it; &#125; /** value will always be non-negative. */ void put(int key, int value) &#123; int t = key % N; auto it = find(key); if (it == hash[t].end()) // not have hash[t].push_back(make_pair(key, value)); else it-&gt;second = value; &#125; /** Returns the value to which the specified key is mapped, or -1 if this map contains no mapping for the key */ int get(int key) &#123; int t = key % N; auto it = find(key); if (it == hash[t].end()) return -1; return it-&gt;second; &#125; /** Removes the mapping of the specified value key if this map contains a mapping for the key */ void remove(int key) &#123; int t = key % N; auto it = find(key); if (it != hash[t].end()) hash[t].erase(it); &#125;&#125;; 652. Find Duplicate Subtrees1234567891011121314151617Example 1: 1 &#x2F; \\ 2 3 &#x2F; &#x2F; \\ 4 2 4 &#x2F; 4The following are two duplicate subtrees: 2 &#x2F; 4and 4 1231. dfs, record the frequency of each subtree2. hash is O(1), copy string is O(n), recursion left and right so O(n^2) 12345678910111213141516171819// record the string frequencyunordered_map&lt;string, int&gt; hash;vector&lt;TreeNode*&gt; ans;string dfs(TreeNode* node) &#123; if (!node) return \" \"; string left = dfs(node-&gt;left); string right = dfs(node-&gt;right); string s = to_string(node-&gt;val) + ',' + left + ',' + right; if (++hash[s] == 2) ans.push_back(node); return s;&#125;vector&lt;TreeNode*&gt; findDuplicateSubtrees(TreeNode* root) &#123; dfs(root); return ans;&#125; 290. Word Pattern123456Input: pattern &#x3D; &quot;abba&quot;, str &#x3D; &quot;dog cat cat dog&quot;Output: trueExample 2:Input:pattern &#x3D; &quot;abba&quot;, str &#x3D; &quot;dog cat cat fish&quot;Output: false 1231. each word map to specific string string map to specific word worng: b -&gt; bc, c-&gt;bc 12345678910111213141516171819202122bool wordPattern(string pattern, string str) &#123; stringstream raw(str); vector&lt;string&gt; words; string word; while (raw &gt;&gt; word) words.push_back(word); if (pattern.size() != words.size()) return false; unordered_map&lt;char, string&gt; patString; unordered_map&lt;string, char&gt; stringPat; for (int i = 0; i &lt; words.size(); i++) &#123; char c = pattern[i]; string s = words[i]; if (!patString.count(c)) patString[c] = s; if (!stringPat.count(s)) stringPat[s] = c; if (patString[c] != s || stringPat[s] != c) return false; &#125; return true; &#125; 554. Brick Wall11. record the max count of same length 1234567891011121314151617int leastBricks(vector&lt;vector&lt;int&gt;&gt;&amp; wall) &#123; unordered_map&lt;int, int&gt; hash; int res = 0; for (auto blocks : wall) &#123; int sum = 0; // each row for (int i = 0; i + 1 &lt; blocks.size(); i++) &#123; sum += blocks[i]; hash[sum]++; res = max(res, hash[sum]); &#125; &#125; return wall.size() - res;&#125; 149. Max Points on a Line12341. set a point, record the slop2. if vertical slop &#x3D; infinite, duplicate3. If the last one is duplicate : need two loop, frist to find the duplicate and vertical 1234567891011121314151617181920212223242526272829303132int maxPoints(vector&lt;vector&lt;int&gt;&gt;&amp; points) &#123;if (points.empty()) return 0;int res = 1;for (int i = 0; i &lt; points.size(); i++) &#123; int vertical = 1, duplicate = 0; // duplicate, vertical for (int j = i + 1; j &lt; points.size(); j++) &#123; if (points[i][0] == points[j][0]) &#123; if (points[i][1] == points[j][1]) duplicate++; vertical++; &#125; &#125; // slop unordered_map&lt;long double, int&gt; hash; for (int j = i + 1; j &lt; points.size(); j++) &#123; if (points[i][0] != points[j][0]) &#123; long double slop = (long double) (points[i][1] - points[j][1]) / (points[i][0] - points[j][0]); if (hash.count(slop)) hash[slop]++; else hash[slop] = 2; res = max(res, duplicate + hash[slop]); &#125; &#125; // need to compare choose the vertical or slop res = max(res, vertical); &#125;return res;&#125; 355. Design Twitter123456789101112131415161718192021222324252627282930313233343536373839404142434445/** Initialize your data structure here. */unordered_map&lt;int, vector&lt;pair&lt;int, int&gt;&gt;&gt; posts; // UserID, &lt;postDate, postID&gt;unordered_map&lt;int, unordered_set&lt;int&gt;&gt; follows; // UserID map to followsint id = 0; // postDateTwitter() &#123; &#125;/** Compose a new tweet. */void postTweet(int userId, int tweetId) &#123; posts[userId].push_back(make_pair(id++, tweetId)); // postDate++&#125;/** Retrieve the 10 most recent tweet ids in the user's news feed. Each item in the news feed must be posted by users who the user followed or by the user herself. Tweets must be ordered from most recent to least recent. */vector&lt;int&gt; getNewsFeed(int userId) &#123; // find all the post he posted vector&lt;pair&lt;int, int&gt;&gt; ps; for (auto t : posts[userId]) ps.push_back(t); // find all the post his followee posts for (auto follow : follows[userId]) for (auto t : posts[follow]) ps.push_back(t); sort(ps.rbegin(), ps.rend()); // id greater, date newer, so reverse begin vector&lt;int&gt; res; for (int i = 0; i &lt; 10 &amp;&amp; i &lt; ps.size(); i++) &#123; res.push_back(ps[i].second); // postID &#125; return res;&#125;/** Follower follows a followee. If the operation is invalid, it should be a no-op. */void follow(int followerId, int followeeId) &#123; if (followerId != followeeId) &#123; follows[followerId].insert(followeeId); &#125;&#125;/** Follower unfollows a followee. If the operation is invalid, it should be a no-op. */void unfollow(int followerId, int followeeId) &#123; follows[followerId].erase(followeeId); &#125; 128. Longest Consecutive Sequence123456789Given an unsorted array of integers, find the length of the longest consecutive elements sequence.Your algorithm should run in O(n) complexity.Example:Input: [100, 4, 200, 1, 3, 2]Output: 4Explanation: The longest consecutive elements sequence is [1, 2, 3, 4]. Therefore its length is 4. 12345671. Because it is consecutive, hash[x-1] is the number of LEFT consecutive points hash[x+1] is the number of RIGHT consecutive points2. hash[x-left] &#x3D; during the left to x, the nubmer of points hash[x+right] &#x3D; during the x to right+x, the numbr of points hash[x+right] can be seen as x+right+1 point hash[x-left] 现在终点可以看成下一段的起点 1234567891011121314151617int longestConsecutive(vector&lt;int&gt;&amp; nums) &#123; int res = 0; unordered_map&lt;int, int&gt; hash; // key: idnex, value : val for (auto x : nums) &#123; if (hash[x]) continue; // repeat hash[x] = 1; // itself, mark int left = hash[x-1]; // the number points of left int right = hash[x+1]; // the number points of right // update hash[x-left] = left+right+1; hash[x+right] = left+right+1; res = max(res, left+right+1); &#125; return res; &#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/categories/leetcode/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"},{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/tags/leetcode/"},{"name":"Hash Table","slug":"Hash-Table","permalink":"http://yoursite.com/tags/Hash-Table/"}],"author":"isFibonacci"},{"title":"sort (0)","slug":"sort (0)","date":"2020-02-14T23:55:00.000Z","updated":"2020-03-06T04:26:56.180Z","comments":true,"path":"2020/02/14/sort (0)/","link":"","permalink":"http://yoursite.com/2020/02/14/sort%20(0)/","excerpt":"","text":"785. 快速排序1234567891011121314151617181920212223242526const int N = 1e6+10;int q[N], n;void quickSort(int q[], int l, int r) &#123; if (l &gt;= r) return; int i = l - 1, j = r + 1, x = q[l + r &gt;&gt;1]; while (i &lt; j) &#123; do i++; while (q[i] &lt; x); do j--; while (q[j] &gt; x); if (i &lt; j) swap(q[i], q[j]); &#125; quickSort(q, l, j), quickSort(q, j+1, r);&#125;int main() &#123; scanf(\"%d\", &amp;n); for (int i = 0 ; i &lt; n; i++) scanf(\"%d\", &amp;q[i]); quickSort(q, 0, n-1); for (int i = 0; i &lt; n; i++) printf(\"%d \", q[i]); return 0;&#125; 786. 第k个数1234567891. find the seperate point, q[l], q[(l+r)&#x2F;2], q[r]2. all the num in the left &lt;&#x3D; x, all the num in the right &gt;&#x3D; x3. recursion sort left and right n+ n&#x2F;2 + n&#x2F;4 + ... &#x3D; n(1+ 1&#x2F;2+1&#x2F;4 + ...) &gt;&#x3D; 2n O(n)int sl &#x3D; j - l + 1; &#x2F;&#x2F; how many nums before the jneed to plus one bc, itsefl. 123456789101112131415161718192021int quickSort(int l, int r, int k) &#123; if (l == r) return q[l]; // check if k &gt; n int x = q[l], i = l - 1, j = r + 1; while (i &lt; j) &#123; while (q[++i] &lt; x); while (q[--j] &gt; x); if ( i &lt; j) swap(q[i], q[j]); &#125; //current sorted //not j - i, should j -l, like binary search int t = j - l + 1; // how many nums before j, (+1 bc plus itself) //index if ( k &lt;= t) return quickSort(l, j, k); //try to find in the left //should k-t, like binary search return quickSort(j+1, r, k-t); // try to find in the right // k-t bc, [j+1, r]&#125;","categories":[{"name":"恰饭要紧","slug":"恰饭要紧","permalink":"http://yoursite.com/categories/%E6%81%B0%E9%A5%AD%E8%A6%81%E7%B4%A7/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"}],"author":"isFibonacci"},{"title":"Dynamic Program (1)","slug":"Dynamic Program (1)","date":"2020-02-14T23:55:00.000Z","updated":"2020-03-11T04:56:05.260Z","comments":true,"path":"2020/02/14/Dynamic Program (1)/","link":"","permalink":"http://yoursite.com/2020/02/14/Dynamic%20Program%20(1)/","excerpt":"","text":"329. Longest Increasing Path in a Matrix123456789101112131415161718192021222324252627vector&lt;vector&lt;int&gt;&gt; f; // each start point, f to record the longest wayint dx[4] = &#123;-1, 0, 1, 0&#125;, dy[4] = &#123;0, -1, 0, 1&#125;;int row, col;int dp(int x, int y, vector&lt;vector&lt;int&gt;&gt; &amp;matrix) &#123; if (f[x][y] != -1) return f[x][y]; // used f[x][y] = 1; for (int i = 0; i &lt; 4; i++) &#123; int a = x + dx[i], b = y + dy[i]; if (a &gt;= 0 &amp;&amp; a &lt; row &amp;&amp; b &gt;= 0 &amp;&amp; b &lt; col &amp;&amp; matrix[a][b] &gt; matrix[x][y]) &#123; f[x][y] = max(f[x][y], dp(a, b, matrix) + 1); // can go deeper, dfs &#125; &#125; return f[x][y];&#125;int longestIncreasingPath(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123; if (matrix.empty()) return 0; row = matrix.size(), col = matrix[0].size(); f = vector&lt;vector&lt;int&gt;&gt; (row, vector&lt;int&gt;(col, -1)); // -1 is not used int ans = 0; for ( int i = 0; i &lt; row; i++) &#123; for (int j = 0; j &lt; col; j++) &#123; ans = max(ans, dp(i, j, matrix)); &#125; &#125; return ans;&#125; 322. Coin Change123456789101112131415int coinChange(vector&lt;int&gt;&amp; coins, int amount) &#123; // enumerate the ways to generate i amount vector&lt;int&gt; dp(amount+1, amount+1); dp[0] = 0; int len = coins.size(); for (int i = 1; i &lt;= amount; i++) &#123; // each coin to make i amount for (int j = 0; j &lt; len; j++) &#123; // connot use coin, bc will overflow, 1 -5 if (coins[j] &lt;= i) dp[i] = min(dp[i], dp[i-coins[j]] + 1); // dp[2 - 2] + 1, dp[2] = amount + 1 &#125; &#125; return dp[amount] &gt; amount ? -1 : dp[amount]; // coins = [2], dp[amount] = amount + 1&#125; 221. Maximal Square12345678910111213141516171819202122232425int maximalSquare(vector&lt;vector&lt;char&gt;&gt;&amp; matrix) &#123; if (matrix.empty()) return 0; int row = matrix.size(), col = matrix[0].size(); vector&lt;vector&lt;int&gt;&gt; dp(row, vector&lt;int&gt;(col, 0)); int ans = 0; for (int i = 0; i &lt; row; i++) &#123; for (int j = 0; j &lt; col; j++) &#123; if (matrix[i][j] == '0') &#123; dp[i][j] = 0; &#125; else &#123; dp[i][j] = 1; // at least one if (i &gt;= 1 &amp;&amp; j &gt;= 1) &#123; dp[i][j] += min(dp[i-1][j], min(dp[i-1][j-1], dp[i][j-1])); // dp[i][j] as the right down point, it limit to the // other three point can generate square &#125; &#125; ans = max(ans, dp[i][j]); &#125; &#125; return ans * ans;&#125; 576. Out of Boundary Paths12345678910111213141516171819202122232425vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt; f;int dx[4] = &#123;-1, 0, 1, 0&#125;, dy[4] = &#123;0, -1, 0, 1&#125;;int mod = 1e9+7; // larget answerint findPaths(int m, int n, int N, int i, int j) &#123; // at most N times f = vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt;(m, vector&lt;vector&lt;int&gt;&gt;(n, vector&lt;int&gt;(N+1, -1))); return dp(m, n, N, i, j);&#125;int dp(int m, int n, int k, int x, int y) &#123; int &amp;v = f[x][y][k]; // at(x,y) move at most N times, paths if (v != -1) return v; // used, not need to calculate again, otherwise -&gt;O(n^3) v = 0; // not use, set it to used if (!k) return v; //Cannot move, return 0 path for (int i = 0; i &lt; 4; i++) &#123; int a = x + dx[i], b = y + dy[i]; if (a &lt; 0 || a == m || b &lt; 0 || b == n) &#123; v++; //move out, so it is a path &#125; else &#123; v += dp(m, n, k-1, a, b); // go deeper &#125; v %= mod; &#125; return v;&#125; 91. Decode Ways1234567891011121314151617181920int len = s.size();vector&lt;int&gt; dp(len+1);dp[0] = 1; // for convenience// i start from 1, bc dp[i-1], overflowfor (int i = 1; i &lt;= len; i++) &#123; //one alpha if (s[i-1] - '0' &gt; 0) &#123; dp[i] += dp[i-1]; &#125; // two alpha if (i &gt; 1) &#123; int t = ((s[i-2]-'0')*10 + s[i-1] - '0'); if (t &gt;= 10 &amp;&amp; t &lt;= 26) &#123; dp[i] += dp[i-2]; &#125; &#125;&#125;return dp[len];&#125; 264. Ugly Number II12345678910111213141516int nthUglyNumber(int n) &#123; vector&lt;int&gt; q; q.push_back(1); int i = 0, j = 0, k = 0; // pointer to 2, 3, 5 while (--n) &#123; int t = min(q[i] * 2, min(q[j]*3, q[k]*5)); q.push_back(t); if (t == q[i]*2) i++; if (t == q[j]*3) j++; if (t == q[k]*5) k++; &#125; return q.back();&#125;// 由于丑数的因子也必定是丑数，它一定是某个丑数乘2、3、5得到的，因此我们可以采用动态规划的思想，利用前面已经得到的丑数序列来得到之后的丑数，而问题的关键在于如何确定状态转移方程。由于小的丑数乘5不一定比大的丑数乘2要小，我们没法直接使用目前最大的丑数来乘2、3、5顺序得到更大的丑数。不过，我们可以确定的是，小的丑陋数乘2，肯定小于大的丑陋数乘2。所以我们使用三个指针，分别记录乘2、3、5得出的目前最大丑陋数，而新的丑数就是这三个目前最大丑数中最小的那个，那么就需要更新被选中的丑数的指针，获得新的三个目前最大丑数，依次类推，从而得到最终结果。// 时间复杂度分析：需要维护3个指针，从1到n遍历，复杂度为O(n)O(n)。 115. Distinct Subsequences1234567891011121314151617181920//f[i][j] : s[i] == t[j] forms// f[i][j] = f[i-1][j-1], s[i]==t[j]// f[i][j] = f[i-1][j], s[i] not matcht[j] :// mutexint numDistinct(string s, string t) &#123; int sLen = s.size(), tLen = t.size(); vector&lt;vector&lt;long long &gt;&gt; f(sLen+1, vector&lt;long long&gt;(tLen+1)); // f[0] has means, so over 1, n+1 // all behave i do not match j, so 1 ways(after i match) for (int i = 0; i &lt;= sLen; i++) f[i][0] = 1; for (int i = 1; i &lt;= sLen; i++) &#123; for (int j = 1; j &lt;= tLen; j++) &#123; f[i][j] = f[i-1][j]; // do not match if (s[i-1] == t[j-1]) f[i][j] += f[i-1][j-1]; &#125; &#125; return f[sLen][tLen];&#125; 132. Palindrome Partitioning II1234567891011121314151617181920int minCut(string s) &#123; int n = s.size(); vector&lt;int&gt;f(n + 1); vector&lt;vector&lt;bool&gt;&gt; st(n, vector&lt;bool&gt;(n, false)); for (int i = 0; i &lt; n; i ++ ) for (int j = i; j &gt;= 0; j -- ) if (i - j &lt;= 1) st[j][i] = s[j] == s[i]; else st[j][i] = s[j] == s[i] &amp;&amp; st[j + 1][i - 1]; f[0] = 0; for (int i = 1; i &lt;= n; i ++ ) &#123; f[i] = INT_MAX; for (int j = 0; j &lt; i; j ++ ) if (st[j][i - 1]) f[i] = min(f[i], f[j] + 1); &#125; return max(0, f[n] - 1);&#125;","categories":[{"name":"恰饭要紧","slug":"恰饭要紧","permalink":"http://yoursite.com/categories/%E6%81%B0%E9%A5%AD%E8%A6%81%E7%B4%A7/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"}],"author":"isFibonacci"},{"title":"binary-stack-queue (0)","slug":"title:BinarySearch-stack-queue","date":"2020-02-14T23:55:00.000Z","updated":"2020-02-24T06:07:13.919Z","comments":true,"path":"2020/02/14/title:BinarySearch-stack-queue/","link":"","permalink":"http://yoursite.com/2020/02/14/title:BinarySearch-stack-queue/","excerpt":"","text":"【模版】(https://www.acwing.com/blog/content/277/) 69. Sqrt(x)12345678910Example 1:Input: 4Output: 2Example 2:Input: 8Output: 2Explanation: The square root of 8 is 2.82842..., and since the decimal part is truncated, 2 is returned. 12345678910int mySqrt(int x) &#123; int l = 0, r = x; while (l &lt; r) &#123; unsigned long long int mid = (l + r &gt;&gt; 1) + 1; if (mid*mid*1ll &lt;= x) l = mid; else r = mid - 1; // let r including target &#125; return r;&#125; 34. Find First and Last Position of Element in Sorted Array12345678Example 1:Input: nums &#x3D; [5,7,7,8,8,10], target &#x3D; 8Output: [3,4]Example 2:Input: nums &#x3D; [5,7,7,8,8,10], target &#x3D; 6Output: [-1,-1] 123456789101112131415161718192021222324252627vector&lt;int&gt; searchRange(vector&lt;int&gt;&amp; nums, int target) &#123; if (nums.empty()) return vector&lt;int&gt; (&#123;-1, -1&#125;); vector&lt;int&gt; res; int l = 0, r = nums.size() - 1; //find up = right, so else is l while ( l &lt; r) &#123; int mid = l + r &gt;&gt; 1; if (nums[mid] &gt;= target) r = mid; else l = mid + 1; &#125; if (nums[r] != target) return vector&lt;int&gt; (&#123;-1, -1&#125;); res.push_back(r); // find down = left, so else is r, need to + 1 l = 0, r = nums.size() - 1; while (l &lt; r) &#123; int mid = l + r + 1&gt;&gt; 1; if (nums[mid] &lt;= target) l = mid; else r = mid - 1; &#125; res.push_back(r); // push (r) always return res;&#125; 74. Search a 2D Matrix123456789101112131415161718Input:matrix &#x3D; [ [1, 3, 5, 7], [10, 11, 16, 20], [23, 30, 34, 50]]target &#x3D; 3Output: trueExample 2:Input:matrix &#x3D; [ [1, 3, 5, 7], [10, 11, 16, 20], [23, 30, 34, 50]]target &#x3D; 13Output: false 1234567891011121314bool searchMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int target) &#123; if (matrix.size() == 0 || matrix[0].size() == 0) return false; int n = matrix.size(), m = matrix[0].size(); int l = 0, r = n * m -1; // see it as one dimension // find up = right while (l &lt; r) &#123; int mid = l + r &gt;&gt; 1; // mid / m - &gt; row, mid % m - &gt; col if (matrix[mid / m][mid % m] &gt;= target) r = mid; else l = mid + 1; &#125; return matrix[r / m][r % m] == target;&#125; 240. Search a 2D Matrix II12345678910[ [1, 4, 7, 11, 15], [2, 5, 8, 12, 19], [3, 6, 9, 16, 22], [10, 13, 14, 17, 24], [18, 21, 23, 26, 30]]Given target &#x3D; 5, return true.Given target &#x3D; 20, return false. 12345678910111213bool searchMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int target) &#123; if (matrix.empty()|| matrix[0].empty()) return false; int i = 0, j = matrix[0].size()-1; while (i &lt; matrix.size() &amp;&amp; j &gt;= 0) &#123; int t = matrix[i][j]; if (t == target) return true; if (t &gt; target) j--; // delete col else i++; &#125; return false;&#125; 153. Find Minimum in Rotated Sorted Array12345678Example 1:Input: [3,4,5,1,2] Output: 1Example 2:Input: [4,5,6,7,0,1,2]Output: 0 1234567891011121314int findMin(vector&lt;int&gt;&amp; nums) &#123; //if sorted if (nums[0] &lt; nums.back()) return nums[0]; int l = 0, r = nums.size() - 1; while ( l &lt; r) &#123; int mid = (l + r &gt;&gt; 1); // find down = left if (nums[mid] &gt;= nums[0]) l = mid + 1; else r = mid; &#125; return nums[r]; &#125; 162. Find Peak Element12345678910111213You may imagine that nums[-1] &#x3D; nums[n] &#x3D; -∞.Example 1:Input: nums &#x3D; [1,2,3,1]Output: 2Explanation: 3 is a peak element and your function should return the index number 2.Example 2:Input: nums &#x3D; [1,2,1,3,5,6,4]Output: 1 or 5 Explanation: Your function can return either index number 1 where the peak element is 2, or index number 5 where the peak element is 6. 12341. nums[i] &gt; i+1 must exist a peak at right, otherwise it is acending, then the most right is peak nums[i-1] &gt; nums[i], must exist a peak at left, otherwise it is decreasing, then the most left is peak 12345678910111213int findPeakElement(vector&lt;int&gt;&amp; nums) &#123; if (nums.size() == 1 || nums[0] &gt; nums[1] ) return 0; int l = 0, r = nums.size() - 1; while (l &lt; r) &#123; int mid = l + r + 1&gt;&gt; 1; if (nums[mid] &gt; nums[mid-1]) l = mid; else r = mid - 1; &#125; return r;&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/categories/leetcode/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"},{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/tags/leetcode/"},{"name":"binary","slug":"binary","permalink":"http://yoursite.com/tags/binary/"},{"name":"stack","slug":"stack","permalink":"http://yoursite.com/tags/stack/"},{"name":"heap","slug":"heap","permalink":"http://yoursite.com/tags/heap/"}],"author":"isFibonacci"},{"title":"Hash Table (0)","slug":"title: Hash Table (0)","date":"2020-02-13T23:55:00.000Z","updated":"2020-02-21T02:46:23.153Z","comments":true,"path":"2020/02/13/title: Hash Table (0)/","link":"","permalink":"http://yoursite.com/2020/02/13/title:%20Hash%20Table%20(0)/","excerpt":"","text":"1. Two Sum1234Given nums &#x3D; [2, 7, 11, 15], target &#x3D; 9,Because nums[0] + nums[1] &#x3D; 2 + 7 &#x3D; 9,return [0, 1]. 1234567891011vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; unordered_map&lt;int, int&gt; hash; for (int i = 0; i &lt; nums.size(); i++) &#123; int t = target - nums[i]; if (hash.count(t)) return vector&lt;int&gt;(&#123;hash[t], i&#125;); // careful here hash[nums[i]] = i; &#125; return vector&lt;int&gt;();&#125; 454. 4Sum II12345678910111213Input:A &#x3D; [ 1, 2]B &#x3D; [-2,-1]C &#x3D; [-1, 2]D &#x3D; [ 0, 2]Output:2Explanation:The two tuples are:1. (0, 0, 0, 1) -&gt; A[0] + B[0] + C[0] + D[1] &#x3D; 1 + (-2) + (-1) + 2 &#x3D; 02. (1, 1, 0, 0) -&gt; A[1] + B[1] + C[0] + D[0] &#x3D; 2 + (-1) + (-1) + 0 &#x3D; 0 12It is euqal to find the opposite value of A+BBc, A+B + C+D &#x3D; 0 &#x3D;&gt; A+B &#x3D; -C-D 12345678910111213int fourSumCount(vector&lt;int&gt;&amp; A, vector&lt;int&gt;&amp; B, vector&lt;int&gt;&amp; C, vector&lt;int&gt;&amp; D) &#123; unordered_map&lt;int, int&gt; hash; int res = 0; for (auto a : A) for (auto b : B) hash[a+b]++; for (auto c : C) for (auto d : D) res += hash[-c-d]; return res;&#125; 560. Subarray Sum Equals K123Given an array of integers and an integer k, you need to find the total number of continuous subarrays whose sum equals to k.Input:nums &#x3D; [1,1,1], k &#x3D; 2Output: 2 1234前缀合思想Need to find sum[j] - sum[i] &#x3D; k -&gt; hash[sum-k]use hash table to record previous sumhash[sum]++; 1234567891011121314151617int subarraySum(vector&lt;int&gt;&amp; nums, int k) &#123; int res = 0, sum = 0; unordered_map&lt;int, int&gt; hash; hash[0] = 1; // if the previous two meet the requirement for (auto num : nums) &#123; sum += num; // sum[j] - sum[i] = k res += hash[sum-k]; hash[sum]++; &#125; return res;&#125; 525. Contiguous Array12345678Example 1:Input: [0,1]Output: 2Explanation: [0, 1] is the longest contiguous subarray with equal number of 0 and 1.Example 2:Input: [0,1,0]Output: 2Explanation: [0, 1] (or [1, 0]) is a longest contiguous subarray with equal number of 0 and 1. 123451. 0 -&gt; -1, 1 -&gt; 1, convert question to find the length previous sum &#x3D; 02. use hash table to record the first index of previous sum &#x3D; 0;3. the max length &#x3D; i - previous sum index res &#x3D; max(i-index, res)4. hash[0] &#x3D; -1 bc [0,1] - &gt; i &#x3D; 1, i-hash[0] &#x3D; 2 1234567891011121314151617int findMaxLength(vector&lt;int&gt;&amp; nums) &#123; unordered_map&lt;int, int&gt; hash; hash[0] = -1; int sum = 0, res = 0; for (int i = 0; i &lt; nums.size(); i++) &#123; sum += nums[i] ? 1 : -1; // 0 -&gt; -1, 1 -&gt; 1 //if have if (hash.count(sum)) res = max(res, i - hash[sum]); //not have, add it into hashtable else hash[sum] = i; &#125; return res;&#125; 187. Repeated DNA Sequences123Input: s &#x3D; &quot;AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT&quot;Output: [&quot;AAAAACCCCC&quot;, &quot;CCCCCAAAAA&quot;] 1231. key is the sub string, value is the times it appear2. ++hash[sub] : add into hash, if it &#x3D;&#x3D; 1, so it&#39;s the second times it appear since we have one sub now, and another is saved in the hash table 1234567891011vector&lt;string&gt; findRepeatedDnaSequences(string s) &#123; unordered_map&lt;string, int&gt; hash; vector&lt;string&gt; res; for (int i = 0; i + 10 &lt;= s.size(); i++) &#123; string str = s.substr(i, 10); hash[str]++; if (hash[str] == 2) res.push_back(str); &#125; return res;&#125; 347. Top K Frequent Elements1234567891011121314Given a non-empty array of integers, return the k most frequent elements.Example 1:Input: nums &#x3D; [1,1,1,2,2,3], k &#x3D; 2Output: [1,2]Example 2:Input: nums &#x3D; [1], k &#x3D; 1Output: [1]**1 ≤ k ≤ number of unique elements.****OUTPUT the k most frequency, e.g. k &#x3D; 2, two numbers, k &#x3D; 3, 3 numbers****NOT K frequency** 1234561. [Counting sort](https:&#x2F;&#x2F;www.geeksforgeeks.org&#x2F;counting-sort&#x2F;), the value as it&#39;s index array index2. In the index array, the value is the index of the places index remember to decrease3. In this question, the index is the frequency, use hashtable to record the frequency and number.4. Find the cut off, and before the cut off, add them to the res. 123456789101112131415161718192021222324252627vector&lt;int&gt; topKFrequent(vector&lt;int&gt;&amp; nums, int k) &#123; unordered_map&lt;int, int&gt; hash; // recored the frequency for (auto t : nums) hash[t]++; int n = nums.size(); // genereate array vector&lt;int&gt; arr(n+1, 0); // place num in arr by the frequency for (auto t : hash) arr[t.second]++; int cut = n, t = 0; while (t &lt; k) t += arr[cut--]; vector&lt;int&gt; res; for (auto t : hash) if (t.second &gt; cut &amp;&amp; res.size() &lt; k) res.push_back(t.first); return res; &#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/categories/leetcode/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"},{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/tags/leetcode/"},{"name":"Hash Table","slug":"Hash-Table","permalink":"http://yoursite.com/tags/Hash-Table/"}],"author":"isFibonacci"},{"title":"Pointers and Dynamic Memory Allocation(2)","slug":"title:  Pointers and Dynamic Memory  2","date":"2020-02-12T01:55:00.000Z","updated":"2020-02-13T19:07:15.217Z","comments":true,"path":"2020/02/11/title:  Pointers and Dynamic Memory  2/","link":"","permalink":"http://yoursite.com/2020/02/11/title:%20%20Pointers%20and%20Dynamic%20Memory%20%202/","excerpt":"","text":"String functions with pointersstrcmp, strcpy1234567891011121314151617181920int cmp1, cmp2;char string1[10] = \"abcxyz\";char string2[10] = \"xyz\";char newText[10];char* subStr = nullptr;cmp1 = strcmp(string1, string2);cout &lt;&lt; \"strcmp of \\\"\" &lt;&lt; string1 &lt;&lt; \"\\\" and \\\"\";cout &lt;&lt; string2 &lt;&lt; \"\\\" returned \" &lt;&lt; cmp1 &lt;&lt; endl;subStr = &amp;string1[3];cmp2 = strcmp(subStr, \"xyz\");cout &lt;&lt; \"strcmp of \\\"\" &lt;&lt; subStr;cout &lt;&lt; \"\\\" and \\\"xyz\\\" returned \";cout &lt;&lt; cmp2 &lt;&lt; endl;strcpy(newText, subStr);cout &lt;&lt; \"newText is now \\\"\" &lt;&lt; newText &lt;&lt; \"\\\"\";cout &lt;&lt; endl; OUTPUT 123strcmp of &quot;abcxyz&quot; and &quot;xyz&quot; returned -23strcmp of &quot;xyz&quot; and &quot;xyz&quot; returned 0newText is now &quot;xyz&quot; strchr(), strrchr(), strstr()123456789101112131415161718192021222324char orgName[100] = \"The Dept. of Redundancy Dept.\"; char newText[100]; char* subString = nullptr;...if (strchr(orgName, 'D') != nullptr) &#123; // 'D' exists in orgName? subString = strchr(orgName, 'D'); // Points to first 'D' strcpy(newText, subString); // newText now \"Dept. of Redundancy Dept.\"&#125;...if (strrchr(orgName, 'D') != nullptr) &#123; // 'D' exists in orgName? subString = strrchr(orgName, 'D'); // Points to last 'D' strcpy(newText, subString); // newText now \"Dept.\"&#125;...subString = strstr(orgName, \"Dept\"); // Points to first 'D'if (subString != nullptr) &#123; strcpy(newText, subString); // newText now \"Dept. of Redundancy Dept.\"&#125; Memory regions: Heap/Stack upload successful Destructors upload successful When the destructors call upload successful 12listToDisplay is passed by reference, so the destructor is not called at the end of the DisplayList function. 1234567void DisplayList(LinkedList&amp; listToDisplay) &#123; LinkedListNode* node = listToDisplay.head; while(node) &#123; cout &lt;&lt; node-&gt;data &lt;&lt; \" \"; node = node-&gt;next; &#125;&#125; 12listToDisplay is not passed by pointer or by reference and goes out of scope at the end of the DisplayList function. Thus, listToDisplay&#39;s destructor is called. 1234567void DisplayList(LinkedList listToDisplay) &#123; LinkedListNode* node = listToDisplay.head; while(node) &#123; cout &lt;&lt; node-&gt;data &lt;&lt; \" \"; node = node-&gt;next; &#125;&#125; Memory leaks upload successful 1234567int main() &#123; MyClass* ptrOne = new MyClass; MyClass* ptrTwo = new MyClass; ptrOne = ptrTwo; return 0;&#125; SO MAKE SURE INITIALIZE DESTRUCTOR 123456789101112131415161718192021222324class MyClass &#123; public: MyClass() &#123; subObject = new int; *subObject = 0; &#125; ~MyClass() &#123; delete subObject; &#125; private: int* subObject;&#125;;int main() &#123; MyClass* ptrOne = new MyClass; MyClass* ptrTwo = new MyClass; ... delete ptrOne; ptrOne = ptrTwo; return 0;&#125; ```C++Vector cubes(intnumCubes){ Vector vec; for (inti= 0; i&lt; numCubes; i++) vec.add(i* i* i); return vec;} // It does, but there is an issue.// The copy constructor of the Vector class is invoked because a value is being returned.// We do not want to make copies of large objects. Vector &amp;cubes(intnumCubes){ Vector vec; for (inti= 0; i&lt; numCubes; i++) vec.add(i* i* i); return vec;} /* This is really reallybad.The scope of vecis only within the function and once the function terminates the stack is cleaned up,thus the reference to the memory location is destroyed. */ Vector cubes(intnumCubes){ Vector vec; for (inti= 0; i&lt; numCubes; i++) vec.add(i i* i); return vec;} /* This is really reallyreallybad.The scope of vecis only within the function and once the function terminates the stack is cleaned up (all local variables are destroyed),thus the reference to the memory location is destroyed.Hence the pointer is pointing at a NULL reference which eventually will cause your program to crash. */","categories":[{"name":"Program Language","slug":"Program-Language","permalink":"http://yoursite.com/categories/Program-Language/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"}],"author":"isFibonacci"},{"title":"Greedy Algorithm (2)","slug":"Greedy Algorithm (2)","date":"2020-02-11T01:55:00.000Z","updated":"2020-02-18T23:56:23.188Z","comments":true,"path":"2020/02/10/Greedy Algorithm (2)/","link":"","permalink":"http://yoursite.com/2020/02/10/Greedy%20Algorithm%20(2)/","excerpt":"","text":"376. Wiggle Subsequence1234567Input: [1,7,4,9,2,5]Output: 6Explanation: The entire sequence is a wiggle sequence.Input: [1,17,5,10,13,15,10,5,16,8]Output: 7Explanation: There are several subsequences that achieve this length. One is [1,17,10,13,10,16,8]. 1234567The longest subsequences will always start at first, to the last one.Since it is subsequence, not need to successive.Proof : [1, -1, -1, -2, 3, 2, 5, 5][-1, -2, 3, 2, 5] can see as [1, -2, 3, 2, 5]Maintain two booleans to record the previous is incr or decrMaintain previous to determind whether cur is valid 123456789101112131415161718def wiggleMaxLength(self, nums: List[int]) -&gt; int: if len(nums) &lt; 2 : return len(nums) incr, decr = True, True count = 1 prev = nums[0] for num in nums[1:] : if num &lt; prev and incr : count += 1 incr, decr = False, True elif num &gt; prev and decr : count += 1 incr, decr = True, False prev = num return count 406. Queue Reconstruction by Height123456789Suppose you have a random list of people standing in a queue. Each person is described by a pair of integers (h, k), where h is the height of the person and k is the number of people in front of this person who have a height greater than or equal to h. Write an algorithm to reconstruct the queue.Input:[[7,0], [4,4], [7,1], [5,0], [6,1], [5,2]]Output:[[5,0], [7,0], [5,2], [6,1], [4,4], [7,1]] 1234561. sort increasing2. map people higher you to index -&gt; pop() e.g [[4, 0], [5, 0]] : indexs : [0, 1] pop(0) -&gt; 0 so indexs : [1] pop(0) -&gt; 1 so pop will delete 0, and 1 will be at the index 0 12345678910111213141516171819202122def reconstructQueue(self, people: List[List[int]]) -&gt; List[List[int]]: n = len(people) if n == 0 or n == 1: return people res = [[]]*n #increasing people.sort(key = lambda x : (x[0], -x[1])) #map of index # [0, 1, 2, 3] -&gt; pop(0) = 0 : [1, 2, 3]-&gt; pop(0) = 1: [2, 3] indexs = [i for i in range(n)] for i, (_, pepHiger) in enumerate(people) : j = indexs.pop(pepHiger) #j is how many people higer and before you res[j] = people[i] return res 452. Minimum Number of Arrows to Burst Balloons12345678Input:[[10,16], [2,8], [1,6], [7,12]]Output:2Explanation:One way is to shoot one arrow for example at x &#x3D; 6 (bursting the balloons [2,8] and [1,6]) and another arrow at x &#x3D; 11 (bursting the other two balloons). 1234567891011def findMinArrowShots(self, points: List[List[int]]) -&gt; int: points.sort(key = lambda x : (x[1])) res, right = 0, float('-inf') for point in points : #new if right &lt; point[0] : res += 1 right = point[1] return res 402. Remove K Digits123Input: num &#x3D; &quot;10200&quot;, k &#x3D; 1Output: &quot;200&quot;Explanation: Remove the leading 1 and the number is 200. Note that the output must not contain leading zeroes. 123456789101112131415res = []n = len(num)if n == k : return '0'for char in num : while k and res and res[-1] &gt; char : res.pop() k -= 1 res.append(char)while k : res.pop() k -= 1return ''.join(res).lstrip('0') or \"0\"#remove leading 0, if \"\" need to return \"0\" 134. Gas Station1234567891011121314Input: gas &#x3D; [1,2,3,4,5]cost &#x3D; [3,4,5,1,2]Output: 3Explanation:Start at station 3 (index 3) and fill up with 4 unit of gas. Your tank &#x3D; 0 + 4 &#x3D; 4Travel to station 4. Your tank &#x3D; 4 - 1 + 5 &#x3D; 8Travel to station 0. Your tank &#x3D; 8 - 2 + 1 &#x3D; 7Travel to station 1. Your tank &#x3D; 7 - 3 + 2 &#x3D; 6Travel to station 2. Your tank &#x3D; 6 - 4 + 3 &#x3D; 5Travel to station 3. The cost is 5. Your gas is just enough to travel back to station 3.Therefore, return 3 as the starting index. 123451. brute force : for each station, run a loop2. # for i to j, i can only to j, i+1 can also to j, but # we don&#39;t need to try. bc when we start from i, and get to i+1 # we have more gas but still can only get to j. # Now we start from i, we have less gas, so we cannot get further than j 12345678910111213141516171819202122232425262728def canCompleteCircuit(self, gas: List[int], cost: List[int]) -&gt; int: n = len(gas) if n == 0 : return 0 i = 0 while i &lt; n : # for each station gasLeft = 0 j = 0 while j &lt; n : # j start from 0 is the same as start from i+1, a loop k = (i+j) % n gasLeft = gasLeft + gas[k] - cost[k] if gasLeft &lt; 0 : break j += 1 if j &gt;= n : # the gasLeft can make a loop return i i += j + 1 #for i to j, i can only to j, i+1 can also to j, but # we don't need to try. bc when we start from i, and get to i+1 # we have more gas but still can only get to j. #Now we start from i, we have less gas, so we cannot get further than j return -1","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/categories/leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/tags/leetcode/"},{"name":"greedy algorithm","slug":"greedy-algorithm","permalink":"http://yoursite.com/tags/greedy-algorithm/"},{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}],"author":"isFibonacci"},{"title":"Tree (0)","slug":"Tree (0)","date":"2020-02-11T01:55:00.000Z","updated":"2020-02-14T04:28:30.206Z","comments":true,"path":"2020/02/10/Tree (0)/","link":"","permalink":"http://yoursite.com/2020/02/10/Tree%20(0)/","excerpt":"","text":"235. Lowest Common Ancestor of a Binary Search Tree1234567def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -&gt; 'TreeNode': if p.val &lt; root.val and q.val &lt; root.val : return self.lowestCommonAncestor(root.left, p, q) elif p.val &gt; root.val and q.val &gt; root.val : return self.lowestCommonAncestor(root.right, p, q) else : return root 236. Lowest Common Ancestor of a Binary Tree12345678910111213141516171819202122232425ans = None def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -&gt; 'TreeNode': #LCA : find the node that p and q seperate def dfs(cur) -&gt; 'boolean' : if not cur : return False left = dfs(cur.left) #if cur node is q or p, so don't need to dfs right mid = cur == q or cur == p right = dfs(cur.right) #so don't need to dfs deep if mid+right+left &gt;= 2 : self.ans = cur #bring the ans up to previous level return mid or left or right dfs(root) return self.ans","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/categories/leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/tags/leetcode/"},{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"},{"name":"tree","slug":"tree","permalink":"http://yoursite.com/tags/tree/"}],"author":"isFibonacci"},{"title":"Pointers and Dynamic Memory Allocation(1)","slug":"title:  Pointers and Dynamic Memory All","date":"2020-02-11T01:55:00.000Z","updated":"2020-02-14T04:17:01.314Z","comments":true,"path":"2020/02/10/title:  Pointers and Dynamic Memory All/","link":"","permalink":"http://yoursite.com/2020/02/10/title:%20%20Pointers%20and%20Dynamic%20Memory%20All/","excerpt":"","text":"PointerIn vecotr, if the capacity is over size, vector will expand the size, and point toanother continous memory. reference, deference123456789101112131415int someInt;int* valPointer; someInt = 5;cout &lt;&lt; \"someInt address is \" &lt;&lt; &amp;someInt &lt;&lt; endl;valPointer = &amp;someInt; cout &lt;&lt; \"valPointer is \" &lt;&lt; valPointer &lt;&lt; endl;cout &lt;&lt; \"*valPointer is \" &lt;&lt; *valPointer &lt;&lt; endl;*valPointer = 10; // Changes someInt to 10cout &lt;&lt; \"someInt is \" &lt;&lt; someInt &lt;&lt; endl;cout &lt;&lt; \"*valPointer is \" &lt;&lt; *valPointer &lt;&lt; endl; 12345someInt address is 76valPointer is 76*valPointer is76someInt is 10*valPointer is 10 COMMON ERROR 12345671. prog.cpp:10:13: error: invalid conversion from &#39;int&#39; to &#39;int*&#39; [-fpermissive] int *ptr &#x3D; var; CORRECT : int *ptr &#x3D; &amp;var;2. Segmentation Fault (SIGSEGV), dereferencing unknown address *ptr &#x3D; var; Three ways12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//Pass-by-Value int square1(int n) &#123; //Address of n in square1() is not the same as n1 in main() cout &lt;&lt; \"address of n1 in square1(): \" &lt;&lt; &amp;n &lt;&lt; \"\\n\"; // clone modified inside the function n *= n; return n; &#125; //Pass-by-Reference with Pointer Arguments void square2(int *n) &#123; //Address of n in square2() is the same as n2 in main() cout &lt;&lt; \"address of n2 in square2(): \" &lt;&lt; n &lt;&lt; \"\\n\"; // Explicit de-referencing to get the value pointed-to *n *= *n; &#125; //Pass-by-Reference with Reference Arguments void square3(int &amp;n) &#123; //Address of n in square3() is the same as n3 in main() cout &lt;&lt; \"address of n3 in square3(): \" &lt;&lt; &amp;n &lt;&lt; \"\\n\"; // Implicit de-referencing (without '*') n *= n; &#125; ... //Call-by-Value int n1=8; cout &lt;&lt; \"address of n1 in main(): \" &lt;&lt; &amp;n1 &lt;&lt; \"\\n\"; cout &lt;&lt; \"Square of n1: \" &lt;&lt; square1(n1) &lt;&lt; \"\\n\"; cout &lt;&lt; \"No change in n1: \" &lt;&lt; n1 &lt;&lt; \"\\n\"; //Call-by-Reference with Pointer Arguments int n2=8; cout &lt;&lt; \"address of n2 in main(): \" &lt;&lt; &amp;n2 &lt;&lt; \"\\n\"; square2(&amp;n2); cout &lt;&lt; \"Square of n2: \" &lt;&lt; n2 &lt;&lt; \"\\n\"; cout &lt;&lt; \"Change reflected in n2: \" &lt;&lt; n2 &lt;&lt; \"\\n\"; //Call-by-Reference with Reference Arguments int n3=8; cout &lt;&lt; \"address of n3 in main(): \" &lt;&lt; &amp;n3 &lt;&lt; \"\\n\"; square3(n3); cout &lt;&lt; \"Square of n3: \" &lt;&lt; n3 &lt;&lt; \"\\n\"; cout &lt;&lt; \"Change reflected in n3: \" &lt;&lt; n3 &lt;&lt; \"\\n\"; ... OUTPUT 123456789101112address of n1 in main(): 0x7ffcf4d06e2caddress of n1 in square1(): 0x7ffcf4d06e0cSquare of n1: 64No change in n1: 8address of n2 in main(): 0x7ffcf4d06e30address of n2 in square2(): 0x7ffcf4d06e30Square of n2: 64Change reflected in n2: 64address of n3 in main(): 0x7ffcf4d06e34address of n3 in square3(): 0x7ffcf4d06e34Square of n3: 64Change reflected in n3: 64 COMMON ERROR 12345678910cout &lt;&lt; &quot;Square of n1: &quot; &lt;&lt; square1(n1) &lt;&lt; &quot;\\n&quot;; void square1(n1) &#123; ... cout &lt;&lt; &quot;address of n1 in square1(): &quot; &lt;&lt; &amp;n &lt;&lt; &quot;\\n&quot;; ...&#125;call square1(n1) -&gt; call cout :address of n1 in square1(): 0x7ffcf4d06e0cSquare of n1: 64 Array Name as Pointers1234567891011121314void test() &#123; //Declare an array int val[3] = &#123; 5, 10, 20 &#125;; //declare pointer variable int *ptr; //Assign the address of val[0] to ptr // We can use ptr=&amp;val[0];(both are same) ptr = val ; cout &lt;&lt; \"Elements of the array are: \"; cout &lt;&lt; ptr[0] &lt;&lt; \" \" &lt;&lt; *(++ptr) &lt;&lt; \" \" &lt;&lt; val[2]; &#125; OUTPUT 1Elements of the array are: 5 10 20 NULLWhen a pointer is declared, the pointer variable holds an unknown address until the pointer is initialized.A programmer may wish to indicate that a pointer points to “nothing” by initializing a pointer to null 12345678910111213141516171819void PrintValue(int* valuePointer) &#123; if (valuePointer == nullptr) &#123; cout &lt;&lt; \"Pointer is null\" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; *valuePointer &lt;&lt; endl; &#125;&#125;int main() &#123; int someInt = 5; int* valPointer = nullptr; PrintValue(valPointer); valPointer = &amp;someInt; PrintValue(valPointer); return 0;&#125; Operators:new, delete, and -&gt; The new operator allocates memory for the given type and returns a pointer to the allocated memory. If the type is a class, the new operator calls the class’s constructor after allocating memory for the class’s member variables. 12345678910111213141516171819202122232425262728class Point &#123;public: Point(double xValue = 0, double yValue = 0); void Print(); double X; double Y;&#125;;Point:: Point(double xValue, double yValue) &#123; X = xValue; Y = yValue;&#125;void Point::Print() &#123; cout &lt;&lt; \"(\" &lt;&lt; X &lt;&lt; \", \"; cout &lt;&lt; Y &lt;&lt; \")\" &lt;&lt; endl;&#125;int main() &#123; Point* point1 = new Point; point1-&gt;Print(); Point* point2 = new Point(8, 9); (*point2).Print(); return 0;&#125; 12type *variable &#x3D; new type; &#x2F;&#x2F; allocates one elementortype *variable &#x3D; new type[n];&#x2F;&#x2F; allocates n elements I.e. an array of type The member access operator12(*point2).Print();point2-&gt;Print(); The delete operator12345678910int main() &#123; Point* point1 = new Point(73, 19); cout &lt;&lt; \"X = \" &lt;&lt; point1-&gt;X &lt;&lt; endl; cout &lt;&lt; \"Y = \" &lt;&lt; point1-&gt;Y &lt;&lt; endl; delete point1; // Error: can't use point1 after deletion point1-&gt;Print();&#125; Allocating and deleting object arrays12345678910// Allocate pointsint pointCount = 4;Point* manyPoints = new Point[pointCount];// Display each pointfor (int i = 0; i &lt; pointCount; ++i) manyPoints[i].Print();// Free all points with one deletedelete[] manyPoints; 1234567A dynamically allocated array is freed with one statement. Objects in the array cannot be deleted individually.ERROR :for (;i &lt; n; i++) &#123; delete pointers[i];&#125; Deallocating memory12345678910111213141516171819class PaintContainer &#123; public: ~PaintContainer(); double gallonPaint;&#125;;PaintContainer::~PaintContainer() &#123; // Covered in section on Destructors. cout &lt;&lt; \"PaintContainer deallocated.\" &lt;&lt; endl;&#125;int main() &#123; PaintContainer* kitchenPaint; kitchenPaint = new PaintContainer; kitchenPaint-&gt;gallonPaint = 26.3; delete kitchenPaint; return 0;&#125; OUTOU 1PaintContainer deallocated. 12345678910111213141516171819202122class Fun&#123; public: Fun(int_size = 10):size(_size)&#123; nums= new int[size]; for(inti= 0; i&lt; size; i++) nums[i] = i + 1; &#125; void display()&#123; for(inti= 0; i&lt; size; i++) cout&lt;&lt; nums[i] &lt;&lt; “ “;std::cout&lt;&lt; ‘\\n’; &#125; ~Fun()&#123; delete [] nums; &#125; private: int size; int*nums;&#125;;int main()&#123; Fun funstuff; funstuff.display(); // destructor will be called when the block is terminated. No need to call delete return 0;&#125; 12345678...int main()&#123; Fun *moreFunstuff; // instance of Fun allocated on the heap moreFunstuff-&gt;display(); // destructor will not be called automatically. Need to call delete delete moreFunstuff; return 0;&#125; Challenge12345678910111213141516171819202122232425262728293031int k = 3, j = 5, *p = &amp;k, *q = &amp;j, *r;if (p == &amp;k) cout&lt;&lt;1&lt;&lt;endl; *p = k + 7; cout&lt;&lt;\"k = \" &lt;&lt;k&lt;&lt;\"*p =\" &lt;&lt;*p&lt;&lt;endl; cout&lt;&lt; &amp;*&amp;p &lt;&lt;endl; cout&lt;&lt; 7 * *p / *q + 7 &lt;&lt;endl; int x[10] = &#123;1, 2, 3, 4, 5&#125;; int *ptr = x; for(int i = 0; i &lt; 10; i++) cout &lt;&lt; *ptr++&lt;&lt;\" \"; cout&lt;&lt;endl; // for(int i = 0; i &lt; 10; i++) cout &lt;&lt; *x++ &lt;&lt; “ “; // *x refers to x[0] *(x+1) refers to x[1] int**intArray; intArray= new int*[8]; for(int k = 0; k &lt; 8 ; k++) intArray[k] = new int[8]; for(int r = 0; r &lt; 8; r++)&#123; for(int c = 0; c &lt; 8; c++)&#123; intArray[r][c] = 1 + rand() %100; cout&lt;&lt; setw(4) &lt;&lt; intArray[r][c] ; &#125; cout&lt;&lt; endl; &#125; for(int k = 0; k &lt; 8 ; k++) delete []intArray[k];","categories":[{"name":"Program Language","slug":"Program-Language","permalink":"http://yoursite.com/categories/Program-Language/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"}],"author":"isFibonacci"},{"title":"Inheritance and Polymorphism in C++ (3)","slug":"Inheritance and Polymorphism in C++ (3)","date":"2020-02-08T22:56:00.000Z","updated":"2020-02-14T04:16:39.649Z","comments":true,"path":"2020/02/08/Inheritance and Polymorphism in C++ (3)/","link":"","permalink":"http://yoursite.com/2020/02/08/Inheritance%20and%20Polymorphism%20in%20C++%20(3)/","excerpt":"","text":"Abstract classes: Introduction (generic)Object-oriented programming (OOP) : Classes Inheritance Abstract classes Abstract classes A pure virtual function is a virtual function that is not implemented in the base class, thus all derived classes must override the function. A pure virtual function is declared with the “virtual” keyword and is assigned with 0. Ex: virtual double ComputeArea() const = 0; declares a pure virtual function ComputeArea(). An abstract class is a class that cannot be instantiated as an object, but is the superclass for a subclass and specifies how the subclass must be implemented. Any class with one or more pure virtual functions is abstract. A concrete class is a class that is not abstract, and hence can be instantiated. 123456789101112131415161718192021222324252627282930class Shape &#123; protected: Point position; public: virtual ~Shape() &#123; &#125; virtual double ComputeArea() const = 0; Point GetPosition() const &#123; return position; &#125; void SetPosition(Point newPosition) &#123; position = newPosition; &#125; void MovePositionRelative(Point otherPosition) &#123; double x = position.GetX() + otherPosition.GetX(); double y = position.GetY() + otherPosition.GetY(); position.SetX(x); position.SetY(y); &#125;&#125;;int main(int argc, const char* argv[]) &#123; Shape* shape = new Shape(); // &lt;- ERROR!!! ...&#125; Omitting ComputeArea() makes the Circle class abstract. To be concrete, all pure virtual functions from the superclass, Shape, must be implemented. In Shape.h 1234567class Shape &#123; ... public: virtual ~Shape() &#123; &#125; virtual double ComputeArea() const = 0; ...&#125; In Circle.h 1234567891011121314class Circle : public Shape &#123; private: double radius; public: Circle(Point center, double radius) &#123; this-&gt;radius = radius; this-&gt;position = center; &#125; double ComputeArea() const &#123; return (M_PI * pow(radius, 2)); &#125;&#125;; Is-a versus has-a relationshipsCompositionThe ‘has-a’ relationship. A MotherInfo object ‘has a’ string object and ‘has a’ vector of ChildInfo objects, but no inheritance is involved. 12345678910111213141516class ChildInfo &#123; string firstName; string birthDate; string schoolName; ...&#125;;class MotherInfo &#123; string firstname; string birthDate; string spouseName; vector&lt;ChildInfo&gt; childrenData; ...&#125;; Inheritance 12345678910111213141516171819class PersonInfo &#123; string firstName; string birthDate; ...&#125;;class ChildInfo : public PersonInfo &#123; string schoolName; ...&#125;;class MotherInfo : public PersonInfo &#123; string spouseName; vector&lt;ChildInfo&gt; childrenData; ...&#125;; UML","categories":[{"name":"Program Language","slug":"Program-Language","permalink":"http://yoursite.com/categories/Program-Language/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"}],"author":"isFibonacci"},{"title":"Inheritance and Polymorphism in C++ (2)","slug":"Inheritance and Polymorphism in C++ (2)","date":"2020-02-07T22:56:00.000Z","updated":"2020-03-05T16:13:10.077Z","comments":true,"path":"2020/02/07/Inheritance and Polymorphism in C++ (2)/","link":"","permalink":"http://yoursite.com/2020/02/07/Inheritance%20and%20Polymorphism%20in%20C++%20(2)/","excerpt":"","text":"Overriding member functionsOverriding vs. overloadingIn overloading, functions with the same name must have different parameter types. In overriding, a derived class member function takes precedence over a base class member function with the same name, regardless of the parameter types. Overloading is not performed if derived and base member functions have different parameter types; the member function of the derived class hides the member function of the base class. Restaurant’s GetDescription() must be identical to Business’s GetDescription() name, return type, and parameter list. 1234567891011121314151617181920212223class Business &#123; public: ... string GetDescription() const &#123; return name + \" -- \" + address; protected: string name; string address;&#125;;class Restaurant : public Business &#123; public: ... string GetDescription() const &#123; return name + \" -- \" + address + \"\\n Rating: \" + to_string(rating); private: int rating;&#125;; Or you can call it conveniently : 12345678910class Restaurant : public Business &#123; ... string GetDescription() const &#123; return Business::GetDescription() + \"\\n Rating: \" + to_string(rating); &#125;; ...&#125;; Without the prepended base class name, the call to GetDescription() refers to itself (a recursive call) 123456789101112131415161718192021222324252627282930class Computer &#123;public: void SetComputerStatus(string cpuStatus, string internetStatus) &#123; cpuUsage = cpuStatus; internet = internetStatus; &#125;; void PrintStatus() &#123; cout &lt;&lt; \"CPU: \" &lt;&lt; cpuUsage &lt;&lt; endl; cout &lt;&lt; \"Internet: \" &lt;&lt; internet &lt;&lt; endl; &#125;;protected: string cpuUsage; string internet;&#125;;class Laptop : public Computer &#123;public: void SetComputerStatus(string cpuStatus, string internetStatus, string wifiStatus) &#123; cpuUsage = cpuStatus; internet = internetStatus; wifiQuality = wifiStatus; &#125;; void PrintStatus() &#123; Computer::PrintStatus(); cout &lt;&lt; \"WiFi: \" &lt;&lt; wifiQuality &lt;&lt; endl; &#125;; Polymorphism and virtual member functions Compile-time polymorphism is when the compiler determines which function to call at compile-time. Runtime polymorphism is when the compiler is unable to determine which function to call at compile-time, so the determination is made while the program is running. Function overloading is an example of compile-time polymorphism where the compiler determines which of several identically-named functions to call based on the function’s arguments. compile-time polymorphismconvert the Restaurant pointer to a Business pointer 1234567891011void DriveTo(string restaurant) &#123; cout &lt;&lt; \"Driving to \" &lt;&lt; restaurant &lt;&lt; endl;&#125;void DriveTo(Restaurant restaurant) &#123; cout &lt;&lt; \"Driving to \" &lt;&lt; restaurant.GetDescription() &lt;&lt; endl;&#125;int main() &#123; DriveTo(\"Big Mac's\"); // Call string version&#125; runtime polymorphism12345678910111213141516void DriveTo(Business* businessPtr) &#123; cout &lt;&lt; \"Driving to \" &lt;&lt; businessPtr-&gt;GetDescription() &lt;&lt; endl;&#125;int main() &#123; int index; vector&lt;Business*&gt; businessList; Business* businessPtr; Restaurant* restaurantPtr; ... businessList.push_back(businessPtr); businessList.push_back(restaurantPtr); index = rand() % businessList.size(); DriveTo(businessList.at(index);&#125; derived/base class pointer conversion :a pointer to a derived class is converted to a pointer to the base class without explicit casting The above statement businessList.push_back(restaurantPtr); uses derived/base class pointer conversion to convert the Restaurant pointer to a Business pointer (businessList is a vector of Business pointers). When derived/base class pointer conversion takes place, the compiler is unable to use compile-time polymorphism. Virtual functionsA virtual function is a member function that may be overridden in a derived class and is used for runtime polymorphism. 123456789101112131415161718192021222324252627282930class Business &#123;public: virtual string GetDescription() const &#123; return name + \" -- \" + address; &#125; ...&#125;;class Restaurant : public Business &#123;public: string GetDescription() const override&#123; return name + \" -- \" + address + \"\\n Rating: \" + to_string(rating); &#125; ...&#125;;int main() &#123; Business* businessPtr; Restaurant favoriteCafe; favoriteCafe.SetName(\"Friends Cafe\"); favoriteCafe.SetAddress(\"500 2nd Ave\"); favoriteCafe.SetRating(5); // Point to favoriteCafe businessPtr = &amp;favoriteCafe; cout &lt;&lt; businessPtr-&gt;GetDescription();&#125; businessPtr points to favoriteCafe. businessPtr-&gt;GetDesciption() calls Business GetDescription()instead of Restaurant GetDescription() because runtime polymorphism does not work without virtual functions. 12345678910111213141516171819202122232425class Business &#123;public: virtual string GetDescription() const &#123; return name + \" -- \" + address; &#125; ...&#125;;class Restaurant : public Business &#123;public: string GetDescription() const override &#123; return name + \" -- \" + address + \"\\n Rating: \" + to_string(rating); &#125; ...&#125;;int main() &#123; ... vector&lt;Business*&gt; businessList; Business* businessPtr; Restaurant* restaurantPtr; ...&#125; The “virtual” keyword makes GetDescription() a virtual function. The “override” keyword indicates that Restaurant GetDescription() overrides the base class GetDescription(). Running the program with an overridden virtual function causes runtime polymorphism to call Restaurant GetDescription(). Another way : 123void PrintDescription(Business&amp; business) &#123; cout &lt;&lt; business.GetDescription() &lt;&lt; endl;&#125; Runtime polymorphism only works with pointers to derived classes. 12345Restaurant favoritePlace;favoritePlace.SetName(\"Friends Cafe\");favoritePlace.SetAddress(\"500 2nd Ave\");favoritePlace.SetRating(5);cout &lt;&lt; favoritePlace.GetDescription(); The compiler can tell from the code that a Restaurant object is calling GetDescription(), so the overridden GetDescription() is called. Pure virtual functionsA pure virtual function is a virtual function that provides no definition in the base class, and all derived classes must override the function A class that has at least one pure virtual function is known as an abstract base class. An abstract base class object cannot be declared. Ex: The variable declaration Business someBusiness; generates a syntax error if Business is an abstract base class. 1234567891011121314151617181920class Business &#123;public: void SetName(string busName) &#123; name = busName; &#125; void SetAddress(string busAddress) &#123; address = busAddress; &#125; virtual string GetDescription() const &#123; return name + \" -- \" + address; &#125; virtual string GetHours() const = 0; // pure virtual functionprotected: string name; string address;&#125;;","categories":[{"name":"Program Language","slug":"Program-Language","permalink":"http://yoursite.com/categories/Program-Language/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"}],"author":"isFibonacci"},{"title":"Uniformed Search","slug":"Search","date":"2020-02-07T01:55:00.000Z","updated":"2020-02-14T04:16:45.693Z","comments":true,"path":"2020/02/06/Search/","link":"","permalink":"http://yoursite.com/2020/02/06/Search/","excerpt":"","text":"Uniformed Searcha. In deterministic environments the search solution is a single sequence (list of actions) b. Stochastic environments need multiple sequences to account for all possible outcomes of actions c. There are 5 parts to search: 1. Initial state 2. Actions possible at each state 3. Transition model (result of each action) 4. Goal test (are we there yet?) 5. Path costs/weights (not stored in states) (related to performance measure) Search algorithm BFS: FIFO The search algorithms metrics/criteria: 1. Completeness (does it terminate with a valid solution) 2. Optimality (is the answer the best solution) 3. Time (in big-O notation) 4. Space (big-O) b = maximum branching factor d = minimum depth of a goal m = maximum length of any path a. Uniform-cost search The only modification is when exploring a node we cannot disregard it if it has already been explored by another node We might have found a shorter path and thus need to update the cost on that node We also do not terminate when we find a goal, but instead when the goal has the lowest cost in the queue. UCS is.. 1. Complete (if costs strictly greater than 0) 2. Optimal However.... 3&amp;4. Time complexity = space complexity = O(b1+C*/min(path cost)), where C* cost of optimal solution (much worse than BFS) b. Bidirectional search It starts from both the goal and start (using BFS) until the trees meet This is better as 2*(bd/2) &lt; bd (the space is much worse than IDS, so only applicable to small problems)![upload successful](/images/pasted-7.png =100x) DFS: FILOMetrics: 1. Might not terminate (not correct) (e.g. in vacuum world, if first expand is action L) 2. Non-optimal (just… no) 3. Time complexity = O(bd ) 4. Space complexity = O(b*d) Only way this is better than BFS is the space complexity… DFS by itself is not great, but it has two (very) useful modifications a. Depth limited search It runs normal DFS, but if it is at a specified depth limit, you cannot have children (i.e. take another action) However, if you pick the depth limit before d, you will not find a solution (not correct, but will terminate) b. iterative deepening DFSThis search performs depth limited search with maximum depth 1, then maximum depth 2, then 3… until it finds a solution The first few states do get re-checked multiple times in IDS, however it is not too many When you find the solution at depth d, depth 1 is expanded d times (at most b of them) The second depth are expanded d-1 times (at most b2 of them) Thus upload successful Metrics: 1. Complete 2. Non-optimal (unless uniform cost) 3. O(bd ) 4. O(b*d) Thus IDS is better in every way than BFS (asymptotically) Best uninformed we will talk about","categories":[{"name":"AI","slug":"AI","permalink":"http://yoursite.com/categories/AI/"}],"tags":[{"name":"Search","slug":"Search","permalink":"http://yoursite.com/tags/Search/"}],"author":"isFibonacci"},{"title":"Greedy Algorithm (1)","slug":"greedy algorithm (1)","date":"2020-02-06T01:55:00.000Z","updated":"2020-02-14T04:16:06.928Z","comments":true,"path":"2020/02/05/greedy algorithm (1)/","link":"","permalink":"http://yoursite.com/2020/02/05/greedy%20algorithm%20(1)/","excerpt":"","text":"860. Lemonade Change1234567Input: [5,5,5,10,20]Output: trueExplanation: From the first 3 customers, we collect three $5 bills in order.From the fourth customer, we collect a $10 bill and give back a $5.From the fifth customer, we give a $10 bill and a $5 bill.Since all customers got correct change, we output true. 123451. Every time we choose the largest one to exchange, like 20 -&gt; 10 + 52. if use 10 to exchange 5 we will have 10, so ten +&#x3D; 13. for 20 case, we cannot just return false if there is not 10, since we can use 5+5+5 to exchange4. make sure temp &#x3D;&#x3D; 0t to quit, otherwise we will have negative temp 123456789101112131415161718192021222324252627282930313233class Solution: def lemonadeChange(self, bills: List[int]) -&gt; bool: five, ten = 0, 0 for cur in bills : if cur == 5 : five += 1 if cur == 10 : #need 5 if five : five -= 1 #exchange to ten, so ten +1 ten += 1 else : return False if cur == 20 : #need 15 temp = 15 if ten : ten -= 1 temp -= 10 #cannot return false, bc we can return 5+5+5 while five and temp: #make sure when temp = 0 quit, or it will loop to negative five -= 1 temp -= 5 if temp : return False return True 392. Is Subsequence123456789Example 1:s &#x3D; &quot;abc&quot;, t &#x3D; &quot;ahbgdc&quot;Return true.Example 2:s &#x3D; &quot;axc&quot;, t &#x3D; &quot;ahbgdc&quot;Return false. 11. Two pointers, make suer k lease than len(s) 123456789class Solution: def isSubsequence(self, s: str, t: str) -&gt; bool: i, k = 0, 0 while i &lt; len(t) and k &lt; len(s) : if s[k] == t[i] : k += 1 i += 1 return k == len(s) 455. Assign Cookies12345678Input: [1,2,3], [1,1]Output: 1Explanation: You have 3 children and 2 cookies. The greed factors of 3 children are 1, 2, 3. And even though you have 2 cookies, since their size is both 1, you could only make the child whose greed factor is 1 content.You need to output 1. 1234567891011121314151617181920class Solution: def findContentChildren(self, g: List[int], s: List[int]) -&gt; int: #who come first, give the cookies to him g = sorted(g) s = sorted(s) res, j = 0, 0 for i in range (len(g)) : #not satisified while j &lt; len(s) and s[j] &lt; g[i] : j += 1 #satisified if j &lt; len(s) : res += 1 #make sure j += 1, bc have used j += 1 return res 55. Jump Game1234Input: [3,2,1,0,4]Output: falseExplanation: You will always arrive at index 3 no matter what. Its maximum jump length is 0, which makes it impossible to reach the last index. 12345678910111213141516class Solution: def canJump(self, nums: List[int]) -&gt; bool: n = len(nums) if n == 0 : return True i, maxDist = 0, 0 #maxDist : the maximum position you can arrive so far while i &lt; n and i &lt;= maxDist : # if i &gt; maxDist, we cannnot get i position maxDist = max(i + nums[i], maxDist) i += 1 # [3, 1, 2, 0] -&gt; i = 0, maxDist = 3, we can arrive i = 3 maximum; # i = 2, maxDist = 2 + 2 = 4, arrive i = 4 maximum return maxDist &gt;= n-1 #not maxDist &gt;= i, bc after loop i+= 1 &gt; n-1 45. Jump Game II1234Input: [2,3,1,1,4]Output: 2Explanation: The minimum number of jumps to reach the last index is 2. Jump 1 step from index 0 to 1, then 3 steps to the last index. At i = 0, if choose jump 2 -&gt; i = 2, we can only jump 1 -&gt; i = 3we can only jump 1 -&gt; i = 4so total is 3 At i = 0, if choose jump 1 -&gt; i = 1, we can jump 3 -&gt; i = 4so total is 4 12345678910111213141516Proof : f[i] &gt; f[i+1] is wrongf[i] : the minimum steps to arrive if[i+1] : the minimum steps to arrive i+1we prove f[i] &lt;&#x3D; f[i+1] is correctAssume at j, we need to arrive at i+1. j+nums[j] &gt;&#x3D; i+1[2, 3, 1, 1, 4]j &#x3D; 0, i+1 &#x3D; 1j+nums[j] &#x3D; 0+2, we can arrive position at 2 maximumAssume we at j, and want to arrive at i+1, we need to jump plus 1f[i+1] &#x3D; f[j] + 1we can also arrive at i by f[j] + 1 steps at leastso f[i] &#x3D; f[j] + 1Hence, f[i] &lt;&#x3D; f[i+1] 123456789101112131415161718192021222324class Solution: def jump(self, nums: List[int]) -&gt; int: n = len(nums) if n == 0 or n == 1: return 0 l, r, step = 0, 0, 0 while l &lt;= r : # we check at each postion we can jump how far maxDist = 0 for i in range(l, r+1) : # want to check l == r, l &lt;= r so r+1 # maxDist : at i position, how far we can jump maxDist = max(i+nums[i], maxDist) l = r+1 # can arrive at r at least r = maxDist step += 1 if r &gt;= n-1 : break return step","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/categories/leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/tags/leetcode/"},{"name":"greedy algorithm","slug":"greedy-algorithm","permalink":"http://yoursite.com/tags/greedy-algorithm/"},{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}],"author":"isFibonacci"},{"title":"Inheritance and Polymorphism in C++ (1)","slug":"Inheritance and Polymorphism in C++ (1)","date":"2020-02-05T22:56:00.000Z","updated":"2020-03-05T16:00:54.963Z","comments":true,"path":"2020/02/05/Inheritance and Polymorphism in C++ (1)/","link":"","permalink":"http://yoursite.com/2020/02/05/Inheritance%20and%20Polymorphism%20in%20C++%20(1)/","excerpt":"","text":"Access by members of derived classesThe members of a derived class have access to the public members of the base class, but not to the private members of the base class. 1234567891011121314151617181920212223class Business &#123; public: ... private: string name; string address;&#125;;class Restaurant : public Business &#123; public: ... void DisplayRestaurant() &#123; cout &lt;&lt; name &lt;&lt; endl; cout &lt;&lt; address &lt;&lt; endl; cout &lt;&lt; \" Rating: \" &lt;&lt; rating &lt;&lt; endl; &#125; private: int rating;&#125;; Solution :But! Careful here : A third access specifier is protected, which provides access to derived classes but not by anyone else. 1234567891011121314151617181920212223242526272829303132333435363738394041class Business &#123; public: // Members accessible by anyone void PrintMembers(); protected: // Members accessible by self and derived classes string name; private: // Members accessible only by self string address;&#125;;class Restaurant : public Business &#123; ... // Attempted accesses PrintMembers(); // OK name = \"Gyro Hero\"; // OK (\"protected\" above made this possible) address = \"5 Fifth St\"; // ERROR ...&#125;;int main() &#123; ... Business business; Restaurant restaurant; ... // Attempted accesses business.PrintMembers(); // OK business.name = \"Gyro Hero\"; // ERROR (protected only applies to derived classes) business.address = \"5 Fifth St\"; // ERROR restaurant.PrintMembers(); // OK restaurant.name = \"Gyro Hero\"; // ERROR restaurant.rating = 5; // ERROR return 0;&#125; Overriding vs. overloading1234In overloading, functions with the same name must have different parameter types.In overriding, a derived class member function takes precedence over a base class member function with the same name, regardless of the parameter types. 123456789101112131415161718192021222324252627282930313233343536373839404142class Computer &#123;public: void SetComputerStatus(string cpuStatus, string internetStatus) &#123; cpuUsage = cpuStatus; internet = internetStatus; &#125;; void PrintStatus() &#123; cout &lt;&lt; \"CPU: \" &lt;&lt; cpuUsage &lt;&lt; endl; cout &lt;&lt; \"Internet: \" &lt;&lt; internet &lt;&lt; endl; &#125;;protected: string cpuUsage; string internet;&#125;;class Laptop : public Computer &#123;public: void SetWiFiStatus(string wifiStatus) &#123; wifiQuality = wifiStatus; &#125;; void PrintStatus() &#123; cout &lt;&lt; \"CPU: \" &lt;&lt; cpuUsage &lt;&lt; endl; cout &lt;&lt; \"WiFi: \" &lt;&lt; wifiQuality &lt;&lt; endl; &#125;;private: string wifiQuality;&#125;;int main() &#123; Laptop myLaptop; myLaptop.SetComputerStatus(\"20%\", \"connected\"); myLaptop.SetWiFiStatus(\"good\"); myLaptop.PrintStatus(); return 0;&#125; Compile-time polymorphism vs. runtime polymorphism.12345678910111213141516171819202122232425262728293031// compile-time polymorphismvoid DriveTo(string restaurant) &#123; cout &lt;&lt; \"Driving to \" &lt;&lt; restaurant &lt;&lt; endl;&#125;void DriveTo(Restaurant restaurant) &#123; cout &lt;&lt; \"Driving to \" &lt;&lt; restaurant.GetDescription() &lt;&lt; endl;&#125;int main() &#123; DriveTo(\"Big Mac's\"); // Call string version&#125;// runtime polymorphismvoid DriveTo(Business* businessPtr) &#123; cout &lt;&lt; \"Driving to \" &lt;&lt; businessPtr-&gt;GetDescription() &lt;&lt; endl;&#125;int main() &#123; int index; vector&lt;Business*&gt; businessList; Business* businessPtr; Restaurant* restaurantPtr; ... businessList.push_back(businessPtr); businessList.push_back(restaurantPtr); index = rand() % businessList.size(); DriveTo(businessList.at(index);&#125; virtual function1Runtime polymorphism only works when an overridden member function in a base class is virtual. 1234567891011121314151617181920212223242526272829class Business &#123;public: virtual string GetDescription() const &#123; return name + \" -- \" + address; &#125; ...&#125;;class Restaurant : public Business &#123;public: string GetDescription() const override&#123; return name + \" -- \" + address + \"\\n Rating: \" + to_string(rating); &#125; ...&#125;;int main() &#123; Business* businessPtr; Restaurant favoriteCafe; favoriteCafe.SetName(\"Friends Cafe\"); favoriteCafe.SetAddress(\"500 2nd Ave\"); favoriteCafe.SetRating(5); // Point to favoriteCafe businessPtr = &amp;favoriteCafe; cout &lt;&lt; businessPtr-&gt;GetDescription();&#125; 123456No virtual functionFriends Cafe -- 500 2nd AveWith virtual functionFriends Cafe -- 500 2nd AveRating: 5","categories":[{"name":"Program Language","slug":"Program-Language","permalink":"http://yoursite.com/categories/Program-Language/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"}],"author":"isFibonacci"},{"title":"Heap","slug":"title: Heap","date":"2020-02-01T23:55:00.000Z","updated":"2020-02-23T15:39:07.941Z","comments":true,"path":"2020/02/01/title: Heap/","link":"","permalink":"http://yoursite.com/2020/02/01/title:%20Heap/","excerpt":"","text":"AcWing 838. 堆排序123451. Insert : hedp[++size] &#x3D; x; up(size) O(logn)2. Min : heap[1]3. Delete min : heap[1] &#x3D; heap[size]; size--; down(1);4. Delete any : heap[k] &#x3D; heap[size]; size--; down(k); up(k);5. heap[k] &#x3D; x; down(k); up(k); 12345678910111213141516171819202122232425262728const int N = 100010;int n, m;int h[N], size;void down(int root) &#123; int min = root; if (root*2 &lt;= size &amp;&amp; h[root*2] &lt; h[min]) min = root*2; // left if (root*2 + 1 &lt;= size &amp;&amp; h[root*2+1] &lt; h[min]) min = root*2 + 1; //right if (root != min) &#123; swap(h[root], h[min]); down(min); &#125;&#125;int main() &#123; scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 0; i &lt;= n; i++) scanf(\"%d\", &amp;h[i]); size = n; for (int i = n / 2; i; i--) down(i); while (m--) &#123; printf(\"%d\", h[1]); h[1] = h[size]; size--; down(1); &#125;&#125; 839. 模拟堆12345678void heap_swap(itn a, int b) &#123; // heap pointer : index map to element // pointer heap : map index // ph[j] = k, hp[k] = j -&gt; ph[hp[k]] swap(ph[hp[a]], ph[hp[b]]); swap(hp[a], hp[b]); //index swap(h[a], h[b]);&#125; 692. Top K Frequent Words12345678910Example 1:Input: [&quot;i&quot;, &quot;love&quot;, &quot;leetcode&quot;, &quot;i&quot;, &quot;love&quot;, &quot;coding&quot;], k &#x3D; 2Output: [&quot;i&quot;, &quot;love&quot;]Explanation: &quot;i&quot; and &quot;love&quot; are the two most frequent words. Note that &quot;i&quot; comes before &quot;love&quot; due to a lower alphabetical order.Example 2:Input: [&quot;the&quot;, &quot;day&quot;, &quot;is&quot;, &quot;sunny&quot;, &quot;the&quot;, &quot;the&quot;, &quot;the&quot;, &quot;sunny&quot;, &quot;is&quot;, &quot;is&quot;], k &#x3D; 4Output: [&quot;the&quot;, &quot;is&quot;, &quot;sunny&quot;, &quot;day&quot;]Explanation: &quot;the&quot;, &quot;is&quot;, &quot;sunny&quot; and &quot;day&quot; are the four most frequent words, with the number of occurrence being 4, 3, 2 and 1 respectively. 1234561. Priority queue is max-heap, -item.second -&gt; min-heap bc pop the top, will remove the most frequency, but we want the most frequency2. if the heap is full, pop out the worest.3. WARNING : priority queue. if the frequency is the same, choose the bigger alphabet but we want lower alphabetical order comes first. 123456789101112131415161718192021222324252627vector&lt;string&gt; topKFrequent(vector&lt;string&gt;&amp; words, int k) &#123; unordered_map&lt;string, int&gt; hash; //&lt;frequency, string&gt; typedef pair&lt;int, string&gt; obj; // same above, for push into heap priority_queue&lt;obj&gt; heap; for (auto word : words) hash[word]++; for (auto item : hash) &#123; // make pair, -frequency is the lowest in the max-heap obj temp(-item.second, item.first); heap.push(temp); // if full, pop if (heap.size() &gt; k) heap.pop(); &#125; // 3. add to res vector&lt;string&gt; res(k); // -frequency is the max, top is the min, so reverse for (int i = k-1 ; i &gt;= 0; i--) &#123; res[i] = heap.top().second; heap.pop(); &#125; return res;&#125; 295. Find Median from Data Stream123456Median is the middle value in an ordered integer list. If the size of the list is even, there is no middle value. So the median is the mean of the two middle value.For example,[2,3,4], the median is 3[2,3], the median is (2 + 3) &#x2F; 2 &#x3D; 2.5 12345678up : min-heap, down : max-heap;if x &gt;&#x3D; down.top(), insert up, if x &lt; down.top(), insert down 7 8 \\ &#x2F; 6 5 &#x2F; \\ 3 4 123456789101112131415161718192021222324252627282930class MedianFinder &#123;public: /** initialize your data structure here. */ priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; up; //min- priority_queue&lt;int&gt; down; // max-heap MedianFinder() &#123; &#125; void addNum(int num) &#123; if (down.empty() || num &gt;= down.top()) up.push(num); else &#123; // every time also add to up, so we only need to maintiain one side down.push(num); up.push(down.top()); down.pop(); &#125; if (up.size() &gt; down.size()+1) &#123; down.push(up.top()); up.pop(); &#125; &#125; double findMedian() &#123; // odd if (down.size() + up.size() &amp; 1) return up.top(); else return ( down.top() + up.top()) / 2.0; &#125;&#125;; 352. Data Stream as Disjoint Intervals123456789Given a data stream input of non-negative integers a1, a2, ..., an, ..., summarize the numbers seen so far as a list of disjoint intervals.For example, suppose the integers from the data stream are 1, 3, 7, 2, 6, ..., then the summary will be:[1, 1][1, 1], [3, 3][1, 1], [3, 3], [7, 7][1, 3], [7, 7][1, 3], [6, 7] 1234567891011121314151617181920212223242526272829303132333435363738394041class SummaryRanges &#123;public: /** Initialize your data structure here. */ map&lt;int, int&gt; L, R; SummaryRanges() &#123; &#125; void addNum(int x) &#123; if (L.size()) &#123; auto it = L.lower_bound(x); if (it != L.end() &amp;&amp; it -&gt;second &lt;= x) return; // x 已经在某个区间 &#125; int left = L.count(x-1), right = R.count(x+1); if (left &amp;&amp; right) &#123; R[L[x-1]] = R[x+1]; L[R[x+1]] = L[x-1]; L.erase(x-1), R.erase(x+1); &#125; else if (left) &#123; R[L[x-1]] = x; L[x] = L[x-1]; L.erase(x-1); &#125; else if (right) &#123; L[R[x + 1]] = x; R[x] = R[x + 1]; R.erase(x + 1); &#125; else &#123; R[x] = L[x] = x; &#125; &#125; vector&lt;vector&lt;int&gt;&gt; getIntervals() &#123; vector&lt;vector&lt;int&gt;&gt; res; for(auto item : R) res.push_back(&#123;item.first, item.second&#125;); return res; &#125;&#125;;","categories":[{"name":"yxcNb","slug":"yxcNb","permalink":"http://yoursite.com/categories/yxcNb/"}],"tags":[{"name":"Data Structure","slug":"Data-Structure","permalink":"http://yoursite.com/tags/Data-Structure/"}],"author":"isFibonacci"},{"title":"并查集","slug":"title: 并查集","date":"2020-02-01T23:55:00.000Z","updated":"2020-02-22T21:47:01.001Z","comments":true,"path":"2020/02/01/title: 并查集/","link":"","permalink":"http://yoursite.com/2020/02/01/title:%20%E5%B9%B6%E6%9F%A5%E9%9B%86/","excerpt":"","text":"【Disjoint-set】1234567891011操作 ： 1. 将两个集合合并2. 询问两个元素是否在一个集合中基本原理 ： 将每个集合用一颗树来表示。树根的编号就是整个集合的编号。每个节点存储它的父节点， p[x]表示x的父节点问题 ： 1. 如何判断树根： if(p[x] &#x3D;&#x3D; x)2. 如何求x的集合编号： while (p[x] !&#x3D; x) x &#x3D; p[x];3. 如何合并两个集合： px 是 x 的集合编号， py 是 y的集合编号。p[x] &#x3D; y 836. 合并集合12345678910111213141516171819202122232425262728293031const int N = 100010;int n, m;int p[N];// return x's ancestor (path compress)int find(int x) &#123; if (p[x] != x) // find it's ancestor p[x] = find(p[x]); // update x's father is it's father's ancestor return p[x];&#125;int main() &#123; scanf(\"%d%d\", &amp;n, &amp;m); // make initial for (int i = 1; i &lt;= n; i++) p[i] = i; while (m--) &#123; char op[2]; int a, b; scanf(\"%s%d%d\", op, &amp;a, &amp;b); // find a reutrn a's ancestor, find b return b's ... // let a's ancestor's father become b'ancestor if (op[0] == 'M') p[find(a)] = find(b); else &#123; if (find(a) == find(b)) puts(\"Yes\"); else puts(\"No\"); &#125; &#125; return 0;&#125; 547. Friend Circles123456789101112131415Input: [[1,1,0], [1,1,0], [0,0,1]]Output: 2Explanation:The 0th and 1st students are direct friends, so they are in a friend circle. The 2nd student himself is in a friend circle. So return 2.Input: [[1,1,0], [1,1,1], [0,1,1]]Output: 1Explanation:The 0th and 1st students are direct friends, the 1st and 2nd students are direct friends, so the 0th and 2nd students are indirect friends. All of them are in the same friend circle, so return 1. 121. each person as a set2. if p[i] !&#x3D; i, that means there is a circle 1234567891011121314151617181920212223242526272829303132class Solution &#123;public: vector&lt;int&gt; p; int find(int x) &#123; if (p[x] != x) p[x] = find(p[x]); return p[x]; &#125; int findCircleNum(vector&lt;vector&lt;int&gt;&gt;&amp; M) &#123; int n = M[0].size(); for (int i = 0; i &lt; n; i++) p.push_back(i); // let each person as a set int res = n; for (int i = 0; i &lt; n; i++) &#123; // only need to check one half // has checked 0th and 1th, don't need to check 1th and 0th // and don't need to check ourself for (int j = 0; j &lt; i; j++) &#123; if (M[i][j] == 0) continue; // if ith don't belong to i // i = 0, find(0) = 1 if (find(i) != find(j)) &#123; p[find(i)] = find(j); res --; // combine 0 and 1, so the number of sets --; &#125; &#125; &#125; return res; &#125;&#125;; 684. Redundant Connection1234567891011121314Example 1:Input: [[1,2], [1,3], [2,3]]Output: [2,3]Explanation: The given undirected graph will be like this: 1 &#x2F; \\2 - 3Example 2:Input: [[1,2], [2,3], [3,4], [1,4], [1,5]]Output: [1,4]Explanation: The given undirected graph will be like this:5 - 1 - 2 | | 4 - 3 1231. add each edge into a set, if two edge has the same ancestorthat means we find a aboundant, otherwise we update the ancestor with current edge 1234567891011121314151617181920212223class Solution &#123;public: vector&lt;int&gt; p; int find(int x) &#123; if (p[x] != x) return p[x] = find(p[x]); return p[x]; &#125; vector&lt;int&gt; findRedundantConnection(vector&lt;vector&lt;int&gt;&gt;&amp; edges) &#123; for (int i = 0 ; i &lt;= edges.size(); i++) p.push_back(i); for (auto e : edges) &#123; int a = e[0], b = e[1]; // [3,4], [1,4], // find(3) = 3, find(4) = 3, find(1) = 3 -&gt; return &#123;1, 4&#125; if (find(a) == find(b)) return &#123;a, b&#125;; p[find(a)] = find(b); &#125; return &#123;-1, -1&#125;; &#125;&#125;;","categories":[{"name":"yxcNb","slug":"yxcNb","permalink":"http://yoursite.com/categories/yxcNb/"}],"tags":[{"name":"-Data Structure","slug":"Data-Structure","permalink":"http://yoursite.com/tags/Data-Structure/"}],"author":"isFibonacci"},{"title":"Informed search","slug":"Informed-search","date":"2020-01-17T22:18:00.000Z","updated":"2020-02-14T04:16:18.442Z","comments":true,"path":"2020/01/17/Informed-search/","link":"","permalink":"http://yoursite.com/2020/01/17/Informed-search/","excerpt":"","text":"In uninformed search, we only had the nodeinformation (parent, children, cost of actions) Now we will assume there is some additionalinformation, we will call a heuristic thatestimates the distance to the goal Previously, we had no idea how close we wereto goal, simply how far we had gone already 1. Greedy best-first searchThis search will simply repeatedly select thechild with the lowest heuristic(cost to goal est.) In fact, it is not guaranteed to converge (if apath reaches a dead-end, it will loop infinitely) 2. A* (a star) upload successful Priority queues can be used to efficiently storeand insert states and their f-values into the fringe Good heuristics can remove “bad” sections of the search space that will not be on any optimal solution (called pruning) A* is optimal and in fact, no optimal algorithm could expand less nodes (optimally efficient) However, the time and memory cost is still exponential (memory tighter constraint) 2.1 Iterative deepening A* Run DFS in IDS, but instead of using depthas cutoff, use f-cost If search fails to find goal, increase f-costto next smallest seen value (above old cost) Pros: Efficient on memory Cons: Large (LARGE) amount of re-searching","categories":[{"name":"AI","slug":"AI","permalink":"http://yoursite.com/categories/AI/"}],"tags":[],"author":"isFibonacci"},{"title":"Comparison of Greedy Search Algorithms","slug":"Comparison of Greedy Search Algo","date":"2020-01-10T22:18:00.000Z","updated":"2020-02-14T04:15:52.496Z","comments":true,"path":"2020/01/10/Comparison of Greedy Search Algo/","link":"","permalink":"http://yoursite.com/2020/01/10/Comparison%20of%20Greedy%20Search%20Algo/","excerpt":"","text":"best-first searches: weighted A*, greedy search, A∗ǫ , window A* multi-state commitment k-weighted A*. hill climbing algorithms : hill climb- ing LSS-LRTA* beam searches : BULB beam-stack search pathfinding in grids (Thayer, Ruml, and Bitton 2008), the traveling salesman problem (Pearl and Kim 1982), dynamic robot pathfinding (Likhachev, Gordon, and Thrun 2003), the sliding tile puzzle (Korf 1985), the pancake puzzle (Holte, Grajkowskic, and Tanner 2005), and a vacuum-robot domain (Russell and Norvig 2010).","categories":[{"name":"AI","slug":"AI","permalink":"http://yoursite.com/categories/AI/"}],"tags":[],"author":"isFibonacci"},{"title":"Some thoughts on AI","slug":"Some-thoughts-about-AI","date":"2020-01-06T03:45:00.000Z","updated":"2020-02-14T04:15:26.160Z","comments":true,"path":"2020/01/05/Some-thoughts-about-AI/","link":"","permalink":"http://yoursite.com/2020/01/05/Some-thoughts-about-AI/","excerpt":"","text":"Recently, there has been a lot of concerns about AI(artificial intelligence), like AI will make people lose jobs and the tech oligarch will make wealth inequality; in brief, AI will raise abundant social issues over than its advantage to society. On the contrary, some people argues that AI will bring abundant jobs instead. Like in the past, some people concerned that industrial revolution will take away people’s jobs but we know this revolution promote society development and then bring many opening jobs. However, I still believe there are many reasons to be concerned about advances of AI. As the automation is developing, we can see in the near future; millions of people will be replaced by the machines. The reasons I concerned are that there are many advantages in automation over than humans. First, machines will never feel tired. Mentioned in this article, I believe ”the self-driving trucks promised by Tesla’s Elon Musk become widely available in the next decade.” (Bossmann, 2016). Human drivers need to take a break after long driving, but self-driving trucks not. Self-driving car can keep long driving during the midnight to avoid rush hours in the daytime, and self-driving car has a lower risk of accidents than humans after long driving. Absolutely, transportation company will hire robots to drive rather than humans in obvious these advances. Hence, we can see in the near future; AI will take away many people’s jobs, and the unemployment rate will be increasing rapidly. What if AI turn to hurt humans? Hollywood movies have presented many AI disasters for us. And in this article, the author mentioned a vivid example: in order to kill the cancer, the machine kills everyone on the planet instead, which is more efficient. (Bossmann, 2016). As we know, the real world is really complicated. It is hard to just use some if-else statements to cover all the cases, like we are hard to predicate the future. So, in more specific, how can we ensure that the robot will not hurt human in a complicate case like rescue hostages? How can we ensure human will still dominate the world if one day we totally lose the ingenuity and intelligence than AI? As one day AI can evolve them very efficiently by iteration? How can we protect ourselves if robots start to attack people? How can we ensure we can still dominate the world, not AI dominate us? Or AI can just create a pandemic breaks out the world, which is the most efficient way to kill all the organism on this planet. Or like the movie, The Matrix, people are imprisoned in a container as a energy source? Obviously, there are still many issues that AI will bring to us. So I believe govern- ments, industries, and academics should take some steps to address these issues. First, since the automation take place of many people’s job, the unemployment rate will be in- creasing. Government should make some effectual policy to against unemployment. For example, Andrew Yang proposes government to pay one thousand dollars each month to every American over the age of 18. This money is from company’s VAT(A Value-Added Tax), and then people use the money to consumer company’s product. (Yang, 2020). This is a double win. No need to say, there are still a lot of issues that AI will bring to us in the future, but government should take its strong right to control these issues. Second, industries and academics should make some principles or agreement during the AI development. Like The Institute for Ethical ML, this academic institute make 8 principles when designing and developing AI and ML.(for Ethical AI ML, 2020). In that 8 principles, the developer commit to assess and handle the impact of incorrect result. So I believe the developers can take a great effort to avoid accident due to AI, and even when the accident happens, they can reduce losses. In brief, We have reasons to be concerned about advances of AI.And there are still many steps to address these issues, but the only principle we need to make sure is, artificial intelligence is conducive to improving the efficiency of social work and promoting social development. References J. Bossmann. Top 9 ethical issues in artificial intelligence. 2016. URL https://www.weforum.org/agenda/2016/10/top-10-ethical-issues -in-artificial-intelligence.I. for Ethical AI ML. The 7 Most Pressing Ethical Issues in Artificial Intelligence. 2020. URL https://ethical.institute/principles.html.A. Yang. VALUE-ADDED TAX. 2020. URL https://www.yang2020.com/policies/value-added-tax/.","categories":[{"name":"AI","slug":"AI","permalink":"http://yoursite.com/categories/AI/"}],"tags":[],"author":"isFibonacci"},{"title":"Build your own blog","slug":"hello-world","date":"2020-01-01T15:22:00.000Z","updated":"2020-02-14T15:52:44.720Z","comments":true,"path":"2020/01/01/hello-world/","link":"","permalink":"http://yoursite.com/2020/01/01/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment Change ThemeThe theme I used in this blog is cited from yscoder 1.git clone -&gt; after all install -&gt; move theme to your hexo theme and 12hexo ghexo d Careful here, if in the _config.yml you set it as 123deploy: type: git branch: master The hexo d will delete your custom domin name!What should do is here","categories":[],"tags":[],"author":"isFibonacci"}]}